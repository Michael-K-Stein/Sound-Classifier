<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=wAPX1HepqA24RkYW1AuHYA');.lst-kix_i1pgzx846xn2-5>li{counter-increment:lst-ctn-kix_i1pgzx846xn2-5}.lst-kix_ezntvu52khpf-7>li{counter-increment:lst-ctn-kix_ezntvu52khpf-7}ol.lst-kix_i1pgzx846xn2-7.start{counter-reset:lst-ctn-kix_i1pgzx846xn2-7 0}.lst-kix_uqp80nmditom-7>li{counter-increment:lst-ctn-kix_uqp80nmditom-7}ol.lst-kix_2diqapx2bjy0-3.start{counter-reset:lst-ctn-kix_2diqapx2bjy0-3 0}ol.lst-kix_9wjr3fbj6zuq-5.start{counter-reset:lst-ctn-kix_9wjr3fbj6zuq-5 0}ol.lst-kix_uqp80nmditom-6.start{counter-reset:lst-ctn-kix_uqp80nmditom-6 0}.lst-kix_9wjr3fbj6zuq-8>li{counter-increment:lst-ctn-kix_9wjr3fbj6zuq-8}.lst-kix_82vovlm3s7ys-0>li{counter-increment:lst-ctn-kix_82vovlm3s7ys-0}ol.lst-kix_82vovlm3s7ys-3.start{counter-reset:lst-ctn-kix_82vovlm3s7ys-3 0}.lst-kix_i1pgzx846xn2-7>li{counter-increment:lst-ctn-kix_i1pgzx846xn2-7}ol.lst-kix_ezntvu52khpf-4.start{counter-reset:lst-ctn-kix_ezntvu52khpf-4 0}.lst-kix_uqp80nmditom-5>li:before{content:"" counter(lst-ctn-kix_uqp80nmditom-5,lower-roman) ". "}.lst-kix_uqp80nmditom-6>li:before{content:"" counter(lst-ctn-kix_uqp80nmditom-6,decimal) ". "}ol.lst-kix_uqp80nmditom-0.start{counter-reset:lst-ctn-kix_uqp80nmditom-0 0}.lst-kix_2diqapx2bjy0-0>li{counter-increment:lst-ctn-kix_2diqapx2bjy0-0}.lst-kix_uqp80nmditom-3>li:before{content:"" counter(lst-ctn-kix_uqp80nmditom-3,decimal) ". "}.lst-kix_uqp80nmditom-4>li:before{content:"" counter(lst-ctn-kix_uqp80nmditom-4,lower-latin) ". "}.lst-kix_uqp80nmditom-7>li:before{content:"" counter(lst-ctn-kix_uqp80nmditom-7,lower-latin) ". "}.lst-kix_uqp80nmditom-8>li:before{content:"" counter(lst-ctn-kix_uqp80nmditom-8,lower-roman) ". "}ol.lst-kix_uqp80nmditom-7.start{counter-reset:lst-ctn-kix_uqp80nmditom-7 0}ol.lst-kix_82vovlm3s7ys-8.start{counter-reset:lst-ctn-kix_82vovlm3s7ys-8 0}ol.lst-kix_ezntvu52khpf-3.start{counter-reset:lst-ctn-kix_ezntvu52khpf-3 0}.lst-kix_uqp80nmditom-0>li:before{content:"" counter(lst-ctn-kix_uqp80nmditom-0,decimal) ". "}.lst-kix_2diqapx2bjy0-7>li{counter-increment:lst-ctn-kix_2diqapx2bjy0-7}.lst-kix_uqp80nmditom-1>li:before{content:"" counter(lst-ctn-kix_uqp80nmditom-1,lower-latin) ". "}.lst-kix_uqp80nmditom-2>li:before{content:"" counter(lst-ctn-kix_uqp80nmditom-2,lower-roman) ". "}.lst-kix_i1pgzx846xn2-7>li:before{content:"" counter(lst-ctn-kix_i1pgzx846xn2-7,lower-latin) ". "}ol.lst-kix_2diqapx2bjy0-4.start{counter-reset:lst-ctn-kix_2diqapx2bjy0-4 0}ol.lst-kix_uqp80nmditom-1.start{counter-reset:lst-ctn-kix_uqp80nmditom-1 0}.lst-kix_i1pgzx846xn2-5>li:before{content:"" counter(lst-ctn-kix_i1pgzx846xn2-5,lower-roman) ". "}.lst-kix_i1pgzx846xn2-6>li:before{content:"" counter(lst-ctn-kix_i1pgzx846xn2-6,decimal) ". "}.lst-kix_i1pgzx846xn2-0>li:before{content:"" counter(lst-ctn-kix_i1pgzx846xn2-0,decimal) ". "}.lst-kix_i1pgzx846xn2-8>li:before{content:"" counter(lst-ctn-kix_i1pgzx846xn2-8,lower-roman) ". "}ol.lst-kix_9wjr3fbj6zuq-5{list-style-type:none}ol.lst-kix_9wjr3fbj6zuq-4{list-style-type:none}ol.lst-kix_9wjr3fbj6zuq-3{list-style-type:none}ol.lst-kix_9wjr3fbj6zuq-2{list-style-type:none}ol.lst-kix_9wjr3fbj6zuq-1{list-style-type:none}.lst-kix_i1pgzx846xn2-1>li:before{content:"" counter(lst-ctn-kix_i1pgzx846xn2-1,lower-latin) ". "}ol.lst-kix_9wjr3fbj6zuq-0{list-style-type:none}.lst-kix_i1pgzx846xn2-2>li:before{content:"" counter(lst-ctn-kix_i1pgzx846xn2-2,lower-roman) ". "}.lst-kix_i1pgzx846xn2-3>li:before{content:"" counter(lst-ctn-kix_i1pgzx846xn2-3,decimal) ". "}.lst-kix_82vovlm3s7ys-2>li{counter-increment:lst-ctn-kix_82vovlm3s7ys-2}ol.lst-kix_9wjr3fbj6zuq-0.start{counter-reset:lst-ctn-kix_9wjr3fbj6zuq-0 0}.lst-kix_9wjr3fbj6zuq-6>li{counter-increment:lst-ctn-kix_9wjr3fbj6zuq-6}.lst-kix_i1pgzx846xn2-4>li:before{content:"" counter(lst-ctn-kix_i1pgzx846xn2-4,lower-latin) ". "}.lst-kix_b91ee1teiew4-6>li:before{content:"\0025cf  "}.lst-kix_2diqapx2bjy0-3>li{counter-increment:lst-ctn-kix_2diqapx2bjy0-3}ol.lst-kix_i1pgzx846xn2-4{list-style-type:none}.lst-kix_82vovlm3s7ys-8>li{counter-increment:lst-ctn-kix_82vovlm3s7ys-8}ol.lst-kix_i1pgzx846xn2-5{list-style-type:none}ol.lst-kix_i1pgzx846xn2-6{list-style-type:none}ol.lst-kix_i1pgzx846xn2-7{list-style-type:none}ol.lst-kix_i1pgzx846xn2-0{list-style-type:none}ol.lst-kix_i1pgzx846xn2-1{list-style-type:none}.lst-kix_ezntvu52khpf-1>li{counter-increment:lst-ctn-kix_ezntvu52khpf-1}.lst-kix_b91ee1teiew4-8>li:before{content:"\0025a0  "}ol.lst-kix_i1pgzx846xn2-2{list-style-type:none}ol.lst-kix_9wjr3fbj6zuq-6.start{counter-reset:lst-ctn-kix_9wjr3fbj6zuq-6 0}ol.lst-kix_i1pgzx846xn2-3{list-style-type:none}.lst-kix_b91ee1teiew4-2>li:before{content:"\0025a0  "}.lst-kix_82vovlm3s7ys-7>li{counter-increment:lst-ctn-kix_82vovlm3s7ys-7}.lst-kix_b91ee1teiew4-4>li:before{content:"\0025cb  "}.lst-kix_ezntvu52khpf-3>li{counter-increment:lst-ctn-kix_ezntvu52khpf-3}.lst-kix_82vovlm3s7ys-6>li{counter-increment:lst-ctn-kix_82vovlm3s7ys-6}ol.lst-kix_i1pgzx846xn2-6.start{counter-reset:lst-ctn-kix_i1pgzx846xn2-6 0}.lst-kix_9wjr3fbj6zuq-2>li{counter-increment:lst-ctn-kix_9wjr3fbj6zuq-2}.lst-kix_b91ee1teiew4-0>li:before{content:"\0025cf  "}ol.lst-kix_2diqapx2bjy0-2.start{counter-reset:lst-ctn-kix_2diqapx2bjy0-2 0}.lst-kix_uqp80nmditom-0>li{counter-increment:lst-ctn-kix_uqp80nmditom-0}.lst-kix_82vovlm3s7ys-1>li:before{content:"" counter(lst-ctn-kix_82vovlm3s7ys-1,lower-latin) ". "}ol.lst-kix_ezntvu52khpf-0.start{counter-reset:lst-ctn-kix_ezntvu52khpf-0 0}ol.lst-kix_ezntvu52khpf-0{list-style-type:none}ol.lst-kix_ezntvu52khpf-2{list-style-type:none}ol.lst-kix_ezntvu52khpf-1{list-style-type:none}ol.lst-kix_ezntvu52khpf-4{list-style-type:none}.lst-kix_2diqapx2bjy0-0>li:before{content:"" counter(lst-ctn-kix_2diqapx2bjy0-0,decimal) ". "}ol.lst-kix_ezntvu52khpf-3{list-style-type:none}.lst-kix_82vovlm3s7ys-3>li:before{content:"" counter(lst-ctn-kix_82vovlm3s7ys-3,decimal) ". "}ol.lst-kix_ezntvu52khpf-6{list-style-type:none}ol.lst-kix_ezntvu52khpf-5{list-style-type:none}ol.lst-kix_ezntvu52khpf-8{list-style-type:none}ol.lst-kix_uqp80nmditom-0{list-style-type:none}ol.lst-kix_ezntvu52khpf-7{list-style-type:none}.lst-kix_82vovlm3s7ys-5>li:before{content:"" counter(lst-ctn-kix_82vovlm3s7ys-5,lower-roman) ". "}ol.lst-kix_uqp80nmditom-1{list-style-type:none}ol.lst-kix_uqp80nmditom-2{list-style-type:none}ol.lst-kix_uqp80nmditom-3{list-style-type:none}ol.lst-kix_uqp80nmditom-4{list-style-type:none}.lst-kix_2diqapx2bjy0-2>li:before{content:"" counter(lst-ctn-kix_2diqapx2bjy0-2,lower-roman) ". "}.lst-kix_82vovlm3s7ys-7>li:before{content:"" counter(lst-ctn-kix_82vovlm3s7ys-7,lower-latin) ". "}.lst-kix_9wjr3fbj6zuq-1>li{counter-increment:lst-ctn-kix_9wjr3fbj6zuq-1}.lst-kix_9wjr3fbj6zuq-7>li{counter-increment:lst-ctn-kix_9wjr3fbj6zuq-7}ol.lst-kix_i1pgzx846xn2-8.start{counter-reset:lst-ctn-kix_i1pgzx846xn2-8 0}ol.lst-kix_9wjr3fbj6zuq-4.start{counter-reset:lst-ctn-kix_9wjr3fbj6zuq-4 0}.lst-kix_i1pgzx846xn2-3>li{counter-increment:lst-ctn-kix_i1pgzx846xn2-3}.lst-kix_uqp80nmditom-5>li{counter-increment:lst-ctn-kix_uqp80nmditom-5}.lst-kix_2diqapx2bjy0-2>li{counter-increment:lst-ctn-kix_2diqapx2bjy0-2}ol.lst-kix_2diqapx2bjy0-1.start{counter-reset:lst-ctn-kix_2diqapx2bjy0-1 0}ol.lst-kix_uqp80nmditom-5{list-style-type:none}ol.lst-kix_uqp80nmditom-6{list-style-type:none}ol.lst-kix_uqp80nmditom-7{list-style-type:none}.lst-kix_ezntvu52khpf-8>li{counter-increment:lst-ctn-kix_ezntvu52khpf-8}ol.lst-kix_uqp80nmditom-8{list-style-type:none}ol.lst-kix_i1pgzx846xn2-8{list-style-type:none}.lst-kix_ezntvu52khpf-2>li{counter-increment:lst-ctn-kix_ezntvu52khpf-2}.lst-kix_2diqapx2bjy0-4>li:before{content:"" counter(lst-ctn-kix_2diqapx2bjy0-4,lower-latin) ". "}.lst-kix_2diqapx2bjy0-8>li:before{content:"" counter(lst-ctn-kix_2diqapx2bjy0-8,lower-roman) ". "}ol.lst-kix_9wjr3fbj6zuq-3.start{counter-reset:lst-ctn-kix_9wjr3fbj6zuq-3 0}.lst-kix_2diqapx2bjy0-6>li:before{content:"" counter(lst-ctn-kix_2diqapx2bjy0-6,decimal) ". "}ol.lst-kix_2diqapx2bjy0-4{list-style-type:none}ol.lst-kix_82vovlm3s7ys-6.start{counter-reset:lst-ctn-kix_82vovlm3s7ys-6 0}ol.lst-kix_2diqapx2bjy0-3{list-style-type:none}ol.lst-kix_2diqapx2bjy0-2{list-style-type:none}ol.lst-kix_2diqapx2bjy0-1{list-style-type:none}ol.lst-kix_2diqapx2bjy0-0{list-style-type:none}.lst-kix_82vovlm3s7ys-1>li{counter-increment:lst-ctn-kix_82vovlm3s7ys-1}ol.lst-kix_9wjr3fbj6zuq-2.start{counter-reset:lst-ctn-kix_9wjr3fbj6zuq-2 0}.lst-kix_2diqapx2bjy0-8>li{counter-increment:lst-ctn-kix_2diqapx2bjy0-8}ol.lst-kix_2diqapx2bjy0-0.start{counter-reset:lst-ctn-kix_2diqapx2bjy0-0 0}.lst-kix_ezntvu52khpf-5>li:before{content:"" counter(lst-ctn-kix_ezntvu52khpf-5,lower-roman) ". "}.lst-kix_9wjr3fbj6zuq-6>li:before{content:"" counter(lst-ctn-kix_9wjr3fbj6zuq-6,decimal) ". "}.lst-kix_9wjr3fbj6zuq-7>li:before{content:"" counter(lst-ctn-kix_9wjr3fbj6zuq-7,lower-latin) ". "}ol.lst-kix_82vovlm3s7ys-0.start{counter-reset:lst-ctn-kix_82vovlm3s7ys-0 0}.lst-kix_ezntvu52khpf-6>li{counter-increment:lst-ctn-kix_ezntvu52khpf-6}ol.lst-kix_ezntvu52khpf-1.start{counter-reset:lst-ctn-kix_ezntvu52khpf-1 0}.lst-kix_ezntvu52khpf-6>li:before{content:"" counter(lst-ctn-kix_ezntvu52khpf-6,decimal) ". "}.lst-kix_9wjr3fbj6zuq-4>li:before{content:"" counter(lst-ctn-kix_9wjr3fbj6zuq-4,lower-latin) ". "}.lst-kix_9wjr3fbj6zuq-5>li:before{content:"" counter(lst-ctn-kix_9wjr3fbj6zuq-5,lower-roman) ". "}.lst-kix_9wjr3fbj6zuq-8>li:before{content:"" counter(lst-ctn-kix_9wjr3fbj6zuq-8,lower-roman) ". "}.lst-kix_ezntvu52khpf-7>li:before{content:"" counter(lst-ctn-kix_ezntvu52khpf-7,lower-latin) ". "}.lst-kix_ezntvu52khpf-8>li:before{content:"" counter(lst-ctn-kix_ezntvu52khpf-8,lower-roman) ". "}ol.lst-kix_2diqapx2bjy0-6.start{counter-reset:lst-ctn-kix_2diqapx2bjy0-6 0}.lst-kix_82vovlm3s7ys-3>li{counter-increment:lst-ctn-kix_82vovlm3s7ys-3}ol.lst-kix_9wjr3fbj6zuq-8.start{counter-reset:lst-ctn-kix_9wjr3fbj6zuq-8 0}.lst-kix_9wjr3fbj6zuq-0>li:before{content:"" counter(lst-ctn-kix_9wjr3fbj6zuq-0,decimal) ". "}.lst-kix_9wjr3fbj6zuq-1>li:before{content:"" counter(lst-ctn-kix_9wjr3fbj6zuq-1,lower-latin) ". "}.lst-kix_9wjr3fbj6zuq-2>li:before{content:"" counter(lst-ctn-kix_9wjr3fbj6zuq-2,lower-roman) ". "}.lst-kix_9wjr3fbj6zuq-3>li:before{content:"" counter(lst-ctn-kix_9wjr3fbj6zuq-3,decimal) ". "}.lst-kix_uqp80nmditom-6>li{counter-increment:lst-ctn-kix_uqp80nmditom-6}.lst-kix_i1pgzx846xn2-4>li{counter-increment:lst-ctn-kix_i1pgzx846xn2-4}ol.lst-kix_ezntvu52khpf-7.start{counter-reset:lst-ctn-kix_ezntvu52khpf-7 0}.lst-kix_2diqapx2bjy0-6>li{counter-increment:lst-ctn-kix_2diqapx2bjy0-6}.lst-kix_82vovlm3s7ys-0>li:before{content:"" counter(lst-ctn-kix_82vovlm3s7ys-0,decimal) ". "}ol.lst-kix_2diqapx2bjy0-5.start{counter-reset:lst-ctn-kix_2diqapx2bjy0-5 0}.lst-kix_i1pgzx846xn2-2>li{counter-increment:lst-ctn-kix_i1pgzx846xn2-2}.lst-kix_9wjr3fbj6zuq-0>li{counter-increment:lst-ctn-kix_9wjr3fbj6zuq-0}.lst-kix_82vovlm3s7ys-5>li{counter-increment:lst-ctn-kix_82vovlm3s7ys-5}.lst-kix_ezntvu52khpf-4>li{counter-increment:lst-ctn-kix_ezntvu52khpf-4}.lst-kix_i1pgzx846xn2-8>li{counter-increment:lst-ctn-kix_i1pgzx846xn2-8}.lst-kix_uqp80nmditom-4>li{counter-increment:lst-ctn-kix_uqp80nmditom-4}ol.lst-kix_9wjr3fbj6zuq-1.start{counter-reset:lst-ctn-kix_9wjr3fbj6zuq-1 0}ol.lst-kix_9wjr3fbj6zuq-7.start{counter-reset:lst-ctn-kix_9wjr3fbj6zuq-7 0}ol.lst-kix_i1pgzx846xn2-5.start{counter-reset:lst-ctn-kix_i1pgzx846xn2-5 0}.lst-kix_2diqapx2bjy0-1>li{counter-increment:lst-ctn-kix_2diqapx2bjy0-1}.lst-kix_ezntvu52khpf-4>li:before{content:"" counter(lst-ctn-kix_ezntvu52khpf-4,lower-latin) ". "}.lst-kix_ezntvu52khpf-2>li:before{content:"" counter(lst-ctn-kix_ezntvu52khpf-2,lower-roman) ". "}ol.lst-kix_82vovlm3s7ys-7.start{counter-reset:lst-ctn-kix_82vovlm3s7ys-7 0}.lst-kix_ezntvu52khpf-3>li:before{content:"" counter(lst-ctn-kix_ezntvu52khpf-3,decimal) ". "}ol.lst-kix_uqp80nmditom-8.start{counter-reset:lst-ctn-kix_uqp80nmditom-8 0}.lst-kix_ezntvu52khpf-0>li:before{content:"" counter(lst-ctn-kix_ezntvu52khpf-0,decimal) ". "}.lst-kix_ezntvu52khpf-1>li:before{content:"" counter(lst-ctn-kix_ezntvu52khpf-1,lower-latin) ". "}ol.lst-kix_i1pgzx846xn2-4.start{counter-reset:lst-ctn-kix_i1pgzx846xn2-4 0}ol.lst-kix_82vovlm3s7ys-1.start{counter-reset:lst-ctn-kix_82vovlm3s7ys-1 0}ol.lst-kix_ezntvu52khpf-2.start{counter-reset:lst-ctn-kix_ezntvu52khpf-2 0}ol.lst-kix_2diqapx2bjy0-8{list-style-type:none}ol.lst-kix_2diqapx2bjy0-7{list-style-type:none}ol.lst-kix_2diqapx2bjy0-6{list-style-type:none}ol.lst-kix_2diqapx2bjy0-5{list-style-type:none}ol.lst-kix_i1pgzx846xn2-0.start{counter-reset:lst-ctn-kix_i1pgzx846xn2-0 0}.lst-kix_9wjr3fbj6zuq-3>li{counter-increment:lst-ctn-kix_9wjr3fbj6zuq-3}ol.lst-kix_uqp80nmditom-2.start{counter-reset:lst-ctn-kix_uqp80nmditom-2 0}ol.lst-kix_ezntvu52khpf-5.start{counter-reset:lst-ctn-kix_ezntvu52khpf-5 0}.lst-kix_b91ee1teiew4-7>li:before{content:"\0025cb  "}ol.lst-kix_9wjr3fbj6zuq-8{list-style-type:none}ol.lst-kix_9wjr3fbj6zuq-7{list-style-type:none}ol.lst-kix_i1pgzx846xn2-3.start{counter-reset:lst-ctn-kix_i1pgzx846xn2-3 0}ol.lst-kix_9wjr3fbj6zuq-6{list-style-type:none}.lst-kix_b91ee1teiew4-1>li:before{content:"\0025cb  "}.lst-kix_9wjr3fbj6zuq-4>li{counter-increment:lst-ctn-kix_9wjr3fbj6zuq-4}.lst-kix_uqp80nmditom-1>li{counter-increment:lst-ctn-kix_uqp80nmditom-1}ol.lst-kix_82vovlm3s7ys-2.start{counter-reset:lst-ctn-kix_82vovlm3s7ys-2 0}.lst-kix_2diqapx2bjy0-4>li{counter-increment:lst-ctn-kix_2diqapx2bjy0-4}ol.lst-kix_ezntvu52khpf-8.start{counter-reset:lst-ctn-kix_ezntvu52khpf-8 0}ol.lst-kix_uqp80nmditom-5.start{counter-reset:lst-ctn-kix_uqp80nmditom-5 0}.lst-kix_b91ee1teiew4-5>li:before{content:"\0025a0  "}.lst-kix_b91ee1teiew4-3>li:before{content:"\0025cf  "}.lst-kix_ezntvu52khpf-0>li{counter-increment:lst-ctn-kix_ezntvu52khpf-0}.lst-kix_9wjr3fbj6zuq-5>li{counter-increment:lst-ctn-kix_9wjr3fbj6zuq-5}.lst-kix_i1pgzx846xn2-1>li{counter-increment:lst-ctn-kix_i1pgzx846xn2-1}.lst-kix_82vovlm3s7ys-2>li:before{content:"" counter(lst-ctn-kix_82vovlm3s7ys-2,lower-roman) ". "}.lst-kix_uqp80nmditom-3>li{counter-increment:lst-ctn-kix_uqp80nmditom-3}.lst-kix_82vovlm3s7ys-4>li:before{content:"" counter(lst-ctn-kix_82vovlm3s7ys-4,lower-latin) ". "}ol.lst-kix_82vovlm3s7ys-4.start{counter-reset:lst-ctn-kix_82vovlm3s7ys-4 0}.lst-kix_2diqapx2bjy0-1>li:before{content:"" counter(lst-ctn-kix_2diqapx2bjy0-1,lower-latin) ". "}.lst-kix_2diqapx2bjy0-3>li:before{content:"" counter(lst-ctn-kix_2diqapx2bjy0-3,decimal) ". "}ol.lst-kix_82vovlm3s7ys-3{list-style-type:none}ul.lst-kix_b91ee1teiew4-2{list-style-type:none}ol.lst-kix_82vovlm3s7ys-2{list-style-type:none}ul.lst-kix_b91ee1teiew4-3{list-style-type:none}.lst-kix_82vovlm3s7ys-4>li{counter-increment:lst-ctn-kix_82vovlm3s7ys-4}ol.lst-kix_82vovlm3s7ys-5{list-style-type:none}.lst-kix_82vovlm3s7ys-6>li:before{content:"" counter(lst-ctn-kix_82vovlm3s7ys-6,decimal) ". "}.lst-kix_82vovlm3s7ys-8>li:before{content:"" counter(lst-ctn-kix_82vovlm3s7ys-8,lower-roman) ". "}ol.lst-kix_uqp80nmditom-3.start{counter-reset:lst-ctn-kix_uqp80nmditom-3 0}ul.lst-kix_b91ee1teiew4-0{list-style-type:none}ol.lst-kix_82vovlm3s7ys-4{list-style-type:none}ul.lst-kix_b91ee1teiew4-1{list-style-type:none}ol.lst-kix_82vovlm3s7ys-7{list-style-type:none}ul.lst-kix_b91ee1teiew4-6{list-style-type:none}ol.lst-kix_82vovlm3s7ys-6{list-style-type:none}ul.lst-kix_b91ee1teiew4-7{list-style-type:none}ol.lst-kix_i1pgzx846xn2-2.start{counter-reset:lst-ctn-kix_i1pgzx846xn2-2 0}ul.lst-kix_b91ee1teiew4-4{list-style-type:none}ol.lst-kix_82vovlm3s7ys-8{list-style-type:none}ul.lst-kix_b91ee1teiew4-5{list-style-type:none}.lst-kix_uqp80nmditom-8>li{counter-increment:lst-ctn-kix_uqp80nmditom-8}ul.lst-kix_b91ee1teiew4-8{list-style-type:none}ol.lst-kix_2diqapx2bjy0-8.start{counter-reset:lst-ctn-kix_2diqapx2bjy0-8 0}ol.lst-kix_82vovlm3s7ys-1{list-style-type:none}ol.lst-kix_82vovlm3s7ys-0{list-style-type:none}ol.lst-kix_82vovlm3s7ys-5.start{counter-reset:lst-ctn-kix_82vovlm3s7ys-5 0}.lst-kix_i1pgzx846xn2-6>li{counter-increment:lst-ctn-kix_i1pgzx846xn2-6}ol.lst-kix_ezntvu52khpf-6.start{counter-reset:lst-ctn-kix_ezntvu52khpf-6 0}.lst-kix_uqp80nmditom-2>li{counter-increment:lst-ctn-kix_uqp80nmditom-2}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_2diqapx2bjy0-5>li{counter-increment:lst-ctn-kix_2diqapx2bjy0-5}.lst-kix_i1pgzx846xn2-0>li{counter-increment:lst-ctn-kix_i1pgzx846xn2-0}ol.lst-kix_2diqapx2bjy0-7.start{counter-reset:lst-ctn-kix_2diqapx2bjy0-7 0}.lst-kix_2diqapx2bjy0-5>li:before{content:"" counter(lst-ctn-kix_2diqapx2bjy0-5,lower-roman) ". "}.lst-kix_2diqapx2bjy0-7>li:before{content:"" counter(lst-ctn-kix_2diqapx2bjy0-7,lower-latin) ". "}ol.lst-kix_uqp80nmditom-4.start{counter-reset:lst-ctn-kix_uqp80nmditom-4 0}ol.lst-kix_i1pgzx846xn2-1.start{counter-reset:lst-ctn-kix_i1pgzx846xn2-1 0}.lst-kix_ezntvu52khpf-5>li{counter-increment:lst-ctn-kix_ezntvu52khpf-5}ol{margin:0;padding:0}table td,table th{padding:0}.c70{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:311.2pt;border-top-color:#000000;border-bottom-style:solid}.c37{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:451.4pt;border-top-color:#000000;border-bottom-style:solid}.c72{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:102.8pt;border-top-color:#000000;border-bottom-style:solid}.c26{margin-left:36pt;padding-top:16pt;padding-left:0pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c35{margin-left:36pt;padding-top:0pt;text-indent:-36pt;padding-bottom:0pt;line-height:2.0;orphans:2;widows:2;text-align:left}.c38{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left;height:18pt}.c55{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center;height:20pt}.c28{margin-left:54pt;padding-top:3pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c54{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c39{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c59{padding-top:12pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c75{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c2{color:#0000ff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c19{margin-left:36pt;padding-top:3pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c36{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c44{margin-left:72pt;padding-top:3pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c42{margin-left:18pt;padding-top:3pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c52{padding-top:14pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c10{padding-top:0pt;padding-bottom:16pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c17{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c69{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c74{-webkit-text-decoration-skip:none;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-style:normal}.c76{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:right}.c22{padding-top:10pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c0{background-color:#fffffe;padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c86{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;text-align:center}.c53{margin-left:72pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c81{padding-top:10pt;padding-bottom:4pt;line-height:1.0;text-align:left}.c27{color:#000000;font-weight:400;font-size:12pt;font-family:"Calibri"}.c43{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c9{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c20{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c64{padding-top:12pt;padding-bottom:0pt;line-height:1.0;text-align:center}.c60{margin-left:36pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c51{border-spacing:0;border-collapse:collapse;margin-right:auto}.c31{padding-top:12pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c6{color:#008000;text-decoration:none;vertical-align:baseline;font-style:normal}.c83{background-color:#ffffff;max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.c68{border-spacing:0;border-collapse:collapse;margin-right:auto}.c57{color:#000000;font-size:12pt;font-family:"Times New Roman"}.c4{font-family:"Times New Roman";color:#000000;font-weight:400}.c3{font-size:12pt;font-family:"Times New Roman";font-weight:400}.c15{text-decoration:none;vertical-align:baseline;font-style:normal}.c80{orphans:2;widows:2}.c84{margin-left:70.9pt;padding-left:0pt}.c33{margin-left:108pt;padding-left:0pt}.c73{margin-left:36pt;padding-left:0pt}.c24{padding:0;margin:0}.c63{color:#000000;font-family:"Times New Roman"}.c8{color:inherit;text-decoration:inherit}.c77{background-color:#ffffff;color:#222222}.c16{font-family:"Times New Roman";font-weight:400}.c40{margin-left:72pt;padding-left:0pt}.c14{color:#a31515}.c49{color:#404040}.c85{font-size:30pt}.c12{height:12pt}.c41{margin-left:106.3pt}.c56{font-size:20pt}.c79{height:20pt}.c65{font-size:15pt}.c21{color:#4864aa}.c58{margin-left:72pt}.c47{height:16pt}.c34{height:0pt}.c13{vertical-align:sub}.c46{text-indent:36pt}.c48{font-weight:700}.c82{font-family:"Times New Roman"}.c18{font-size:16pt}.c29{font-style:italic}.c50{color:#3030c0}.c66{margin-left:108pt}.c32{font-size:18pt}.c25{color:#2b91af}.c71{color:#008080}.c62{font-size:50pt}.c7{color:#098658}.c61{font-size:12pt}.c78{margin-left:36pt}.c45{color:#808080}.c67{height:14pt}.c23{font-size:14pt}.c30{color:#008000}.c5{color:#0000ff}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:12pt;font-family:"Times New Roman"}p{margin:0;color:#000000;font-size:12pt;font-family:"Times New Roman"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:18pt;padding-bottom:6pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#000000;font-size:16pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#000000;font-size:14pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#000000;font-size:12pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#000000;font-size:12pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c83"><div><p class="c17"><span>Michael Kuperfish Steinberg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>/</span></p></div><p class="c76"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 134.20px; height: 204.52px;"><img alt="&#1488;&#1500;&#1497;&#1508;&#1493;&#1514; &#1492;&#1488;&#1489;&#1497;&#1489; &#1489;&#1499;&#1508;&#1512; &#1492;&#1497;&#1512;&#1493;&#1511;" src="images/image11.png" style="width: 134.20px; height: 204.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c75 c12 title" id="h.dtkt6uf5l3h6"><span class="c4 c15 c62"></span></p><p class="c75 title" id="h.wgf87ja4wknn"><span class="c4 c15 c62">Sound Classifier</span></p><p class="c10 subtitle" id="h.2xr9icfykbv9"><span class="c4 c15 c65">How Sophisticated Can A Non-Organic Object&rsquo;s Musical Hearing Become Utilizing Neural Networks?</span></p><p class="c69 c12"><span class="c4 c15 c65"></span></p><p class="c69 c12"><span class="c4 c15 c65"></span></p><p class="c69"><span class="c1">A Computer Science Research Project</span></p><p class="c69"><span class="c4 c15 c56">By Michael Kuperfish Steinberg</span></p><p class="c69"><span class="c1">I.D. 214288912</span></p><p class="c69"><span class="c4 c15 c65">HaKfar HaYarok 2020</span></p><p class="c69"><span class="c4 c15 c65">Advisor: Yooda Or</span></p><p class="c69 c12"><span class="c4 c15 c65"></span></p><hr style="page-break-before:always;display:none;"><p class="c17 c12"><span class="c4 c15 c85"></span></p><p class="c17"><span class="c57 c74">Student Contact Information:</span></p><p class="c17"><span class="c48">Name:</span><span class="c1">&nbsp;Michael Kuperfish Steinberg ( &#1502;&#1497;&#1499;&#1488;&#1500; &#1511;&#1493;&#1508;&#1512;&#1508;&#1497;&#1513; &#1513;&#1496;&#1497;&#1497;&#1504;&#1489;&#1512;&#1490; )</span></p><p class="c17"><span class="c48">I.D.:</span><span class="c1">&nbsp;214288912</span></p><p class="c17"><span class="c48">Date of Birth:</span><span class="c1">&nbsp;01/06/2003</span></p><p class="c17"><span class="c48">Address:</span><span class="c1">&nbsp;Oppenheimer 6, Tel Aviv</span></p><p class="c17"><span class="c48">Tel:</span><span class="c1">&nbsp;+972-58-676-2020</span></p><p class="c17"><span class="c48">Email:</span><span>&nbsp;</span><span class="c20"><a class="c8" href="mailto:m.kuper.steinberg@gmail.com">m.kuper.steinberg@gmail.com</a></span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span class="c74 c57">General Information:</span></p><p class="c17"><span class="c48">School:</span><span class="c1">&nbsp;&#1492;&#1499;&#1508;&#1512; &#1492;&#1497;&#1512;&#1493;&#1511; &#1506;&quot;&#1513; &#1500;&#1493;&#1497; &#1488;&#1513;&#1499;&#1493;&#1500;</span></p><p class="c17"><span class="c48">School Tel:</span><span class="c1">&nbsp;03-645-5666</span></p><p class="c17"><span class="c48">Field:</span><span class="c1">&nbsp;Computer Science</span></p><p class="c17"><span class="c48 c61">Study Units:</span><span class="c61">&nbsp;5 Units</span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span class="c74 c57">Advisor Contact Information:</span></p><p class="c17"><span class="c48">Advisor: </span><span class="c1">Yooda Or ( &#1497;&#1492;&#1493;&#1491;&#1492; &#1488;&#1493;&#1512; )</span></p><p class="c17"><span class="c48">I.D.:</span><span class="c1">&nbsp;023098007</span></p><p class="c17"><span class="c48">Tel:</span><span class="c1">&nbsp;+972-50-734-4457</span></p><p class="c17"><span class="c48">Email:</span><span>&nbsp;</span><span class="c20"><a class="c8" href="mailto:yoooda@gmail.com">yoooda@gmail.com</a></span></p><p class="c17"><span class="c48">Address: </span><span class="c1">HaKerem 3, Tel Aviv</span></p><p class="c17"><span class="c48">Academic Degree:</span><span class="c1">&nbsp;MA Engineer, Technion Certified Engineer, Microsoft Certified, Academic transfer to Computer Science on behalf of the country since the year 2000.</span></p><p class="c17"><span class="c48">Workplaces:</span><span class="c1">&nbsp;Weizmann Institute of Technology, John Bryce College, HaKfar HaYarok, Youth Engineering College of Computer Science.</span></p><p class="c17 c12"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><h1 class="c36 c79" id="h.uzxytrf9vqpr"><span class="c1"></span></h1><h1 class="c36" id="h.fgnzam9lbbzn"><span class="c1">Table of contents:</span></h1><p class="c22"><span class="c9 c63 c48"><a class="c8" href="#h.hds9hl5hocod">Theoretical Background</a></span><span class="c9 c63 c48">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c63 c48"><a class="c8" href="#h.hds9hl5hocod">5</a></span></p><p class="c22"><span class="c57 c15 c48"><a class="c8" href="#h.n3aje4quob27">C++ Research</a></span><span class="c57 c15 c48">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c57 c15 c48"><a class="c8" href="#h.n3aje4quob27">8</a></span></p><p class="c42"><span class="c1"><a class="c8" href="#h.6cgb2mn4fcqd">OOP - Object Oriented Programming</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.6cgb2mn4fcqd">8</a></span></p><p class="c19"><span class="c1"><a class="c8" href="#h.olcmpnopy3pm">Encapsulation</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.olcmpnopy3pm">8</a></span></p><p class="c19"><span class="c1"><a class="c8" href="#h.j9iyytszo3ry">Inheritance</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.j9iyytszo3ry">9</a></span></p><p class="c19"><span class="c1"><a class="c8" href="#h.dlh12jc2eqiq">Polymorphism</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.dlh12jc2eqiq">10</a></span></p><p class="c42"><span class="c1"><a class="c8" href="#h.ihrlc1lrddvk">Evolvement - Practical Research</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.ihrlc1lrddvk">13</a></span></p><p class="c19"><span class="c1"><a class="c8" href="#h.njlz6y7k98vc">Calling Conventions</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.njlz6y7k98vc">13</a></span></p><p class="c19"><span class="c1"><a class="c8" href="#h.u7klqhmk015v">Parameter Types</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.u7klqhmk015v">15</a></span></p><p class="c19"><span class="c1"><a class="c8" href="#h.ooqsm4qiitcd">Arrays vs Vectors</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.ooqsm4qiitcd">16</a></span></p><p class="c22"><span class="c57 c15 c48"><a class="c8" href="#h.xkkpa3sxzye">Machine Learning</a></span><span class="c57 c15 c48">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c15 c48 c57"><a class="c8" href="#h.xkkpa3sxzye">21</a></span></p><p class="c42"><span class="c9 c4"><a class="c8" href="#h.7r3yjq2rk36s">Introduction</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.7r3yjq2rk36s">21</a></span></p><p class="c42"><span class="c9 c4"><a class="c8" href="#h.d0lw3r9kdj3z">Concept and Theory</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.d0lw3r9kdj3z">21</a></span></p><p class="c42"><span class="c1"><a class="c8" href="#h.h8nhutqjmjdd">MNIST Database - Handwritten Digits</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.h8nhutqjmjdd">22</a></span></p><p class="c19"><span class="c9 c4"><a class="c8" href="#h.pa6fgry1mcbn">Code</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.pa6fgry1mcbn">23</a></span></p><p class="c28"><span class="c9 c4"><a class="c8" href="#h.yzbeymaeqult">data.h + data.cpp</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.yzbeymaeqult">23</a></span></p><p class="c28"><span class="c9 c4"><a class="c8" href="#h.i977r5qf9475">data_handler.h + data_handler.cpp</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.i977r5qf9475">26</a></span></p><p class="c28"><span class="c9 c4"><a class="c8" href="#h.fvgndexjddzk">common_data.h + common_data.cpp</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.fvgndexjddzk">33</a></span></p><p class="c28"><span class="c9 c4"><a class="c8" href="#h.7i1yk8c9jq3r">Graphic.h + Graphic.cpp</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.7i1yk8c9jq3r">35</a></span></p><p class="c19"><span class="c9 c4"><a class="c8" href="#h.ng6x7hwph2mb">KNN - K Nearest Neighbors</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.ng6x7hwph2mb">38</a></span></p><p class="c28"><span class="c9 c4"><a class="c8" href="#h.ka9r1rsai5ay">Utility</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.ka9r1rsai5ay">38</a></span></p><p class="c28"><span class="c9 c4"><a class="c8" href="#h.a01redtf54dc">Final Result</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.a01redtf54dc">39</a></span></p><p class="c28"><span class="c9 c4"><a class="c8" href="#h.pfmkdneijd5q">Code</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.pfmkdneijd5q">39</a></span></p><p class="c19"><span class="c9 c4"><a class="c8" href="#h.uim2dx2zutxx">K-Means Clustering</a></span><span class="c4 c9">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.uim2dx2zutxx">45</a></span></p><p class="c28"><span class="c9 c4"><a class="c8" href="#h.7nxi9lox5okj">Utility</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.7nxi9lox5okj">45</a></span></p><p class="c28"><span class="c1"><a class="c8" href="#h.ellbdowp1qjw">Final Result</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.ellbdowp1qjw">46</a></span></p><p class="c28"><span class="c9 c4"><a class="c8" href="#h.ntm4lnbaq5ce">Code</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.ntm4lnbaq5ce">46</a></span></p><p class="c19"><span class="c1"><a class="c8" href="#h.wpdnekuu8i36">Neural Network</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.wpdnekuu8i36">51</a></span></p><p class="c28"><span class="c1"><a class="c8" href="#h.olgezktlkg8n">Gradient Descent</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.olgezktlkg8n">51</a></span></p><p class="c28"><span class="c1"><a class="c8" href="#h.7d3ty47hixe9">Backpropagation</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.7d3ty47hixe9">52</a></span></p><p class="c28"><span class="c1"><a class="c8" href="#h.6f23blautjr">Utility</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.6f23blautjr">53</a></span></p><p class="c28"><span class="c1"><a class="c8" href="#h.c1404dnqdlmy">Final Result</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.c1404dnqdlmy">54</a></span></p><p class="c28"><span class="c1"><a class="c8" href="#h.f8n6y9e6fhii">Code</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.f8n6y9e6fhii">55</a></span></p><p class="c19"><span class="c1"><a class="c8" href="#h.8nkeqr817z3g">Improved Neural Network</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.8nkeqr817z3g">61</a></span></p><p class="c28"><span class="c1"><a class="c8" href="#h.k856hxxaptyk">Final Result</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.k856hxxaptyk">62</a></span></p><p class="c28"><span class="c1"><a class="c8" href="#h.mr82aqcu7e5f">Code</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.mr82aqcu7e5f">63</a></span></p><p class="c44"><span class="c1"><a class="c8" href="#h.gh185xtq3j72">data.h + data.cpp</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.gh185xtq3j72">63</a></span></p><p class="c44"><span class="c1"><a class="c8" href="#h.1vsjm9qv6qjp">data_handler.h + data_handler.cpp</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.1vsjm9qv6qjp">66</a></span></p><p class="c44"><span class="c1"><a class="c8" href="#h.pmeee8ak5uo1">common_data.h + common_data.cpp</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.pmeee8ak5uo1">73</a></span></p><p class="c44"><span class="c1"><a class="c8" href="#h.oky7k09rwrar">neuron.h + neuron.cpp</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.oky7k09rwrar">74</a></span></p><p class="c44"><span class="c1"><a class="c8" href="#h.ubsi1zc54qk2">layer.h + layer.cpp</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.ubsi1zc54qk2">75</a></span></p><p class="c44"><span class="c1"><a class="c8" href="#h.g541qnwrwqsn">network.h + network.cpp</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.g541qnwrwqsn">76</a></span></p><p class="c44"><span class="c1"><a class="c8" href="#h.er37jyz7h1mk">main.cpp</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.er37jyz7h1mk">85</a></span></p><p class="c22"><span class="c9 c63 c48"><a class="c8" href="#h.idlcnp4e5ye6">FFT - Fast Fourier Transform</a></span><span class="c9 c63 c48">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c63 c48"><a class="c8" href="#h.idlcnp4e5ye6">88</a></span></p><p class="c42"><span class="c9 c4"><a class="c8" href="#h.bsnz3inlejru">DFT - Discrete Fourier Transform</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.bsnz3inlejru">88</a></span></p><p class="c42"><span class="c9 c4"><a class="c8" href="#h.lyt2xx7z5s4f">Code - FFT.h + FFT.cpp:</a></span><span class="c9 c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c9 c4"><a class="c8" href="#h.lyt2xx7z5s4f">89</a></span></p><p class="c22"><span class="c57 c15 c48"><a class="c8" href="#h.endqd0rjle1y">Music Genre Classifier</a></span><span class="c57 c15 c48">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c57 c15 c48"><a class="c8" href="#h.endqd0rjle1y">98</a></span></p><p class="c42"><span class="c1"><a class="c8" href="#h.kryixj2nhzc0">CreateDataSet - Data Set Creator for Music Genre Classifier</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.kryixj2nhzc0">98</a></span></p><p class="c19"><span class="c1"><a class="c8" href="#h.jolwscus14lq">CreateDataSet.cpp</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.jolwscus14lq">99</a></span></p><p class="c19"><span class="c1"><a class="c8" href="#h.rzcffo9mu0lx">AudioFile.h</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.rzcffo9mu0lx">116</a></span></p><p class="c22"><span class="c57 c15 c48"><a class="c8" href="#h.xkjtgfmwbqe">Multifunction Audio Classifier</a></span><span class="c57 c15 c48">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c57 c15 c48"><a class="c8" href="#h.xkjtgfmwbqe">138</a></span></p><p class="c19"><span class="c1"><a class="c8" href="#h.7sqzyolimvv2">Network Output Files - .net</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.7sqzyolimvv2">138</a></span></p><p class="c42"><span class="c1"><a class="c8" href="#h.nm3bulueensr">Final Result:</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.nm3bulueensr">138</a></span></p><p class="c42"><span class="c1"><a class="c8" href="#h.qvvedneg9cjy">Different genres of music:</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.qvvedneg9cjy">139</a></span></p><p class="c42"><span class="c1"><a class="c8" href="#h.muph8g8rz4k7">Different people speaking:</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.muph8g8rz4k7">139</a></span></p><p class="c42"><span class="c1"><a class="c8" href="#h.qdq2jc6pmsv">Different instruments:</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.qdq2jc6pmsv">139</a></span></p><p class="c42"><span class="c1"><a class="c8" href="#h.5mmr5ropg797">Code:</a></span><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1"><a class="c8" href="#h.5mmr5ropg797">140</a></span></p><p class="c19"><span><a class="c8" href="#h.s9f76537z0mu">neuron.h + neuron.cpp</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c8" href="#h.s9f76537z0mu">140</a></span></p><p class="c19"><span><a class="c8" href="#h.uji3vcytg5hd">layer.h + layer.cpp</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c8" href="#h.uji3vcytg5hd">142</a></span></p><p class="c19"><span><a class="c8" href="#h.49b631p4s7ab">network.h + network.cpp</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c8" href="#h.49b631p4s7ab">144</a></span></p><p class="c19"><span><a class="c8" href="#h.xbjj3bx4h2xd">CommandLineFunctions.h + CommandLineFunctions.cpp</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c8" href="#h.xbjj3bx4h2xd">158</a></span></p><p class="c19"><span><a class="c8" href="#h.7o2p75syjsm5">AudioClassifier.cpp (main)</a></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span><a class="c8" href="#h.7o2p75syjsm5">183</a></span></p><p class="c80 c81"><span class="c48"><a class="c8" href="#h.njg5yv5rlqry">Works Cited</a></span><span class="c48">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c48"><a class="c8" href="#h.njg5yv5rlqry">185</a></span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span>All code can be found on GitHub: </span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://github.com/Michael-K-Stein/Sound-Classifier&amp;sa=D&amp;source=editors&amp;ust=1617101996978000&amp;usg=AOvVaw2dRdgUNNya-t02QCyl-Gd5">https://github.com/Michael-K-Stein/Sound-Classifier</a></span><hr style="page-break-before:always;display:none;"></p><h1 class="c36" id="h.hds9hl5hocod"><span>Theoretical </span><span class="c4 c15 c56">Background</span></h1><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Recognizing people by their voice, differentiating between music genres, animal sounds, and understanding the random noises from the kitchen are all standard tasks our human brain does automatically. These are all achieved by our impeccable ability to find patterns. So how do we grant a computer this ability?</span></p><p class="c17"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The factor humans use to recognize sounds we will be focussing on is timbre. Looking at what &ldquo;sound&rdquo; actually is, we see it is a wave moving through space. This wave is generated by vibrations, either from a person&rsquo;s vocal cords, a speaker&rsquo;s diaphragm, or the strings of an instrument. We can now look at Mersenne&rsquo;s formula and see that each chord or string produces a set of frequencies depending on its properties (length, mass per unit length, and the stretching force) </span><img src="images/image1.png"><span class="c1">. Evidently, we can now refer to the sound an instrument makes as a wave at a certain frequency.</span></p><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 398.67px;"><img alt="" src="images/image27.png" style="width: 601.70px; height: 398.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moreover, we can play, for example on a piano, chords. A chord is the simultaneous sound of multiple notes, and thus the sound produced is quite simply a wave of the sum of the individual waves. We can take for example the natural A minor chord, which has the following notes with the corresponding frequencies:</span></p><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 98.50px; height: 180.58px;"><img alt="" src="images/image10.png" style="width: 98.50px; height: 180.58px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 461.50px; height: 245.82px;"><img alt="" src="images/image25.png" style="width: 461.50px; height: 245.82px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17"><span class="c3">&nbsp;And plot the wave generated by summing the sine waves at these frequencies </span><img src="images/image2.png"><span class="c1">. </span></p><p class="c17"><span class="c1">This wave describes the A minor chord explicitly (and specifically the A minor chord beginning at the closest A to middle C on a grand piano, A at frequency 440.0 Hz).</span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17 c46"><span class="c1">Now let&rsquo;s assume we are the audience at this performance, and what we are given is the produced wave (this wave is the movement of particles in the air from the piano&rsquo;s chords, through the room, and into our ears). How could we figure out which notes were played?</span></p><p class="c17"><span class="c3">To do this we use the </span><span class="c20 c3"><a class="c8" href="#h.idlcnp4e5ye6">Fourier Transform</a></span><span class="c1">. The Fourier Transform takes the wave we &ldquo;hear&rdquo; as an input, and returns an array of the frequencies which produce it. In this case, the Fourier Transform will return {440.0, 523.25, 659.26}, and thus tell us exactly which notes were played to produce the sound wave. (This is a very simplified output of the Fourier Transform, a more in-depth explanation will be found below.)</span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Our brain is trained to do this automatically, and therefore musicians are able to recognize different chords in songs. Additionally, we can also derive information about the theme of the song, if it is uplifting or melancholic, which style it is in, Jazz is a unique example, and much more. This all stems from being able to recognize which frequencies are combined, and utilize them to classify the sound.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It is quite clear to a keen listener that there is a significant difference in the frequency arrays of Twinkle Twinkle Little Star and Seven Nation Army by The White Stripes, while the frequency arrays of Beethoven&rsquo;s 9th Symphony (Ode to Joy) and Vivaldi&rsquo;s Spring will be more alike one-another. This is because different genres of music tend to follow a format, which includes certain frequency ranges, and certain intervals between frequencies. So we can use this fact to teach a computer to differentiate between music genres solely based on the frequency arrays our nifty Fourier Transform provides us with. This is actually how Shazam works (Wang, &ldquo;An Industrial-Strength Audio Search Algorithm.&rdquo;), and what much of the initial research was based on.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interestingly, to the best of our understanding, the way the human brain differentiates between peoples&rsquo; voices is almost identical to how we differentiate between music genres. This means that if we can do one, we can easily do the other.</span></p><hr style="page-break-before:always;display:none;"><h1 class="c36 c79" id="h.xvkfscry3po8"><span class="c4 c15 c56"></span></h1><h1 class="c36" id="h.n3aje4quob27"><span class="c4 c15 c56">C++ Research</span></h1><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ (or c++, CPP, cpp) is one of the most widely used programming languages. C++ is essentially an extension to the classic C programming language, created by Bjarne Stroustrup. Bjarne Stroustrup developed C++ in 1979 at Bell Labs, as a way to enhance C with more features - most importantly: classes and object oriented programming.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As C++ has classes, let&rsquo;s dive into Object Oriented Programming (OOP):</span></p><h2 class="c54" id="h.6cgb2mn4fcqd"><span class="c4 c15 c32">OOP - Object Oriented Programming</span></h2><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object Oriented Programming is a method of coding based on objects (classes), rather than Procedural Programming which is based on procedurally calling functions and thus creating routines and subroutines. Classes in OOP contain both code and data, and can interact with other classes, while Procedural Programming would have to pass data pointers between function calls.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The most common examples of Object Oriented Languages are C++, C#, Java, and Python, while Procedural languages include: C, Fortran, COBOL, and Pascal.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Three of the main highlights of OOP are: Encapsulation, Inheritance, and Polymorphism.</span></p><h3 class="c39" id="h.olcmpnopy3pm"><span class="c4 c15 c18">Encapsulation</span></h3><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encapsulation is the concept of combining data with the methods (functions) which use it, and &ldquo;hiding&rdquo; that data from unauthorized parties. Data, for example an array of characters (a string), in a class will be accessible only to methods in that class. Therefore, if an external use of the data is made, it is done through a method in the class containing the data, usually through &lsquo;get&rsquo; and &lsquo;set&rsquo; methods. A simple use case of this could be a class &ldquo;Student&rdquo; which represents one student in a school, and in this class (disambiguation: programming class. we will refer to the physical room where the students learn as &ldquo;school&rdquo;) there is a string labeled &ldquo;Name&rdquo; which holds the name of the student. We can now use the concept of encapsulation to prevent a students name from being changed (as this should not generally happen) and guarantee that the class returns a properly capitalized name when asked. This class could look like:</span></p><p class="c17 c12"><span class="c1"></span></p><a id="t.be9ac747f56c9203d7bddb7bfca1d0b1a47ecd94"></a><a id="t.0"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c11"><span class="c1">class Student {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private:</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char * Name;</span></p><p class="c11 c12"><span class="c1"></span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public:</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char error_no_name[9] = &quot;No Name!&quot;;</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char * getName() {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Name == NULL) { return error_no_name; } // Make sure Name isn&#39;t empty</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name[0] = toupper(Name[0]); // Force capitalize first letter of name</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Name;</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c11 c12"><span class="c1"></span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void setName(int student_name_length, char * student_name) {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (Name != NULL) { </span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Student already has a name!\n&quot;);</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return; </span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (student_name_length &lt; 2) {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;This cannot be a legal name, it is too short!\n&quot;);</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (student_name == NULL) {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;No name was given!\n&quot;);</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(Name, student_name, student_name_length);</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Student&#39;s name was changed to: &#39;%s&#39;.\n&quot;, Name);</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c11"><span class="c1">};</span></p></td></tr></tbody></table><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In this example we already see how encapsulation protects data, and places functions in an intuitive location regarding the data they use. In the case we see here, by using encapsulation, we reduce and simplify the code, as we have these protective &lsquo;if&rsquo; statements only once, rather than making sure we are not accidentally ruining the student&rsquo;s name each time we use it.</span></p><p class="c17 c12"><span class="c1"></span></p><h3 class="c39" id="h.j9iyytszo3ry"><span class="c4 c15 c18">Inheritance</span></h3><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inheritance is the mechanism through which one class can be based on, and thus acquire the methods and data of, another class. Inherited classes will have the same attributes and functions as their parent (or base or super) class, while being able to build on those to include more. Inheritance can be used to create a hierarchy of classes, where there is a base class which includes common and standard functionality, and an inherited child class has some extra functionality. For example:</span></p><p class="c17 c12"><span class="c1"></span></p><a id="t.74d5f6b81ee5c882284a2f39a41543a695be8606"></a><a id="t.1"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c11"><span class="c1">typedef struct shape {/* Data */};</span></p><p class="c11"><span class="c1">typedef struct food {/* Data */ };</span></p><p class="c11"><span class="c1">typedef struct place {/* Data */ };</span></p><p class="c11 c12"><span class="c1"></span></p><p class="c11 c12"><span class="c1"></span></p><p class="c11"><span class="c1">class Animal {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected:</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int age;</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shape body;</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;food diet;</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;place habitat;</span></p><p class="c11 c12"><span class="c1"></span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public:</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Walk() {};</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Talk();</span></p><p class="c11"><span class="c1">};</span></p><p class="c11"><span class="c1">class Bird : public Animal {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected: </span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int wing_span;</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public:</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Fly();</span></p><p class="c11"><span class="c1">};</span></p><p class="c11"><span class="c1">class Penguin : public Bird {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public:</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Swim();</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void Fly() = delete; // Penguins cannot fly</span></p><p class="c11"><span class="c1">};</span></p></td></tr></tbody></table><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We have here the hierarchy from a general animal to a penguin, where a penguin has all the attributes and information of a base animal, and also some of the features of a bird - without the flying. Using inheritance, we avoid writing definitions and implementations of standard functions like &ldquo;Walk()&rdquo; in each class of animal. Say we implemented a class for each of the ~400 dog breeds. It would be incredibly redundant to implement 400 walk functions, while if we inherited each &lsquo;dog_breed&rsquo; class from a base &lsquo;dog&rsquo; class, we would only implement this function - and many others - once.</span></p><p class="c17 c12"><span class="c1"></span></p><h3 class="c39" id="h.dlh12jc2eqiq"><span class="c4 c15 c18">Polymorphism</span></h3><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Polymorphism allows two interesting and useful features which can be classified as static and dynamic polymorphisms. Static polymorphism (or ad hoc polymorphism) allows multiple functions two have the same name, and differentiates between them by their formal parameters - function overloading. This allows us to define similar functions which use different types of parameters with the same name:</span></p><p class="c17 c12"><span class="c1"></span></p><a id="t.a4b5ec7367feb91382c815ab963a7578c1641bc1"></a><a id="t.2"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c11"><span class="c1">double Sum(int num1, int num2) {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num2;</span></p><p class="c11"><span class="c1">}</span></p><p class="c11"><span class="c1">double Sum(double num1, double num2) {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num2;</span></p><p class="c11"><span class="c1">}</span></p><p class="c11"><span class="c1">double Sum(float num1, float num2) {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num2;</span></p><p class="c11"><span class="c1">}</span></p><p class="c11"><span class="c1">double Sum(int length_of_array, double * num_array) {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double sum = 0;</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i &lt; length_of_array; i++) {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += num_array[i];</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return sum;</span></p><p class="c11"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Now when we need to use some implementation of the &lsquo;Sum&rsquo; function, we do not need to worry about which one to choose, as the compiler will select the proper one for each call according to that call&#39;s parameters.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The second type, dynamic polymorphism, allows us to refer to objects of different derived classes the same way, given the derive from a common function. We can use this feature to iterate over an array of animals (see Encapsulation) and call their common &ldquo;Walk()&rdquo; function.</span></p><p class="c17 c12"><span class="c1"></span></p><a id="t.50bd11f569d57732a506f168ce3bb3c16a78aa9b"></a><a id="t.3"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c11"><span class="c1">Animal * animals[4];</span></p><p class="c11 c12"><span class="c1"></span></p><p class="c11"><span class="c1">Animal * generic_animal = new Animal();</span></p><p class="c11"><span class="c1">Bird * bird = new Bird();</span></p><p class="c11"><span class="c1">Penguin * penguin = new Penguin();</span></p><p class="c11"><span class="c1">Dog * dog = new Dog(); // assume we implement a class Dog similarly to Penguin.</span></p><p class="c11 c12"><span class="c1"></span></p><p class="c11"><span class="c1">animals[0] = generic_animal;</span></p><p class="c11"><span class="c1">animals[1] = bird;</span></p><p class="c11"><span class="c1">animals[2] = penguin;</span></p><p class="c11"><span class="c1">animals[3] = dog;</span></p><p class="c11 c12"><span class="c1"></span></p><p class="c11"><span class="c1">for (int i = 0; i &lt; 4; i++) {</span></p><p class="c11"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;animals[i]-&gt;Walk();</span></p><p class="c11"><span class="c1">}</span></p><p class="c11 c12"><span class="c1"></span></p></td></tr></tbody></table><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Here we see that, although each of the four objects in the array are of a different type, we can store them alongside each other, and call their common functions in such a way.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is granted by how inheritance is implemented in memory, which is that the base class&rsquo; attributes and methods are at the beginning and are then followed by the child class&rsquo; information.</span></p><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 201.33px;"><img alt="" src="images/image22.png" style="width: 601.70px; height: 201.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><hr style="page-break-before:always;display:none;"><h2 class="c38" id="h.odks7x6ni88p"><span class="c4 c15 c32"></span></h2><h2 class="c54" id="h.ihrlc1lrddvk"><span class="c4 c15 c32">Evolvement - Practical Research</span></h2><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;One of the most significant challenges which rose during this project, was that the platform I was using to run and execute the machine learning algorithms is a standard home computer - with the processing power of one. This means that each iteration over, for example, a euclidean distance calculation function took a massive amount of time, on the order of 1,500 milliseconds. This function being called 4,000 times for each of the 1,200 data points in the prototype-phase dataset, meant training the neural network would take 2,000 hours.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To increase efficiency to a more feasible training time, I tried the following:</span></p><ol class="c24 lst-kix_82vovlm3s7ys-0 start" start="1"><li class="c26 li-bullet-0"><h3 id="h.njlz6y7k98vc" style="display:inline"><span class="c4 c15 c18">Calling Conventions</span></h3></li></ol><ol class="c24 lst-kix_82vovlm3s7ys-1 start" start="1"><li class="c17 c40 li-bullet-0"><span class="c1">Calling conventions are the standard methods by which functions are called - each convention defines how arguments are passed into the function and how where the output is placed. These conventions are all implemented in low-level languages, in our case we will use Assembly 8086 (x86) - although the actual project is in 64bit assembly.</span></li><li class="c17 c40 li-bullet-0"><span class="c1">The standard calling convention is &lsquo;cdecl&rsquo; (C declaration), which passes arguments to the function through the stack. This means that code in C like: </span></li></ol><a id="t.80cc3091b26bcc3e9dce0eca3bd32f3d3c4696dc"></a><a id="t.4"></a><table class="c53"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">int</span><span>&nbsp;func(</span><span class="c5">int</span><span>&nbsp;a,</span><span class="c5">int</span><span>&nbsp;b,</span><span class="c5">int</span><span>&nbsp;c,</span><span class="c5">int</span><span>&nbsp;d, </span><span class="c5">int</span><span>&nbsp;e, </span><span class="c5">int</span><span class="c1">&nbsp;f) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;out = a + b + c + d + e + f;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;out;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;main(</span><span class="c5">int</span><span>&nbsp;argc, </span><span class="c5">char</span><span class="c1">&nbsp;** argv) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;output = func(</span><span class="c7">0</span><span>,</span><span class="c7">1</span><span>,</span><span class="c7">2</span><span>,</span><span class="c7">3</span><span>,</span><span class="c7">4</span><span>,</span><span class="c7">5</span><span class="c1">);</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c58"><span class="c1">Will look like: </span></p><a id="t.35c73405ec4e0b8eda0ca37b509a77a2bb3d7b62"></a><a id="t.5"></a><table class="c53"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c3 c15 c71">_func &nbsp; PROC</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c21">ebp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">ebp</span><span>, </span><span class="c3 c15 c21">esp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c21">ecx</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">ebp + 8</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">add</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">ebp + 12</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">add</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">ebp + 16</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">add</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">ebp + 20</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">add</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">ebp + 24</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">add</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">ebp + 28</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">ebp - 4</span><span>], </span><span class="c3 c15 c21">eax</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span class="c71">&nbsp;</span><span>[</span><span class="c21">ebp - 4</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">esp</span><span>, </span><span class="c3 c15 c21">ebp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">pop</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c3 c15 c21">ebp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">ret</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c3 c15 c7">0</span></p><p class="c0"><span class="c3 c15 c71">_func &nbsp; ENDP</span></p><p class="c0 c12"><span class="c6 c3"></span></p><p class="c0"><span class="c3 c15 c71">_main &nbsp; PROC</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c21">ebp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">ebp</span><span>, </span><span class="c3 c15 c21">esp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c21">ecx</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c7">5</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c7">4</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c7">3</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c7">2</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c7">1</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c7">0</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">call</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c71">_func</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">add</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">esp</span><span>, </span><span class="c7">24</span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6 c3">; 00000018H</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">ebp - 4</span><span>], </span><span class="c3 c15 c21">eax</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">xor</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c3 c15 c21">eax</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">esp</span><span>, </span><span class="c3 c15 c21">ebp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">pop</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c3 c15 c21">ebp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">ret</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c3 c15 c7">0</span></p><p class="c0"><span class="c71">_main &nbsp; ENDP</span></p></td></tr></tbody></table><p class="c17 c58"><span class="c1">While this is a good convention, and for general use is sufficient, in our case we need to optimize the code further, and remove as many redundant instructions as possible. The first thing to do, is change the calling convention to &lsquo;fastcall&rsquo; which will pass the arguments through registers instead of the stack. Luckily, we only actually need two arguments, so the function could look like this:</span></p><a id="t.3b8825da753fc72026202d2b9652504adf8fd54d"></a><a id="t.6"></a><table class="c53"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c3 c15 c71">func:</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c21">rbp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rbp</span><span>, </span><span class="c3 c15 c21">rsp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">edx</span><span>, </span><span class="c21">edi</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c21">esi</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">add</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c3 c15 c21">edx</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">4</span><span>], </span><span class="c3 c15 c21">eax</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">4</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">pop</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c3 c15 c21">rbp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">ret</span></p><p class="c0"><span class="c3 c15 c71">main:</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c21">rbp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rbp</span><span>, </span><span class="c3 c15 c21">rsp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">sub</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rsp</span><span>, </span><span class="c3 c7 c15">32</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">20</span><span>], </span><span class="c3 c15 c21">edi</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">QWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">32</span><span>], </span><span class="c3 c15 c21">rsi</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">esi</span><span>, </span><span class="c3 c15 c7">1</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">edi</span><span>, </span><span class="c3 c15 c7">0</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">call</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c71">func</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">4</span><span>], </span><span class="c3 c15 c21">eax</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c3 c15 c7">0</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">leave</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">ret</span></p></td></tr></tbody></table><p class="c17 c58"><span>Notice how we reduced the amount of instructions in </span><span class="c29">func </span><span class="c1">which will be expressed as a significant speed increase when we repeatedly call the function.</span></p><ol class="c24 lst-kix_82vovlm3s7ys-0" start="2"><li class="c26 li-bullet-0"><h3 id="h.u7klqhmk015v" style="display:inline"><span class="c4 c15 c18">Parameter Types</span></h3></li></ol><ol class="c24 lst-kix_82vovlm3s7ys-1 start" start="1"><li class="c17 c40 li-bullet-0"><span class="c1">In C/C++ parameters can be passed to function either by-value, meaning you pass the literal bits of the value to the function, or by-reference, meaning you pass an address pointer to the value in memory.</span></li><li class="c17 c40 li-bullet-0"><span class="c1">By-Value is clearly faster, as we avoid having to dereference the address when using the value. However, there is a caveat to by-value, and an exception:</span></li></ol><ol class="c24 lst-kix_82vovlm3s7ys-2 start" start="1"><li class="c17 c33 li-bullet-0"><span class="c1">The caveat: An &ldquo;object&rdquo; passed by-value cannot be changed. Any changes done to the object are temporary within the scope of the called function, as the function actually received a bitwise copy of the object, and this copy is in a different memory location than the original.</span></li><li class="c17 c33 li-bullet-0"><span class="c1">The exception: &ldquo;Objects&rdquo; or structures cannot be properly passed by-value. While some compilers (not MSVC, which was used to compile most of this project) allow passing a structure by-value, this is quite odd and wildly inefficient.</span></li></ol><ol class="c24 lst-kix_82vovlm3s7ys-1" start="3"><li class="c17 c40 li-bullet-0"><span class="c1">By-Reference, while being slower, solves the caveat of being unable to change the object outside the scope of the function.</span></li></ol><ol class="c24 lst-kix_82vovlm3s7ys-2 start" start="1"><li class="c17 c33 li-bullet-0"><span class="c1">Notice the redundancy, however, with passing a standard object - like an int32_t or char - by-reference in order to change it:</span></li></ol><a id="t.abc8b4f92d3cae82a82ea4544b972b2ea8fbd546"></a><a id="t.7"></a><table class="c66 c68"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">int</span><span>&nbsp;square(</span><span class="c5">int</span><span class="c1">&nbsp;num) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;num * num; </span><span class="c6 c3">// Multiplies num </span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;square(</span><span class="c5">int</span><span class="c1">&nbsp;* num) {</span></p><p class="c0"><span>&nbsp; &nbsp; *num = (*num) * (*num); </span><span class="c6 c3">// Changes num at its original location as allocated in main.</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;main() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;number = </span><span class="c7">5</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; number = square(number);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;number2 = </span><span class="c7">7</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; square(&amp;number);</span></p><p class="c0"><span class="c1">}</span></p><p class="c11 c12"><span class="c1"></span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c3 c15 c71">square(int):</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c21">rbp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rbp</span><span>, </span><span class="c3 c15 c21">rsp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">4</span><span>], </span><span class="c3 c15 c21">edi</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">4</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">imul</span><span>&nbsp; &nbsp; </span><span class="c21">eax</span><span>, </span><span class="c3 c15 c21">eax</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">pop</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c3 c15 c21">rbp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">ret</span></p><p class="c0"><span class="c3 c15 c71">square(int*):</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c21">rbp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rbp</span><span>, </span><span class="c3 c15 c21">rsp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">QWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">8</span><span>], </span><span class="c3 c15 c21">rdi</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rax</span><span>, </span><span class="c45">QWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">8</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">edx</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rax</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rax</span><span>, </span><span class="c45">QWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">8</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rax</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">imul</span><span>&nbsp; &nbsp; </span><span class="c21">edx</span><span>, </span><span class="c3 c15 c21">eax</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rax</span><span>, </span><span class="c45">QWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">8</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rax</span><span>], </span><span class="c3 c15 c21">edx</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">nop</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">pop</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c3 c15 c21">rbp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">ret</span></p><p class="c0"><span class="c3 c15 c71">main:</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">push</span><span>&nbsp; &nbsp; </span><span class="c3 c15 c21">rbp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rbp</span><span>, </span><span class="c3 c15 c21">rsp</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">sub</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rsp</span><span>, </span><span class="c3 c15 c7">16</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">8</span><span>], </span><span class="c3 c15 c7">5</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">8</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">edi</span><span>, </span><span class="c3 c15 c21">eax</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">call</span><span>&nbsp; &nbsp; </span><span class="c71">square</span><span>(</span><span class="c71">int</span><span class="c1">)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">8</span><span>], </span><span class="c3 c15 c21">eax</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c45">DWORD</span><span>&nbsp;</span><span class="c45">PTR</span><span>&nbsp;[</span><span class="c21">rbp</span><span>-</span><span class="c7">4</span><span>], </span><span class="c3 c15 c7">7</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">lea</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rax</span><span>, [</span><span class="c21">rbp</span><span>-</span><span class="c7">8</span><span class="c1">]</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">rdi</span><span>, </span><span class="c3 c15 c21">rax</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">call</span><span>&nbsp; &nbsp; </span><span class="c71">square</span><span>(</span><span class="c71">int</span><span class="c1">*)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">mov</span><span>&nbsp; &nbsp; &nbsp;</span><span class="c21">eax</span><span>, </span><span class="c3 c15 c7">0</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">leave</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">ret</span></p></td></tr></tbody></table><p class="c17 c66"><span class="c1">A very simple 7 line function mutates into a complex 13 line function. This is an easily avoidable redundancy.</span></p><p class="c17 c41"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Therefore, for performance critical functions, we will pass only simple types by-value.</span></p><ol class="c24 lst-kix_82vovlm3s7ys-0" start="3"><li class="c26 li-bullet-0"><h3 id="h.ooqsm4qiitcd" style="display:inline"><span class="c4 c15 c18">Arrays vs Vectors</span></h3></li></ol><ol class="c24 lst-kix_82vovlm3s7ys-1 start" start="1"><li class="c17 c40 li-bullet-0"><span class="c1">However, even with all these optimizations, most functions, specifically uint32_t knn::calculate_distance(data * query_point, data * input), were still severely hindering the process.</span></li><li class="c17 c40 li-bullet-0"><span class="c1">The original version of knn:calculate_distance(data*, data*) looked a little like this: </span></li></ol><a id="t.e11f09c211151d83b84e46a2a678affb16c4c876"></a><a id="t.8"></a><table class="c53"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;knn::calculate_distance(data * query_point, data * input) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;distance = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(query_point-&gt;get_feature_vector_size() != input-&gt;get_feature_vector_size()) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Vector size mismatch&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; exit(</span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(uint16_t i = </span><span class="c7">0</span><span class="c1">; i &lt; query_point-&gt;get_feature_vector_size(); i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; distance += pow(query_point-&gt;get_feature_vector()-&gt;at(i) - input-&gt;get_feature_vector()-&gt;at(i),</span><span class="c7">2</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; distance = sqrt(distance);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;distance;</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><ol class="c24 lst-kix_82vovlm3s7ys-1" start="3"><li class="c17 c84 li-bullet-0"><span class="c1">The first optimization I made, was realizing that the feature vectors were of type std::vector&lt;uint8_t&gt;, meaning that the difference between two values on two vectors was also of type uint8_t (assuming we take the absolute value, which we do). This automatically means we are working with 8 bit integers instead of 64 bit doubles. Using these 8 bit integers, we gain the capability to use 8 bit operations, those using AL, AH, BL, &hellip;, DH, which are significantly faster than 64 bit operations. (Note: during the research, I initially tried using floating points (float) instead of doubles, in the hopes that using Floating-Point arithmetic - which can be done on the Floating Point Unit (FPU) - would be faster. Though this was successful and did in-fact increase performance, ultimately it was inferior to simply using unsigned byte-sized integers). One of my reasons for using 8 bit integers was the idea that twice as many could fit in the computer&rsquo;s registers (see below) and thus reduce time spent fetching values from RAM (Random Access Memory) or the Stack. </span></li></ol><p class="c17 c12 c58"><span class="c1"></span></p><p class="c17 c12 c58"><span class="c1"></span></p><p class="c17 c12"><span class="c1"></span></p><ol class="c24 lst-kix_82vovlm3s7ys-1" start="4"><li class="c17 c40 li-bullet-0"><span class="c1">Now to the crux of the issue; Vectors. Although vectors massively simplify dynamic size list usage, they are exponentially slower than normal c-style arrays. The main problem in our case with vectors is the &lsquo;at(int)&rsquo; function, which through trial-and-error, I found to be the bottleneck of our distance function. To solve this, I added another step in the initialization of the entire algorithm: after setting everything up, copy each and every vector in every single object found into a corresponding array inside that object. Obviously, this additional step nearly doubles the initialization time. However, we only need to do this step once, and by doing so we reduce the processing time of each data point by a factor of 10. The actual implementation of this was quite simple, as I merely duplicated all the performance critical functions and wrote a &ldquo;fast&rdquo; version which used arrays instead of vectors. The final distance function looks like this: </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 621.10px; height: 416.50px;"><img alt="" src="images/image9.png" style="width: 621.10px; height: 416.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></li></ol><a id="t.25bb5af7e8405b311488b62e82fa6c41b47125b4"></a><a id="t.9"></a><table class="c53"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c1">uint32_t knn::calculate_distance_fast(data * query_point, data * input) {</span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t distance = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint8_t * arr1 = query_point-&gt;get_feature_array();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint8_t * arr2 = input-&gt;get_feature_array();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint16_t size = query_point-&gt;get_feature_vector_size();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(uint16_t i = </span><span class="c7">0</span><span class="c1">; i &lt; size; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; distance += pow(arr1[i] - arr2[i], </span><span class="c7">2</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//distance = sqrt(distance); //Not necessary for comparisons</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;distance;</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><ol class="c24 lst-kix_82vovlm3s7ys-2" start="2"><li class="c17 c33 li-bullet-0"><span class="c1">We use integer types of the smallest possible sizes; unsigned 32 bit for the total distance - as it can be quite large, unsigned 8 bit for the inputs - as they are simply those (see our FFT class), and unsigned 16 bit for the size of the arrays (which is obviously the same as the vector&rsquo;s size) - as this is around 4,000 in our case.</span></li><li class="c17 c33 li-bullet-0"><span class="c1">We moved the array length validation out of this function, as to not check each and every time we call the distance function, rather only before beginning the distance comparisons.</span></li><li class="c17 c33 li-bullet-0"><span class="c1">We do not perform the square root calculation on the total distance. We use euclidean distance, which, informally, looks like this:</span></li></ol><p class="c17 c66"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 370.68px; height: 191.50px;"><img alt="" src="images/image13.png" style="width: 370.68px; height: 191.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17 c46 c66"><span class="c1">And formally:</span></p><a id="t.ca5a0ed46af8312a908a2abcaffe19e2c2afb091"></a><a id="t.10"></a><table class="c68 c66"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c11"><span>Assume points </span><span class="c29">a </span><span>and </span><span class="c29">b </span><span>such that their coordinates in an N dimensions space are {</span><span class="c29">a</span><span class="c13 c29">i</span><span>&nbsp;| </span><span class="c29">i </span><span>&isin; &#8477; &and; 1 &le; </span><span class="c29">i </span><span>&le; </span><span class="c29">N</span><span>} = {</span><span class="c29">a</span><span class="c13">1</span><span class="c29">,a</span><span class="c13">2</span><span class="c29">,...,a</span><span class="c13 c29">n</span><span>} and {</span><span class="c29">b</span><span class="c13">1</span><span class="c29">,b</span><span class="c13">2</span><span class="c29">,...,b</span><span class="c13 c29">n</span><span class="c1">}.</span></p><p class="c64"><span>The euclidean distance between points </span><span class="c29">a </span><span>and </span><span class="c29">b </span><span>is defined as:</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 172.00px; height: 72.00px;"><img alt="" src="images/image16.png" style="width: 172.00px; height: 72.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c31"><span class="c1">However, if all we care about is the relation between distances, we do not need to square root the sum since:</span></p><p class="c31"><span>&forall;</span><span class="c29">a,b </span><span>&isin; &#8477;</span><span class="c13">+</span><span class="c29">. a &gt; b</span><span>&nbsp;&lArr;&rArr;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 26.00px; height: 20.00px;"><img alt="" src="images/image17.png" style="width: 26.00px; height: 20.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span>&nbsp;</span><span class="c29">&gt;</span><span>&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 25.00px; height: 20.00px;"><img alt="" src="images/image24.png" style="width: 25.00px; height: 20.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c11 c12"><span class="c1"></span></p></td></tr></tbody></table><ol class="c24 lst-kix_82vovlm3s7ys-2" start="5"><li class="c17 c33 li-bullet-0"><span class="c1">We do not need to ask the data points&rsquo; class for the array or vector for each value, as we store our own pointers with &lsquo;arr1&rsquo; and &lsquo;arr2&rsquo;. This trivial fix reduces the extra calls to the &lsquo;get_feature_array()&rsquo; function, which while being very compact, still is redundant.</span></li></ol><p class="c17 c46"><span class="c1">All these improvements reduced the processing time of the algorithm from a couple thousand hours, to a few minutes. Specifically the bottleneck of knn::find_knearest(data*), which loops over the calculate_distance function many times, improved from around 1,850 milliseconds per loop, to under 330 milliseconds =&gt; a 82.16% increase in speed.</span></p><p class="c17 c12"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><h1 class="c36 c79" id="h.jyu5yhh2esns"><span class="c4 c15 c56"></span></h1><h1 class="c36" id="h.xkkpa3sxzye"><span class="c4 c15 c56">Machine Learning</span></h1><h2 class="c54" id="h.7r3yjq2rk36s"><span class="c4 c15 c32">Introduction</span></h2><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Machine learning is a form of artificial intelligence, designed to be able to solve problems which were not anticipated. Artificial intelligence (AI), is the concept wherein a computer can make decisions based on given information, to &ldquo;think&rdquo; so to say. The simplest form of AI is the commonly used &ldquo;if - else&rdquo; statement, which produces an output depending on the input.</span></p><p class="c17 c12"><span class="c1"></span></p><a id="t.27b29eaaca51e7fc3f8115f6919a62b6e1f2d3ad"></a><a id="t.11"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c11"><span class="c1">if (time == Night) {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp; turn_lights_on();</span></p><p class="c11"><span class="c1">} else {</span></p><p class="c11"><span class="c1">&nbsp; &nbsp;turn_lights_off();</span></p><p class="c11"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span class="c1">&nbsp;However, there is a clear limitation to &ldquo;if - else&rdquo; statements; the conditions must be predefined and the options for variability are very limited. An AI utilizing &ldquo;if - else&rdquo; statements could sort a school of children into classes by age, yet would be discomposed given a picture of a student to place in an appropriate class. Machine learning overcomes this limitation by making decisions in a more &ldquo;organic&rdquo; fashion, similar to human thought, as, pertaining to the aforementioned example, a school teacher would easily be able to tell the age of a child off a picture.</span></p><p class="c17"><span class="c16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;While theoretically possible, hardcoding a program to recognize a person&rsquo;s age from a picture is both unfathomable and impractical. Computers rely on functions, a mathematical concept which describes the relation or expression between variables (&ldquo;Function&rdquo;, Vocabulary.com). Humans can intuitively see and understand functions in two dimensions (X - Y Plane / Cartesian Plane), and can grasp a three dimensional coordinate system (X - Y - Z). However, some decisions rely on more than two quantifiable real-number inputs (&ldquo;input&rdquo; </span><span class="c3 c77">&isin; </span><span class="c77 c48 c61 c82">&#8477;</span><span class="c3 c77">), and humans simply lack the conceptual ability to turn such a function into code.</span></p><h2 class="c54" id="h.d0lw3r9kdj3z"><span class="c4 c15 c32">Concept and Theory</span></h2><p class="c17"><span class="c16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To solve problems which humans cannot explain, machine learning practically &ldquo;creates&rdquo; its own function for the problem. Instead of being told how to solve a problem, a machine learning algorithm is fed problems and their solutions, and depending on the machine learning algorithm, either learns and refines its &ldquo;function&rdquo; according to the training data, or uses the training data as a comparison to the validation and test data.</span></p><hr style="page-break-before:always;display:none;"><p class="c17 c12"><span class="c1"></span></p><h2 class="c54" id="h.h8nhutqjmjdd"><span class="c4 c15 c32">MNIST Database - Handwritten Digits</span></h2><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MNIST database is a collection of 60,000 grayscale images of handwritten digits in a 28x28px box.</span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 594.00px; height: 361.00px;"><img alt="" src="images/image19.png" style="width: 594.00px; height: 361.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In order to research and learn more about machine learning, I wrote three kinds of machine learning algorithms to classify the digits: KNN, K Means, and a Neural Network.</span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some of the code was the same throughout all three algorithms. Hence it is not placed under a specific category, rather in a general location. This includes the classes of the data itself, data holding classes and graphics (Which is solely for debugging purposes in the KNN algorithm). Note: there is a &ldquo;main&rdquo; function for each algorithm, only one of them may be available (uncommented) at a time.</span></p><hr style="page-break-before:always;display:none;"><h3 class="c39 c47" id="h.bsl6q96x38el"><span class="c4 c15 c18"></span></h3><h3 class="c39" id="h.pa6fgry1mcbn"><span class="c4 c15 c18">Code</span></h3><h4 class="c52" id="h.yzbeymaeqult"><span class="c4 c15 c23">data.h + data.cpp</span></h4><a id="t.122b4e11f745de400110eec7db90a3cd180f9b00"></a><a id="t.12"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c43"><span class="c16 c25">#ifndef __DATA_H</span><span class="c4"><br></span><span class="c16 c25">#define __DATA_H</span><span class="c4"><br><br></span><span class="c16 c25">#include &quot;stdint.h&quot;</span><span class="c4"><br></span><span class="c16 c25">#include &quot;stdio.h&quot;</span><span class="c4"><br></span><span class="c16 c25">#include &lt;vector&gt;</span><span class="c4"><br><br><br></span><span class="c16 c25">#pragma once</span><span class="c4"><br></span><span class="c16 c5">class</span><span class="c4">&nbsp;</span><span class="c16 c14">data</span><span class="c4"><br>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">uint8_t</span><span class="c4">&gt; * feature_vector;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt; * double_feature_vector;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt; *normalizedFeatureVector;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">int</span><span class="c4">&gt; * class_vector;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint8_t</span><span class="c4">&nbsp;label;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;enum_label; </span><span class="c16 c30">// A: 1; B: 2</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;distance;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">public</span><span class="c4">:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~data();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">set_feature_vector</span><span class="c4">(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">uint8_t</span><span class="c4">&gt; *);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">set_double_feature_vector</span><span class="c4">(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt; *);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">setNormalizedFeatureVector</span><span class="c4">(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt;*);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">set_class_vector</span><span class="c4">(</span><span class="c16 c5">int</span><span class="c4">&nbsp;count);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">append_to_feature_vector</span><span class="c4">(</span><span class="c16 c5">uint8_t</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">append_to_feature_vector</span><span class="c4">(</span><span class="c16 c5">double</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">set_label</span><span class="c4">&nbsp;(</span><span class="c16 c5">uint8_t</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">set_enumerated_label</span><span class="c4">(</span><span class="c16 c5">int</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">set_distance</span><span class="c4">(</span><span class="c16 c5">double</span><span class="c4">);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;</span><span class="c16 c14">get_distance</span><span class="c4">();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;</span><span class="c16 c14">get_feature_vector_size</span><span class="c4">();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint8_t</span><span class="c4">&nbsp;get_label();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint8_t</span><span class="c4">&nbsp;get_enumerated_label();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">uint8_t</span><span class="c4">&gt; * get_feature_vector();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt; * get_double_feature_vector();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt; * getNormalizedFeatureVector();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">int</span><span class="c4">&gt; * get_class_vector();<br><br>};<br><br></span><span class="c16 c25">#endif</span></p></td></tr></tbody></table><h4 class="c52 c67" id="h.95jcpmg0lcra"><span class="c4 c15 c23"></span></h4><a id="t.977001e5c29991dba99a24278c715aabd528714e"></a><a id="t.13"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c43"><span class="c16 c25">#include &quot;data.h&quot;</span><span class="c4"><br><br>data::data()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;feature_vector = </span><span class="c16 c5">new</span><span class="c4">&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">uint8_t</span><span class="c4">&gt;;<br>}<br><br><br>data::~data()<br>{<br>}<br><br></span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt; * data::getNormalizedFeatureVector()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;normalizedFeatureVector;<br>}<br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data::setNormalizedFeatureVector(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt;* vect)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normalizedFeatureVector = vect;<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data::set_feature_vector(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">uint8_t</span><span class="c4">&gt; * vect) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;feature_vector = vect;<br>}<br> <br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data::set_double_feature_vector(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt; * vect) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double_feature_vector = vect;<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data::set_class_vector(</span><span class="c16 c5">int</span><span class="c4">&nbsp;count) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_vector = </span><span class="c16 c5">new</span><span class="c4">&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">int</span><span class="c4">&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 0; i &lt; count; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(i == label)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_vector-&gt;push_back(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">else</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_vector-&gt;push_back(0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data::append_to_feature_vector(</span><span class="c16 c5">uint8_t</span><span class="c4">&nbsp;val) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;feature_vector-&gt;push_back(val);<br>}<br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data::append_to_feature_vector(</span><span class="c16 c5">double</span><span class="c4">&nbsp;val) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normalizedFeatureVector-&gt;push_back(val);<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data::set_label(</span><span class="c16 c5">uint8_t</span><span class="c4">&nbsp;val) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;label = val;<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data::set_enumerated_label(</span><span class="c16 c5">int</span><span class="c4">&nbsp;val) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enum_label = val;<br>}<br><br></span><span class="c16 c5">int</span><span class="c4">&nbsp;data::get_feature_vector_size() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;feature_vector-&gt;size();<br>}<br><br></span><span class="c16 c5">uint8_t</span><span class="c4">&nbsp;data::get_label() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;label;<br>}<br><br></span><span class="c16 c5">uint8_t</span><span class="c4">&nbsp;data::get_enumerated_label() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;enum_label;<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data::set_distance(</span><span class="c16 c5">double</span><span class="c4">&nbsp;val) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance = val;<br>}<br><br></span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">uint8_t</span><span class="c4">&gt; * data::get_feature_vector() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;feature_vector;<br>}<br><br></span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt; * data::get_double_feature_vector() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;double_feature_vector;<br>}<br><br></span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">int</span><span class="c4">&gt; * data::get_class_vector() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;class_vector;<br>}<br><br></span><span class="c16 c5">double</span><span class="c4">&nbsp;data::get_distance() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;distance;<br>}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h4 class="c52" id="h.i977r5qf9475"><span class="c4 c15 c23">data_handler.h + data_handler.cpp</span></h4><a id="t.0c673115f4a35229051a59fefb0ecd061c97087d"></a><a id="t.14"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c43"><span class="c16 c25">#ifndef __DATA_HANDLER_H</span><span class="c4"><br></span><span class="c16 c25">#define __DATA_HANDLER_H</span><span class="c4"><br><br></span><span class="c16 c25">#include &lt;fstream&gt;</span><span class="c4"><br></span><span class="c16 c25">#include &quot;stdint.h&quot;</span><span class="c4"><br></span><span class="c16 c25">#include &quot;data.h&quot;</span><span class="c4"><br></span><span class="c16 c25">#include &lt;vector&gt;</span><span class="c4"><br></span><span class="c16 c25">#include &lt;string&gt;</span><span class="c4"><br></span><span class="c16 c25">#include &lt;map&gt;</span><span class="c4"><br></span><span class="c16 c25">#include &lt;unordered_set&gt;</span><span class="c4"><br></span><span class="c16 c25">#include &lt;algorithm&gt; </span><span class="c4"><br></span><span class="c16 c25">#include &quot;Graphic.h&quot;</span><span class="c4"><br><br></span><span class="c16 c25">#pragma once</span><span class="c4"><br></span><span class="c16 c5">class</span><span class="c4">&nbsp;</span><span class="c16 c14">data_handler</span><span class="c4"><br>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * data_array;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * training_data;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * test_data;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * validation_data;<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;num_classes;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;feature_vector_size;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">map</span><span class="c4">&lt;</span><span class="c16 c5">uint8_t</span><span class="c4">, </span><span class="c16 c5">int</span><span class="c4">&gt; class_map;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">map</span><span class="c4">&lt;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">, </span><span class="c16 c5">int</span><span class="c4">&gt; classMap;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">const</span><span class="c4">&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;TRAIN_SET_PERCENT = 0.75;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">const</span><span class="c4">&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;TEST_SET_PERCENT = 0.20;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">const</span><span class="c4">&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;VALIDATION_PERCENT = 0.05;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">public</span><span class="c4">:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_handler();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~data_handler();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">read_csv</span><span class="c4">(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">&nbsp;path, </span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">&nbsp;delimiter);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">read_feature_vector</span><span class="c4">(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">&nbsp;filePath);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">read_feature_labels</span><span class="c4">(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">&nbsp;filePath);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">split_data</span><span class="c4">();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">count_classes</span><span class="c4">();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">normalize</span><span class="c4">();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;convert_to_little_endian(</span><span class="c16 c5">const</span><span class="c4">&nbsp;</span><span class="c16 c5">unsigned</span><span class="c4">&nbsp;</span><span class="c16 c5">char</span><span class="c4">&nbsp;* bytes);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;</span><span class="c16 c14">get_class_count</span><span class="c4">();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * get_training_data();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * get_test_data();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * get_validation_data();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">private</span><span class="c4">:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;max_image_array = 1000; </span><span class="c16 c30">// To keep the program from hogging the RAM</span><span class="c4"><br>};<br><br></span><span class="c16 c25">#endif</span></p></td></tr></tbody></table><p class="c43 c12"><span class="c1"></span></p><a id="t.79b2fca462579aa4db912c062246830d5d288f1d"></a><a id="t.15"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c43"><span class="c16 c25">#include &quot;data_handler.h&quot;</span><span class="c4"><br><br>data_handler::data_handler()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_array = </span><span class="c16 c5">new</span><span class="c4">&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_data = </span><span class="c16 c5">new</span><span class="c4">&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;training_data = </span><span class="c16 c5">new</span><span class="c4">&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validation_data = </span><span class="c16 c5">new</span><span class="c4">&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt;;<br>}<br><br><br>data_handler::~data_handler()<br>{<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data_handler::read_csv(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">&nbsp;path, </span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">&nbsp;delimiter) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_classes = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::ifstream </span><span class="c16 c14">data_file</span><span class="c4">(path.c_str());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">&nbsp;line;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">while</span><span class="c4">&nbsp;(</span><span class="c16 c5">std</span><span class="c4">::getline(data_file, line)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(line.length() == 0) { </span><span class="c16 c5">continue</span><span class="c4">; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data * d = </span><span class="c16 c5">new</span><span class="c4">&nbsp;data();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d-&gt;set_double_feature_vector(</span><span class="c16 c5">new</span><span class="c4">&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt;());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">size_t</span><span class="c4">&nbsp;position = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">&nbsp;token; </span><span class="c16 c30">// value in between delimiter</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">while</span><span class="c4">&nbsp;((position = line.find(delimiter)) != </span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">::npos) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token = line.substr(0, position);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d-&gt;append_to_feature_vector(</span><span class="c16 c5">std</span><span class="c4">::stod(token));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line.erase(0, position + delimiter.length());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(classMap.find(line) != classMap.end()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d-&gt;set_label(classMap[line]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">else</span><span class="c4">&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;classMap[line] = num_classes;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d-&gt;set_label(classMap[line]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_classes++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_array-&gt;push_back(d);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;feature_vector_size = data_array-&gt;at(0)-&gt;get_double_feature_vector()-&gt;size();<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data_handler::read_feature_vector(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">&nbsp;filePath) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header[4]; </span><span class="c16 c30">// Magic | Num Images | Row Size | Col Size </span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">unsigned</span><span class="c4">&nbsp;</span><span class="c16 c5">char</span><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes[4];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE *f = fopen(filePath.c_str(), </span><span class="c16 c14">&quot;rb&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(f) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 0; i &lt; 4; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(fread(bytes, </span><span class="c16 c5">sizeof</span><span class="c4">(bytes), 1, f)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header[i] = convert_to_little_endian(bytes);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Done getting input file header.\n&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;image_size = header[2] * header[3];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;image_count = </span><span class="c16 c5">std</span><span class="c4">::min(header[1], max_image_array);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 0; i &lt; image_count; i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data *d = </span><span class="c16 c5">new</span><span class="c4">&nbsp;data();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d-&gt;set_feature_vector(</span><span class="c16 c5">new</span><span class="c4">&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">uint8_t</span><span class="c4">&gt;());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint8_t</span><span class="c4">&nbsp;element[784];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fread(element, 1, image_size, f);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;j = 0; j &lt; image_size; j++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(</span><span class="c16 c14">true</span><span class="c4">) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d-&gt;append_to_feature_vector(element[j]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">else</span><span class="c4">&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Error reading from file.\n&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_array-&gt;push_back(d);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normalize();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Successfully read and stored %lu feature vectors.\n&quot;</span><span class="c4">, data_array-&gt;size());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} </span><span class="c16 c5">else</span><span class="c4">&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Could not find file.\n&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data_handler::read_feature_labels(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">&nbsp;filePath) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header[2]; </span><span class="c16 c30">// Magic | Num Images</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">unsigned</span><span class="c4">&nbsp;</span><span class="c16 c5">char</span><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes[4];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE *f = fopen(filePath.c_str(), </span><span class="c16 c14">&quot;rb&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(f) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 0; i &lt; 2; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(fread(bytes, </span><span class="c16 c5">sizeof</span><span class="c4">(bytes), 1, f)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header[i] = convert_to_little_endian(bytes);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Done getting label file header.\n&quot;</span><span class="c4">);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;image_count = </span><span class="c16 c5">std</span><span class="c4">::min(header[1], max_image_array);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 0; i &lt; image_count; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data *d = </span><span class="c16 c5">new</span><span class="c4">&nbsp;data();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint8_t</span><span class="c4">&nbsp;element[1];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(fread(element, </span><span class="c16 c5">sizeof</span><span class="c4">(element), 1, f)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_array-&gt;at(i)-&gt;set_label(element[0]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">else</span><span class="c4">&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Error reading from file.\n&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">exit</span><span class="c4">(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Successfully read and stored label vectors.\n&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">else</span><span class="c4">&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Could not find file.\n&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data_handler::normalize()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt; mins, maxs;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">// fill min and max lists</span><span class="c4"><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data *d = data_array-&gt;at(0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">auto</span><span class="c4">&nbsp;val : *d-&gt;get_feature_vector())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mins.push_back(val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxs.push_back(val);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 1; i &lt; data_array-&gt;size(); i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = data_array-&gt;at(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;j = 0; j &lt; d-&gt;get_feature_vector_size(); j++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;value = (</span><span class="c16 c5">double</span><span class="c4">)d-&gt;get_feature_vector()-&gt;at(j);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(value &lt; mins.at(j)) mins[j] = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(value &gt; maxs.at(j)) maxs[j] = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">// normalize data array</span><span class="c4"><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 0; i &lt; data_array-&gt;size(); i++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_array-&gt;at(i)-&gt;setNormalizedFeatureVector(</span><span class="c16 c5">new</span><span class="c4">&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;</span><span class="c16 c5">double</span><span class="c4">&gt;());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_array-&gt;at(i)-&gt;set_class_vector(get_class_count());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;j = 0; j &lt; data_array-&gt;at(i)-&gt;get_feature_vector_size(); j++)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(maxs[j] - mins[j] == 0) data_array-&gt;at(i)-&gt;append_to_feature_vector(0.0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">else</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_array-&gt;at(i)-&gt;append_to_feature_vector((</span><span class="c16 c5">double</span><span class="c4">)(data_array-&gt;at(i)-&gt;get_feature_vector()-&gt;at(j) - mins[j]) / (maxs[j] - mins[j]));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data_handler::split_data() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">unordered_set</span><span class="c4">&nbsp;&lt;</span><span class="c16 c5">int</span><span class="c4">&gt; used_indexes;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;train_size = data_array-&gt;size() * TRAIN_SET_PERCENT;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;test_size = data_array-&gt;size() * TEST_SET_PERCENT;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;valid_size = data_array-&gt;size() * VALIDATION_PERCENT;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">// Training Data</span><span class="c4"><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;count = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">while</span><span class="c4">&nbsp;(count &lt; train_size) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;rand_index = count;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">//uint32_t rand_index = rand() % data_array-&gt;size(); &nbsp;// Takes too long</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(used_indexes.find(rand_index) == used_indexes.end()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;training_data-&gt;push_back(data_array-&gt;at(rand_index));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used_indexes.insert(rand_index);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">// Test Data</span><span class="c4"><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">while</span><span class="c4">&nbsp;(count &lt; test_size) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">//uint32_t rand_index = rand() % data_array-&gt;size(); &nbsp;// Takes too long</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;rand_index = train_size + count;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(used_indexes.find(rand_index) == used_indexes.end()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_data-&gt;push_back(data_array-&gt;at(rand_index));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used_indexes.insert(rand_index);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">// Validation Data</span><span class="c4"><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">while</span><span class="c4">&nbsp;(count &lt; valid_size) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">//uint32_t rand_index = rand() % data_array-&gt;size(); &nbsp;// Takes too long</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;rand_index = train_size + test_size + count;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(used_indexes.find(rand_index) == used_indexes.end()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validation_data-&gt;push_back(data_array-&gt;at(rand_index));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used_indexes.insert(rand_index);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Training Data Size: %lu.\n&quot;</span><span class="c4">, training_data-&gt;size());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Test Data Size: %lu.\n&quot;</span><span class="c4">, test_data-&gt;size());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Validation Data Size: %lu.\n&quot;</span><span class="c4">, validation_data-&gt;size());<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;data_handler::count_classes() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;count = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">unsigned</span><span class="c4">&nbsp;i = 0; i &lt; data_array-&gt;size(); i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(class_map.find(data_array-&gt;at(i)-&gt;get_label()) == class_map.end()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_map[data_array-&gt;at(i)-&gt;get_label()] = count;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_array-&gt;at(i)-&gt;set_enumerated_label(count);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_classes = count;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Extracted %d unique classes.\n&quot;</span><span class="c4">, num_classes);<br>}<br><br></span><span class="c16 c5">uint32_t</span><span class="c4">&nbsp;data_handler::convert_to_little_endian(</span><span class="c16 c5">const</span><span class="c4">&nbsp;</span><span class="c16 c5">unsigned</span><span class="c4">&nbsp;</span><span class="c16 c5">char</span><span class="c4">&nbsp;* bytes) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;(</span><span class="c16 c5">uint32_t</span><span class="c4">)((bytes[0] &lt;&lt; 24) | (bytes[1] &lt;&lt; 16) | (bytes[2] &lt;&lt; 8) | (bytes[3]));<br>}<br><br></span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * data_handler::get_training_data() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;training_data;<br>}<br></span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * data_handler::get_test_data() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;test_data;<br>}<br></span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * data_handler::get_validation_data() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;validation_data;<br>}<br><br></span><span class="c16 c5">int</span><span class="c4">&nbsp;data_handler::get_class_count() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;num_classes;<br>}</span></p></td></tr></tbody></table><h4 class="c52 c67" id="h.u0qoyi5nstzw"><span class="c4 c15 c23"></span></h4><h4 class="c52" id="h.fvgndexjddzk"><span class="c4 c15 c23">common_data.h + common_data.cpp</span></h4><a id="t.fd5dcc07eda491f28361b480b43cab9bfd15cf70"></a><a id="t.16"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c43"><span class="c16 c25">#ifndef __COMMON_HPP</span><span class="c4"><br></span><span class="c16 c25">#define __COMMON_HPP</span><span class="c4"><br><br><br></span><span class="c16 c25">#pragma once</span><span class="c4"><br><br></span><span class="c16 c25">#include &lt;vector&gt;</span><span class="c4"><br></span><span class="c16 c25">#include &quot;data.h&quot;</span><span class="c4"><br></span><span class="c16 c25">#include &quot;data_handler.h&quot;</span><span class="c4"><br><br></span><span class="c16 c5">class</span><span class="c4">&nbsp;</span><span class="c16 c14">common_data</span><span class="c4"><br>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">public</span><span class="c4">:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;common_data();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~common_data();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">set_training_Data</span><span class="c4">(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * vect);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">set_test_Data</span><span class="c4">(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * vect);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">set_validation_Data</span><span class="c4">(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * vect);<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">protected</span><span class="c4">:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&nbsp;&lt;data *&gt; * training_data;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&nbsp;&lt;data *&gt; * test_data;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&nbsp;&lt;data *&gt; * validation_data;<br><br>};<br><br><br></span><span class="c16 c25">#endif </span><span class="c16 c30">// !__COMMON_HPP</span></p></td></tr></tbody></table><p class="c43 c12"><span class="c1"></span></p><a id="t.b6c40e886ad8282ed694fbb1b39ab41e817ec833"></a><a id="t.17"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c43"><span class="c16 c25">#include &quot;common_data.h&quot;</span><span class="c4"><br><br><br><br>common_data::common_data()<br>{<br>}<br><br><br>common_data::~common_data()<br>{<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;common_data::set_training_Data(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * vect) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;training_data = vect;<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;common_data::set_test_Data(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * vect) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_data = vect;<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;common_data::set_validation_Data(</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt; * vect) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validation_data = vect;<br>}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h4 class="c52" id="h.7i1yk8c9jq3r"><span class="c4 c15 c23">Graphic.h + Graphic.cpp</span></h4><a id="t.54941471817471aa971e9f8a897bc3a592a05a3f"></a><a id="t.18"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c43"><span class="c16 c25">#include &quot;data.h&quot;;</span><span class="c4"><br><br></span><span class="c16 c25">#include &lt;thread&gt;</span><span class="c4"><br><br></span><span class="c16 c25">#include &lt;SFML/Graphics.hpp&gt;</span><span class="c4"><br><br></span><span class="c16 c25">#pragma once</span><span class="c4"><br></span><span class="c16 c5">class</span><span class="c4">&nbsp;</span><span class="c16 c14">Graphic</span><span class="c4"><br>{<br></span><span class="c16 c5">public</span><span class="c4">:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graphic();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~Graphic();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">static</span><span class="c4">&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">drawImages</span><span class="c4">(data * query, data * input);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">static</span><span class="c4">&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">drawImage</span><span class="c4">(data * image, </span><span class="c16 c5">int</span><span class="c4">&nbsp;* label);<br>};</span></p></td></tr></tbody></table><p class="c43 c12"><span class="c1"></span></p><a id="t.078ed88b2dc6e64d44bd6d3f806a4b489776236a"></a><a id="t.19"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c43"><span class="c16 c25">#include &quot;Graphic.h&quot;</span><span class="c4"><br><br><br><br>Graphic::Graphic()<br>{<br>}<br><br><br>Graphic::~Graphic()<br>{<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;Graphic::drawImages(data * query, data * input) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::RenderWindow </span><span class="c16 c14">gameWindow</span><span class="c4">(sf::VideoMode(104, 84), &quot;Images&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameWindow.setSize(sf::Vector2u(860, 760));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::Image qImage;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qImage.create(28, 28);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 0; i &lt; query-&gt;get_feature_vector_size(); i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;c = query-&gt;get_feature_vector()-&gt;at(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qImage.setPixel(i % 28, (i - (i % 28)) / 28, sf::Color(c, c, c, c));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qImage.saveToFile(</span><span class="c16 c14">&quot;qImage.png&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::Texture qTexture;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qTexture.loadFromImage(qImage);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::Sprite </span><span class="c16 c14">qSprite</span><span class="c4">(qTexture);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qSprite.setPosition(100.0, 100.0);<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::Image iImage;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iImage.create(28, 28);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;x = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;y = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 0; i &lt; input-&gt;get_feature_vector_size(); i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;c = input-&gt;get_feature_vector()-&gt;at(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iImage.setPixel(x, y, sf::Color(c, 0, 0, 255));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(x == 28) { y++; x = 0; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::Texture iTexture;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iTexture.loadFromImage(iImage);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::Sprite </span><span class="c16 c14">iSprite</span><span class="c4">(iTexture);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qSprite.setPosition(480.0, 500.0);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">while</span><span class="c4">&nbsp;(gameWindow.isOpen()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameWindow.draw(iSprite);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameWindow.display();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Loaded Images&quot;</span><span class="c4">);<br>}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;Graphic::drawImage(data * image, </span><span class="c16 c5">int</span><span class="c4">&nbsp;* label) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::RenderWindow </span><span class="c16 c14">gameWindow</span><span class="c4">(sf::VideoMode(200, 200), &quot;Images&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameWindow.setSize(sf::Vector2u(200, 200));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::Image qImage;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qImage.create(28, 28);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 0; i &lt; image-&gt;get_feature_vector_size(); i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;c = image-&gt;get_feature_vector()-&gt;at(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qImage.setPixel(i % 28, (i - (i % 28)) / 28, sf::Color(c, c, c, 255));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::Texture qTexture;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qTexture.loadFromImage(qImage);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::Sprite </span><span class="c16 c14">qSprite</span><span class="c4">(qTexture);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qSprite.setPosition(0, 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qSprite.setScale(sf::Vector2f(5, 5));<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::Text tLabel;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tLabel.setString(</span><span class="c16 c14">&quot;Prediction: &quot;</span><span class="c4">&nbsp;+ </span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">string</span><span class="c4">((</span><span class="c16 c5">char</span><span class="c4">&nbsp;*)(label)));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tLabel.setPosition(20, 150);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tLabel.setFillColor(sf::Color::White);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sf::Font f = sf::Font();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.loadFromFile(</span><span class="c16 c14">&quot;Fonts/arial.ttf&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tLabel.setFont(f);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameWindow.draw(qSprite);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameWindow.draw(tLabel);<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameWindow.display();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::this_thread::sleep_for(</span><span class="c16 c5">std</span><span class="c4">::chrono::milliseconds(500));<br><br>}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><h3 class="c39 c47" id="h.gclhfxloic3v"><span class="c4 c15 c18"></span></h3><h3 class="c39" id="h.ng6x7hwph2mb"><span class="c4 c15 c18">KNN - K Nearest Neighbors</span></h3><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K Nearest Neighbors (KNN) is a simple and intuitive supervised machine learning algorithm. The concept of KNN is to place all the data, as points, in an &lsquo;n&rsquo; dimensional void, and then compare new information to the &lsquo;K&rsquo; closest data points (K Neighbors). The algorithm then classifies the new data according to the classes of the neighbors.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The following image shows many points on a two dimensional plane classified by their color. The translucent shapes show an approximation of the classification zones which the algorithm would come up with according to the given data. The diagram is of a &ldquo;K = 3&rdquo; KNN algorithm, meaning that there are three lines connecting points &alpha; and &beta; to the three closest points. As visualized by the encompassing shapes, point &alpha;&rsquo;s closest neighbors consist of two red points and one green point, meaning &alpha; is most likely a red point. Point &beta; is very close to two blue points and one green point, and therefore is most likely a blue point as well.</span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 346.67px;"><img alt="" src="images/image26.png" style="width: 601.70px; height: 346.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h4 class="c52" id="h.ka9r1rsai5ay"><span class="c4 c15 c23">Utility</span></h4><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KNN shines mostly in its simplicity of usage and implementation. While not being the best at classifying and not being too good for much else, contrary to a neural network, KNN starts working at a relatively good accuracy from the beginning. The one major setback of KNN is the necessity of having a substantial set of pre-classified examples for the classifier to compare with, though it does not require time to process and learn the data set, which is a great upside.</span></p><h4 class="c52" id="h.a01redtf54dc"><span class="c4 c15 c23">Final Result</span></h4><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The final result of the KNN classifier was acceptable, with an approximate 94% accuracy on the validation sample and 85% on the test sample when K was set to 8.</span></p><h4 class="c52" id="h.pfmkdneijd5q"><span class="c4 c15 c23">Code</span></h4><a id="t.af29223ea97dfcfd1b7af48b60f5797f09f0c355"></a><a id="t.20"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c43"><span class="c16 c25">#ifndef __KNN_H</span><span class="c4"><br></span><span class="c16 c25">#define __KNN_H</span><span class="c4"><br></span><span class="c16 c25">#pragma once</span><span class="c4"><br><br></span><span class="c16 c25">#include &quot;common_data.h&quot;</span><span class="c4"><br><br></span><span class="c16 c5">class</span><span class="c4">&nbsp;</span><span class="c16 c14">knn</span><span class="c4">&nbsp;: </span><span class="c16 c5">public</span><span class="c4">&nbsp;common_data {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;k;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&nbsp;&lt;data *&gt; * neighbors;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">/*std::vector &lt;data *&gt; * training_data;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector &lt;data *&gt; * test_data;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector &lt;data *&gt; * validation_data;*/</span><span class="c4">&nbsp; </span><span class="c16 c30">// Now in common_data</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">public</span><span class="c4">:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;knn(</span><span class="c16 c5">int</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;knn();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~knn();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">find_knearest</span><span class="c4">(data * query_point);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">/*void set_training_Data(std::vector&lt;data *&gt; * vect);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void set_test_Data(std::vector&lt;data *&gt; * vect);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void set_validation_Data(std::vector&lt;data *&gt; * vect);*/</span><span class="c4">&nbsp; </span><span class="c16 c30">// Now in common_data</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">void</span><span class="c4">&nbsp;</span><span class="c16 c14">set_k</span><span class="c4">(</span><span class="c16 c5">int</span><span class="c4">&nbsp;val);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;</span><span class="c16 c14">predict</span><span class="c4">();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;</span><span class="c16 c14">calculate_distance</span><span class="c4">(data * query_point, data * input);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;</span><span class="c16 c14">validate_performance</span><span class="c4">();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;</span><span class="c16 c14">test_performance</span><span class="c4">();<br>};<br><br><br><br></span><span class="c16 c25">#endif </span><span class="c16 c30">// !__KNN_H</span></p></td></tr></tbody></table><p class="c43 c12"><span class="c1"></span></p><a id="t.4969cd22d2ccdbbb921583b113c84fc02220747e"></a><a id="t.21"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c43"><span class="c16 c25">#include &quot;knn.h&quot;</span><span class="c4"><br></span><span class="c16 c25">#include &lt;cmath&gt;</span><span class="c4"><br></span><span class="c16 c25">#include &lt;limits&gt;</span><span class="c4"><br></span><span class="c16 c25">#include &lt;map&gt;</span><span class="c4"><br></span><span class="c16 c25">#include &quot;stdint.h&quot;</span><span class="c4"><br></span><span class="c16 c25">#include &quot;data_handler.h&quot;</span><span class="c4"><br><br></span><span class="c16 c25">#include &quot;Graphic.h&quot;</span><span class="c4"><br><br>knn::knn(</span><span class="c16 c5">int</span><span class="c4">&nbsp;val) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = val;<br>}<br><br>knn::knn() {}<br>knn::~knn() {}<br><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;knn::find_knearest(data * query_point) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors = </span><span class="c16 c5">new</span><span class="c4">&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">vector</span><span class="c4">&lt;data *&gt;;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;min = </span><span class="c16 c5">std</span><span class="c4">::numeric_limits&lt;</span><span class="c16 c5">double</span><span class="c4">&gt;::max();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;previous_min = min;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;index = 0;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 0; i &lt; k; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(i == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;j = 0; j &lt; training_data-&gt;size(); j++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;distance = calculate_distance(query_point, training_data-&gt;at(j));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;training_data-&gt;at(j)-&gt;set_distance(distance);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(distance &lt; min) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min = distance;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = j;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors-&gt;push_back(training_data-&gt;at(index));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previous_min = min;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min = </span><span class="c16 c5">std</span><span class="c4">::numeric_limits&lt;</span><span class="c16 c5">double</span><span class="c4">&gt;::max();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">else</span><span class="c4">&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;j = 0; j &lt; training_data-&gt;size(); j++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;distance = training_data-&gt;at(j)-&gt;get_distance(); </span><span class="c16 c30">// calculate_distance(query_point, training_data-&gt;at(j));</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(distance &gt; previous_min &amp;&amp; distance &lt; min) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min = distance;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index = j;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors-&gt;push_back(training_data-&gt;at(index));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;previous_min = min;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min = </span><span class="c16 c5">std</span><span class="c4">::numeric_limits&lt;</span><span class="c16 c5">double</span><span class="c4">&gt;::max();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></span><span class="c16 c30">/*<br>void knn::set_training_Data(std::vector&lt;data *&gt; * vect) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;training_data = vect;<br>}<br><br>void knn::set_test_Data(std::vector&lt;data *&gt; * vect) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test_data = vect;<br>}<br><br>void knn::set_validation_Data(std::vector&lt;data *&gt; * vect) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validation_data = vect;<br>}<br>*/</span><span class="c4">&nbsp; </span><span class="c16 c30">// Now in common_data</span><span class="c4"><br></span><span class="c16 c5">void</span><span class="c4">&nbsp;knn::set_k(</span><span class="c16 c5">int</span><span class="c4">&nbsp;val) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = val;<br>}<br><br></span><span class="c16 c5">int</span><span class="c4">&nbsp;knn::predict() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">std</span><span class="c4">::</span><span class="c16 c5">map</span><span class="c4">&lt;</span><span class="c16 c5">uint8_t</span><span class="c4">, </span><span class="c16 c5">int</span><span class="c4">&gt; class_freq;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;i = 0; i &lt; neighbors-&gt;size(); i++) { </span><span class="c16 c30">// Count the frequency of a class in the neighboring points</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(class_freq.find(neighbors-&gt;at(i)-&gt;get_label()) == class_freq.end()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_freq[neighbors-&gt;at(i)-&gt;get_label()] = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} </span><span class="c16 c5">else</span><span class="c4">&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class_freq[neighbors-&gt;at(i)-&gt;get_label()]++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;best = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;max = 0;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">std</span><span class="c4">::pair&lt;</span><span class="c16 c5">uint8_t</span><span class="c4">, </span><span class="c16 c5">int</span><span class="c4">&gt; kv : class_freq) { </span><span class="c16 c30">// Find the most frequent class</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(kv.second &gt; max) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max = kv.second;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best = kv.first;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors-&gt;clear();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;best;<br>}<br><br></span><span class="c16 c5">double</span><span class="c4">&nbsp;knn::calculate_distance(data * query_point, data * input) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;distance = 0.0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(query_point-&gt;get_feature_vector_size() != input-&gt;get_feature_vector_size()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Vector size mismatch&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">exit</span><span class="c4">(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br></span><span class="c16 c30">//#ifdef EUCLID</span><span class="c4"><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">unsigned</span><span class="c4">&nbsp;i = 0; i &lt; query_point-&gt;get_feature_vector_size(); i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance += </span><span class="c16 c5">pow</span><span class="c4">(query_point-&gt;get_feature_vector()-&gt;at(i) - input-&gt;get_feature_vector()-&gt;at(i),2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance = </span><span class="c16 c5">sqrt</span><span class="c4">(distance);</span></p><p class="c43"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;distance;<br>}<br></span><span class="c16 c5">double</span><span class="c4">&nbsp;knn::validate_performance() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;current_performance = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;count = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;data_index = 0;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(data * query_point : * validation_data) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;find_knearest(query_point);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;prediction = predict();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;asciiPred = prediction + 48;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graphic::drawImage(query_point, &amp;asciiPred);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Guessed %d for %d\n&quot;</span><span class="c4">, prediction, query_point-&gt;get_label());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(prediction == query_point-&gt;get_label()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">else</span><span class="c4">&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">//printf(&quot;Mist</span><span class="c30">ook</span><span class="c16 c30">&nbsp;%d for %d\n&quot;, query_point-&gt;get_label(), prediction);</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_index++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Current Performance: %.3f %%\n&quot;</span><span class="c4">, ((</span><span class="c16 c5">double</span><span class="c4">)count*100.0) / ((</span><span class="c16 c5">double</span><span class="c4">)data_index));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_performance = ((</span><span class="c16 c5">double</span><span class="c4">)count*100.0) / ((</span><span class="c16 c5">double</span><span class="c4">)validation_data-&gt;size());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Validation Performance for K = %d: %.3f %%\n&quot;</span><span class="c4">, k, current_performance);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;current_performance;<br>}<br><br></span><span class="c16 c5">double</span><span class="c4">&nbsp;knn::test_performance() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;current_performance = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;count = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">//int data_index = 0;</span><span class="c4"><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(data * query_point : * test_data) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;find_knearest(query_point);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;prediction = predict();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(prediction == query_point-&gt;get_label()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_performance = ((</span><span class="c16 c5">double</span><span class="c4">)count*100.0) / ((</span><span class="c16 c5">double</span><span class="c4">)test_data-&gt;size());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c14 c16">&quot;Test Performance: %.3f %%\n&quot;</span><span class="c4">, current_performance);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">return</span><span class="c4">&nbsp;current_performance;<br>}<br><br></span><span class="c16 c5">int</span><span class="c4">&nbsp;</span><span class="c16 c14">main</span><span class="c4">() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_handler *dh = </span><span class="c16 c5">new</span><span class="c4">&nbsp;data_handler();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">//dh-&gt;read_feature_vector(&quot;C:/Users/stein/Desktop/Research Project 2020/Neural Networks/MNIST/Training Data/Training Data/train-images.idx3-ubyte&quot;);</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dh-&gt;read_feature_vector(</span><span class="c16 c14">&quot;../Training Data/train-images.idx3-ubyte&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c30">//dh-&gt;read_feature_labels(&quot;C:/Users/stein/Desktop/Research Project 2020/Neural Networks/MNIST/Training Data/Training Data/train-labels.idx1-ubyte&quot;);</span><span class="c4"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dh-&gt;read_feature_labels(</span><span class="c16 c14">&quot;../Training Data/train-labels.idx1-ubyte&quot;</span><span class="c4">);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dh-&gt;split_data();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dh-&gt;count_classes();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;knn * knearest = </span><span class="c16 c5">new</span><span class="c4">&nbsp;knn();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;knearest-&gt;set_training_Data(dh-&gt;get_training_data());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;knearest-&gt;set_test_Data(dh-&gt;get_test_data());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;knearest-&gt;set_validation_Data(dh-&gt;get_validation_data());<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;performance = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">double</span><span class="c4">&nbsp;best_performance = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">int</span><span class="c4">&nbsp;best_k = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">for</span><span class="c4">&nbsp;(</span><span class="c16 c5">int</span><span class="c4">&nbsp;k = 4; k &lt;= 8; k++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(k == 1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;knearest-&gt;set_k(k);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;performance = knearest-&gt;validate_performance();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best_performance = performance;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">else</span><span class="c4">&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;knearest-&gt;set_k(k);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;performance = knearest-&gt;validate_performance();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">if</span><span class="c4">&nbsp;(performance &gt; best_performance) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best_performance = performance;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;best_k = k;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;knearest-&gt;set_k(best_k);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;knearest-&gt;test_performance();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c16 c5">printf</span><span class="c4">(</span><span class="c16 c14">&quot;Closing...&quot;</span><span class="c4">);<br>}</span></p></td></tr></tbody></table><hr style="page-break-before:always;display:none;"><h3 class="c39" id="h.uim2dx2zutxx"><span class="c4 c15 c18">K-Means Clustering</span></h3><p class="c17 c46"><span class="c16">K-Means Clustering is relatively similar to KNN in the sense that it&rsquo;s also a supervised machine learning model. The main difference between the learning models is that K Nearest Neighbours tests each potential query point against all the points known to the algorithm and finds the K nearest ones, while K-Means tests query points against K centres of mass. K-Means initially loads all the known data points (the labeled training data) and splits it into K zones, each which corresponds to some label (for example, if we had two large clusters of points we could set K to 2 and assume that there is a high probability that another point close to one of the clusters would be of the same type as most of the points in the cluster). </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 389.33px;"><img alt="" src="images/image14.png" style="width: 601.70px; height: 389.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h4 class="c52" id="h.7nxi9lox5okj"><span class="c4 c15 c23">Utility</span></h4><p class="c17 c46"><span class="c1">K Means is significantly faster at classifying than KNN, which is a nifty upside for general testing. However, K Means was wildly inaccurate (usually below 80%) on all tests and validations I conducted. Therefore, K Means will not be developed further for use with audio classification.</span></p><h4 class="c52" id="h.ellbdowp1qjw"><span class="c4 c15 c23">Final Result</span></h4><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 314.67px;"><img alt="" src="images/image7.png" style="width: 601.70px; height: 314.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clearly, K-Means is not ideal for this sort of classification, nor the rest of the project. However, it does have a clear advantage over KNN in terms of speed - once the clusters are constant, as K-Means only needs to compare a query point to the clusters, not every single other data point.</span></p><h4 class="c52" id="h.ntm4lnbaq5ce"><span class="c4 c15 c23">Code</span></h4><a id="t.971ddfb20c8f2a55a951b916055d50d878ea32ac"></a><a id="t.22"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#ifndef</span><span class="c1">&nbsp;__KMEAN_HPP</span></p><p class="c0"><span class="c5">#define</span><span class="c1">&nbsp;__KMEAN_HPP</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">common_data.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">unordered_set</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">limits</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">cstdlib</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">cmath</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">map</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">typedef</span><span>&nbsp;</span><span class="c5">struct</span><span class="c1">&nbsp;cluster {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * centroid;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;data *&gt; * cluster_points;</span></p><p class="c0"><span>&nbsp; &nbsp; std::map&lt;</span><span class="c5">int</span><span>, </span><span class="c5">int</span><span class="c1">&gt; class_counts;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;most_frequent_class;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; cluster(data * initial_point) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; centroid = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt;;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; cluster_points = </span><span class="c5">new</span><span class="c1">&nbsp;std::vector&lt;data *&gt;;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">auto</span><span class="c1">&nbsp;value : *(initial_point-&gt;get_feature_vector())) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; centroid-&gt;push_back(value);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; cluster_points-&gt;push_back(initial_point);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; class_counts[initial_point-&gt;get_label()] = </span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; most_frequent_class = initial_point-&gt;get_label();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;add_to_cluster(data * point) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;previous_size = cluster_points-&gt;size();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; cluster_points-&gt;push_back(point);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; centroid-&gt;size() - </span><span class="c7">1</span><span class="c1">; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;value = centroid-&gt;at(i);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value *= previous_size;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value += point-&gt;get_feature_vector()-&gt;at(i);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value /= (</span><span class="c5">double</span><span class="c1">)cluster_points-&gt;size();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; centroid-&gt;at(i) = value;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(class_counts.find(point-&gt;get_label()) == class_counts.end()) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class_counts[point-&gt;get_label()] = </span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; } </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class_counts[point-&gt;get_label()]++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; set_most_frequent_class();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;set_most_frequent_class() {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;best_class;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;freq = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">auto</span><span class="c1">&nbsp;kv : class_counts) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(kv.second &gt; freq) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freq = kv.second;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_class = kv.first;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; most_frequent_class = best_class;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">} cluster_t;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">class</span><span>&nbsp;kmeans : </span><span class="c5">public</span><span class="c1">&nbsp;common_data {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;num_clusters;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;cluster_t *&gt; * clusters;</span></p><p class="c0"><span>&nbsp; &nbsp; std::unordered_set&lt;</span><span class="c5">int</span><span class="c1">&gt; * used_indexes;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">public</span><span class="c1">:</span></p><p class="c0"><span>&nbsp; &nbsp; kmeans(</span><span class="c5">int</span><span class="c1">&nbsp;k);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; kmeans();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ~kmeans();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;init_clusters();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;init_clusters_for_each_class();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;train();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;euclidean_distance(std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; *, data *);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;validate();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;test();</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#endif</span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">kmeans.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">kmeans::kmeans() {}</span></p><p class="c0"><span class="c1">kmeans::~kmeans() {}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>kmeans::kmeans(</span><span class="c5">int</span><span class="c1">&nbsp;k) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; num_clusters = k;</span></p><p class="c0"><span>&nbsp; &nbsp; clusters = </span><span class="c5">new</span><span class="c1">&nbsp;std::vector&lt;cluster_t *&gt;;</span></p><p class="c0"><span>&nbsp; &nbsp; used_indexes = </span><span class="c5">new</span><span>&nbsp;std::unordered_set&lt;</span><span class="c5">int</span><span class="c1">&gt;;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;kmeans::init_clusters() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; num_clusters; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = (rand() % training_data-&gt;size());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(used_indexes-&gt;find(index) != used_indexes-&gt;end()) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; index = (rand() % training_data-&gt;size());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; clusters-&gt;push_back(</span><span class="c5">new</span><span class="c1">&nbsp;cluster(training_data-&gt;at(index)));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; used_indexes-&gt;insert(index);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;kmeans::init_clusters_for_each_class() {</span></p><p class="c0"><span>&nbsp; &nbsp; std::unordered_set&lt;</span><span class="c5">int</span><span class="c1">&gt; classes_used;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; training_data-&gt;size(); i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(classes_used.find(training_data-&gt;at(i)-&gt;get_label()) == classes_used.end()) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clusters-&gt;push_back(</span><span class="c5">new</span><span class="c1">&nbsp;cluster_t(training_data-&gt;at(i)));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classes_used.insert(training_data-&gt;at(i)-&gt;get_label());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; used_indexes-&gt;insert(i);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;kmeans::train() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(used_indexes-&gt;size() &lt; training_data-&gt;size()) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = (rand() % training_data-&gt;size());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(used_indexes-&gt;find(index) != used_indexes-&gt;end()) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = (rand() % training_data-&gt;size());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;min_dist = std::numeric_limits&lt;</span><span class="c5">double</span><span class="c1">&gt;::max();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;best_cluster = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; clusters-&gt;size(); j++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;current_dist = euclidean_distance(clusters-&gt;at(j)-&gt;centroid, training_data-&gt;at(index));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(current_dist &lt; min_dist) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_dist = current_dist;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_cluster = j;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; clusters-&gt;at(best_cluster)-&gt;add_to_cluster(training_data-&gt;at(index));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; used_indexes-&gt;insert(index);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span>&nbsp;kmeans::euclidean_distance(std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * centroid, data * point) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;dist = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; centroid-&gt;size(); i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; dist += pow(centroid-&gt;at(i) - point-&gt;get_feature_vector()-&gt;at(i), </span><span class="c7">2</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;sqrt(dist);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;kmeans::validate() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;num_correct = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">auto</span><span class="c1">&nbsp;query_point : *validation_data) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;min_dist = std::numeric_limits&lt;</span><span class="c5">double</span><span class="c1">&gt;::max();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;best_cluster = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; clusters-&gt;size(); j++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;current_dist = euclidean_distance(clusters-&gt;at(j)-&gt;centroid, query_point);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(current_dist &lt; min_dist) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_dist = current_dist;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_cluster = j;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(clusters-&gt;at(best_cluster)-&gt;most_frequent_class == query_point-&gt;get_label()) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_correct++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">100.0</span><span>&nbsp;* (num_correct / (</span><span class="c5">double</span><span class="c1">)validation_data-&gt;size());</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;kmeans::test() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;num_correct = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">auto</span><span class="c1">&nbsp;query_point : * test_data) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;min_dist = std::numeric_limits&lt;</span><span class="c5">double</span><span class="c1">&gt;::max();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;best_cluster = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; clusters-&gt;size(); j++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;current_dist = euclidean_distance(clusters-&gt;at(j)-&gt;centroid, query_point);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(current_dist &lt; min_dist) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_dist = current_dist;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_cluster = j;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(clusters-&gt;at(best_cluster)-&gt;most_frequent_class == query_point-&gt;get_label()) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_correct++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">100.0</span><span>&nbsp;* (num_correct / (</span><span class="c5">double</span><span class="c1">)test_data-&gt;size());</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><h3 class="c39 c47" id="h.17ml7448um"><span class="c4 c15 c18"></span></h3><h3 class="c39" id="h.wpdnekuu8i36"><span class="c4 c15 c18">Neural Network</span></h3><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Neural Networks are the classic example of Machine Learning. Neural Networks are the form of machine learning most similar to animals&rsquo; organic learning, as the network of neurons is vaguely based on the neurons in our brains which are interconnected by synapses.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The idea is that each neuron is activated based on the weights and biases connected to it combined with the activation outputs of the neurons from the previous layer. The network evolves and learns by adjusting these weights and biases to output the desired values.</span></p><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 288.00px;"><img alt="" src="images/image29.png" style="width: 601.70px; height: 288.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conventionally, we group neurons into layers, which we can then say are connected to each other. Essentially, two connected layers means each neuron in the first layer is connected by a &ldquo;synapses&rdquo; with certain weights to each of the neurons in the following layer.</span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Training a neural network is where the complications escalate. What is implemented here is a backpropagation, which is an algorithm that computes the gradients of the loss function according to the difference between the outputs from the network and the desired outputs, and uses this gradient to find the minimum of the loss function - which would be the &ldquo;smartest&rdquo; network, the network who&rsquo;s weights and biases are as ideal as possible for the problem.</span></p><h4 class="c52" id="h.olgezktlkg8n"><span class="c4 c15 c23">Gradient Descent</span></h4><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gradient Descent is a way of computing which changes (&ldquo;nudges&rdquo;) need to be made to the weights of a neuron in order to minimize the cost of the network as efficiently as possible. Gradient Descent in effect calculates the gradient vector which shows how sensitive the output of the network is to changes to each of the neurons in the current layer (doing so recursively is backpropagation).</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We can visualize a two dimensional gradient descent, where the black line is our cost function, the blue dot is our weights and biases, and the red line is our gradient. What gradient descent tells us, is that if we follow the opposite of the gradient (-f&rsquo;(x)) and move, as in adjust the weights and biases, proportionally to its size (represented by a longer red line below), we will reach a local (ideally global) minimum of the cost function in a very efficient manner.</span></p><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 291.58px; height: 261.50px;"><img alt="" src="images/image21.png" style="width: 291.58px; height: 261.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 288.72px; height: 261.50px;"><img alt="" src="images/image18.png" style="width: 288.72px; height: 261.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17"><span class="c1">We can prove that this will converge onto a local minimum:</span></p><p class="c17 c12"><span class="c1"></span></p><a id="t.c32a0e92adc94f42ecece0db92bf8a7c286600b2"></a><a id="t.23"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c11"><span>Let&rsquo;s call the cost function </span><span class="c29">F</span><span>(</span><span class="c29">x</span><span class="c1">) and assume it is defined and differentiable for all values.</span></p><p class="c31"><span>Let &nabla;</span><span class="c29">F </span><span>be the derivative of </span><span class="c29">F</span><span class="c1">.</span></p><p class="c31"><span>Assume point </span><span class="c29">a</span><span class="c13 c29">n</span><span class="c1">&nbsp;is our current location on the cost function, representing the weights and biases of the network.</span></p><p class="c31"><span>&upsih; being our learning rate such that: &upsih; &isin; &#8477;</span><span class="c13">+</span><span>&nbsp;resolves to the next point </span><span class="c29">a</span><span class="c13 c29">n</span><span class="c13">+1 </span><span class="c1">being:</span></p><p class="c31"><span class="c29">a</span><span class="c13 c29">n</span><span class="c13">+1</span><span>&nbsp;= </span><span class="c29">a</span><span class="c13 c29">n</span><span>&nbsp;- &upsih;&nabla;</span><span class="c29">F</span><span>(</span><span class="c29">a</span><span class="c13 c29">n</span><span class="c1">)</span></p><p class="c31"><span class="c1">and therefore we have a monotonic sequence such that:</span></p><p class="c31"><span class="c29">F</span><span>(</span><span class="c29">a</span><span class="c13">1</span><span>) &ge; </span><span class="c29">F</span><span>(</span><span class="c29">a</span><span class="c13">2</span><span>) &ge; </span><span class="c29">F</span><span>(</span><span class="c29">a</span><span class="c13">3</span><span>) &ge; </span><span class="c29">... </span><span>&ge; </span><span class="c29">F</span><span>(</span><span class="c29">a</span><span class="c13 c29">n</span><span class="c1">)</span></p><p class="c31"><span>meaning that</span><span class="c29">F</span><span>(</span><span class="c29">a</span><span class="c13 c29">n</span><span class="c1">) will be a local minimum of the cost function,</span></p><p class="c31"><span>and as such, our weights and biases array - which is represented by </span><span class="c29">a</span><span class="c13 c29">n</span><span class="c1">- will be semi-idealized to the problem</span></p><p class="c31"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 31.00px; height: 12.00px;"><img alt="" src="images/image23.png" style="width: 31.00px; height: 12.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c1">The neural network has learnt to &ldquo;solve&rdquo; the given problem.</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h4 class="c52" id="h.7d3ty47hixe9"><span class="c4 c15 c23">Backpropagation</span></h4><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backpropagation is one of the core factors of machine learning. Backpropagation in essence is a method of changing the weights and biases of layers in a neural network depending on the layer after them. This method is crucial in training a network, since when training we cannot directly change the outputs of the last layer to fit our problem, rather we change the weights and biases of all the neurons. Backpropagation allows us to quickly calculate how much to change the parameters of each neuron layer by layer simply by inputting our final output and our desired output.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backpropagation works by working backwards - from the last (output) layer, to the first layer - and calculating each time the effect that each neuron in that layer had on the output, and accordingly, should it be increased or decreased and by how much (this is done by calculating the error). Backpropagation then takes this calculation and uses it as the desired output for the previous layer, which in effect simplifies the network recursively so that we only ever update one layer as if it was the output layer and we knew exactly what outputs we wanted there.</span></p><h4 class="c52" id="h.6f23blautjr"><span class="c4 c15 c23">Utility</span></h4><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The most alluring feature of neural networks is the fact that once they have been suited to the problem, they give predictions almost instantaneously. Contrary to KNN, which starts working with a solid accuracy immediately when launched, neural networks start off scoring poorly. Moreover, neural networks do not need an entire dataset to be loaded in memory in order to classify data; all they need is the weights and biases which best suit the problem - the weights and biases which produce the smallest cost function.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This means that once we adequately train a neural network, we can save the weights and biases it calculated and import them at a later date and immediately have a high accuracy, while maintaining a short prediction time.</span></p><h4 class="c52" id="h.c1404dnqdlmy"><span class="c4 c15 c23">Final Result</span></h4><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 652.00px;"><img alt="" src="images/image20.png" style="width: 601.70px; height: 652.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Here we can see a proof of concept for this neural network. Obviously the performance is not ideal. However, this is simply since we are using a very small network - only two hidden layers with ten neurons each. Nevertheless, we clearly see that the network is improving, the iteration error, which is the output of our error function, is going down, and the validation performance is going up.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The main limiting factor here is time; each training cycle takes approximately 12 minutes (disregard the time in the image, as a smaller training dataset was used to produce more results. Therefore, the actual error performance is also inaccurate). This is utterly impractical, especially since for our final product we want a more complex network with many more calculations. See the faster version of this network here.</span></p><h4 class="c52" id="h.f8n6y9e6fhii"><span class="c4 c15 c23">Code</span></h4><p class="c17 c12"><span class="c1"></span></p><a id="t.4a55e7ff8143976cb37583472fd14d80322fa7ba"></a><a id="t.24"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">network.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">layer.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">DataHandler.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">numeric</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">algorithm</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">thread</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">chrono</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">utility</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">typedef</span><span class="c1">&nbsp;std::chrono::high_resolution_clock::time_point TimeVar;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#define</span><span class="c1">&nbsp;duration(a) std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(a).count()</span></p><p class="c0"><span class="c5">#define</span><span class="c1">&nbsp;timeNow() std::chrono::high_resolution_clock::now()</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>Network::Network(std::vector&lt;</span><span class="c5">int</span><span>&gt; spec, </span><span class="c5">int</span><span>&nbsp;inputSize, </span><span class="c5">int</span><span>&nbsp;numClasses, </span><span class="c5">double</span><span class="c1">&nbsp;learningRate)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; spec.size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i == </span><span class="c7">0</span><span class="c1">)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; layers.push_back(</span><span class="c5">new</span><span class="c1">&nbsp;Layer(inputSize, spec.at(i)));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; layers.push_back(</span><span class="c5">new</span><span>&nbsp;Layer(layers.at(i - </span><span class="c7">1</span><span class="c1">)-&gt;neurons.size(), spec.at(i)));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; layers.push_back(</span><span class="c5">new</span><span>&nbsp;Layer(layers.at(layers.size() - </span><span class="c7">1</span><span class="c1">)-&gt;neurons.size(), numClasses));</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;learningRate = learningRate;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">Network::~Network() {}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span>&nbsp;Network::activate(std::vector&lt;</span><span class="c5">double</span><span>&gt; weights, std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; input)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;activation = weights.back(); </span><span class="c6 c3">// bias term</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; weights.size() - </span><span class="c7">1</span><span class="c1">; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; activation += weights[i] * input[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;activation;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span>&nbsp;Network::transfer(</span><span class="c5">double</span><span class="c1">&nbsp;activation)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">1.0</span><span>&nbsp;/ (</span><span class="c7">1.0</span><span class="c1">&nbsp;+ exp(-activation));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span>&nbsp;Network::transferDerivative(std::vector&lt;</span><span class="c5">double</span><span>&gt; errors, std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; inputs)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;derivative = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; errors.size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; derivative += errors[i] * inputs[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; derivative *= </span><span class="c7">2.0</span><span class="c1">&nbsp;/ errors.size();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;derivative;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; Network::CalculateDerivative(Data * data, Layer * myLayer) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; errors1;</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; errors2;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;gamma = </span><span class="c7">0.00000001</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(Neuron *n : myLayer-&gt;neurons) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;error = n-&gt;weights.at(n-&gt;weights.size() - </span><span class="c7">1</span><span>); </span><span class="c6 c3">// bias</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;w = </span><span class="c7">0</span><span>; w &lt; n-&gt;weights.size() - </span><span class="c7">1</span><span class="c1">; w++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error += n-&gt;weights[w] * (data-&gt;getNormalizedFeatureVector()-&gt;at(w));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; errors1.push_back(error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(Neuron *n : myLayer-&gt;neurons) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;error = n-&gt;weights.at(n-&gt;weights.size() - </span><span class="c7">1</span><span>); </span><span class="c6 c3">// bias</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;w = </span><span class="c7">0</span><span>; w &lt; n-&gt;weights.size() - </span><span class="c7">1</span><span class="c1">; w++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error += n-&gt;weights[w] * (data-&gt;getNormalizedFeatureVector()-&gt;at(w) + gamma);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; errors2.push_back(error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; errors_difference;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; errors1.size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; errors_difference.push_back((errors2[i] - errors1[i]) / gamma);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;errors_difference;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span>std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; Network::CalculateDerivative(Layer * preLayer, Layer * myLayer) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; errors1;</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; errors2;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;gamma = </span><span class="c7">0.00000001</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(Neuron *n : myLayer-&gt;neurons) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;error = n-&gt;weights.at(n-&gt;weights.size() - </span><span class="c7">1</span><span>); </span><span class="c6 c3">// bias</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;w = </span><span class="c7">0</span><span>; w &lt; n-&gt;weights.size() - </span><span class="c7">1</span><span class="c1">; w++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error += n-&gt;weights[w] * preLayer-&gt;neurons[w]-&gt;output;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; errors1.push_back(error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(Neuron *n : myLayer-&gt;neurons) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;error = n-&gt;weights.at(n-&gt;weights.size() - </span><span class="c7">1</span><span>); </span><span class="c6 c3">// bias</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;w = </span><span class="c7">0</span><span>; w &lt; n-&gt;weights.size() - </span><span class="c7">1</span><span class="c1">; w++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error += n-&gt;weights[w] * (preLayer-&gt;neurons[w]-&gt;output + gamma);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; errors2.push_back(error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; errors_difference;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; errors1.size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; errors_difference.push_back((errors2[i] - errors1[i]) / gamma);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;errors_difference;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; Network::fprop(Data *data)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; inputs = *data-&gt;getNormalizedFeatureVector();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers.size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Layer *layer = layers.at(i);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; newInputs;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(Neuron *n : layer-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;activation = </span><span class="c5">this</span><span class="c1">-&gt;activate(n-&gt;weights, inputs);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;output = </span><span class="c5">this</span><span class="c1">-&gt;transfer(activation);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newInputs.push_back(n-&gt;output);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; layer-&gt;layerOutputs = newInputs;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; inputs = newInputs;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;inputs; </span><span class="c6 c3">// output layer outputs</span></p><p class="c0"><span>}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span>&nbsp;Network::bprop(std::vector&lt;</span><span class="c5">double</span><span>&gt; deriv_errors) </span><span class="c6 c3">/// Backpropagation</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = layers.size() - </span><span class="c7">1</span><span>; i &gt;= </span><span class="c7">0</span><span class="c1">; i--)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Layer *layer = layers.at(i);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; errors;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i != layers.size() - </span><span class="c7">1</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; layer-&gt;neurons.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Neuron *n : layers.at(i + </span><span class="c7">1</span><span class="c1">)-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error += (n-&gt;weights.at(j) * n-&gt;delta);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors.push_back(error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// If is last layer (i == layers.size()-1)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors = deriv_errors;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; layer-&gt;neurons.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Neuron *n = layer-&gt;neurons.at(j);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;delta = errors[j];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;Network::updateWeights(Data *data)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; inputs = *data-&gt;getNormalizedFeatureVector();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers.size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i != </span><span class="c7">0</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Neuron *n : layers.at(i - </span><span class="c7">1</span><span class="c1">)-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputs.push_back(n-&gt;output);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(Neuron *n : layers.at(i)-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; inputs.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;weights.at(j) += </span><span class="c5">this</span><span class="c1">-&gt;learningRate * n-&gt;delta * inputs.at(j);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;weights.back() += </span><span class="c5">this</span><span class="c1">-&gt;learningRate * n-&gt;delta;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; inputs.clear();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;Network::predict(Data * data)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; outputs = fprop(data);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;std::distance(outputs.begin(), std::max_element(outputs.begin(), outputs.end()));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span>&nbsp;Network::train(</span><span class="c5">int</span><span>&nbsp;numEpochs, </span><span class="c5">int</span><span class="c1">&nbsp;iter)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; numEpochs; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;sumError = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; deriv_error;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;output_vector_size = </span><span class="c5">this</span><span>-&gt;trainingData-&gt;at(</span><span class="c7">0</span><span class="c1">)-&gt;getClassVector().size();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; output_vector_size; i++) { deriv_error.push_back(</span><span class="c7">0.0</span><span class="c1">); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Data *data : *</span><span class="c5">this</span><span class="c1">-&gt;trainingData)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; outputs = fprop(data);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">int</span><span class="c1">&gt; expected = data-&gt;getClassVector();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;tempErrorSum = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; outputs.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tempErrorSum += pow((</span><span class="c5">double</span><span>)expected.at(j) - outputs.at(j), </span><span class="c7">2</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] += (</span><span class="c5">double</span><span class="c1">)expected.at(j) - outputs.at(j);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sumError += tempErrorSum;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error.at(j) /= </span><span class="c5">this</span><span class="c1">-&gt;trainingData-&gt;size();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error.at(j) *= </span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bprop(deriv_error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updateWeights(data);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error.at(j) = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Iteration: %d \t Error=%.4f\n&quot;</span><span class="c1">, (iter * numEpochs) + i, sumError);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;Network::test()</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;numCorrect = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;count = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Data *data : *</span><span class="c5">this</span><span class="c1">-&gt;testData)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = predict(data);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(data-&gt;getClassVector().at(index) == </span><span class="c7">1</span><span class="c1">) numCorrect++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; testPerformance = (numCorrect / count); </span><span class="c6 c3">// as decimal 0 -&gt; 1</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;testPerformance;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;Network::validate()</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;numCorrect = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;count = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Data *data : *</span><span class="c5">this</span><span class="c1">-&gt;validationData)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = predict(data);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(data-&gt;getClassVector().at(index) == </span><span class="c7">1</span><span class="c1">) numCorrect++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Validation Performance: %.4f%%\n&quot;</span><span>, (numCorrect*</span><span class="c7">100</span><span>) / count); </span><span class="c6 c3">// as percentage 0.0000% -&gt; 100.0000%</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;main()</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; DataHandler *dataHandler = </span><span class="c5">new</span><span class="c1">&nbsp;DataHandler();</span></p><p class="c0"><span>&nbsp; &nbsp; dataHandler-&gt;readInputData(</span><span class="c14">&quot;C:\\Users\\stein\\Desktop\\Research Project 2020\\Neural Networks\\MNIST\\Training Data\\train-images.idx3-ubyte&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; dataHandler-&gt;readLabelData(</span><span class="c14">&quot;C:\\Users\\stein\\Desktop\\Research Project 2020\\Neural Networks\\MNIST\\Training Data\\train-labels.idx1-ubyte&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; dataHandler-&gt;countClasses();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; dataHandler-&gt;splitData();</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">int</span><span>&gt; hiddenLayers = { </span><span class="c7">10</span><span>,</span><span class="c7">10</span><span class="c1">&nbsp;};</span></p><p class="c0"><span>&nbsp; &nbsp; Network *netw = </span><span class="c5">new</span><span class="c1">&nbsp;Network(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; hiddenLayers,</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; dataHandler-&gt;getTrainingData()-&gt;at(</span><span class="c7">0</span><span class="c1">)-&gt;getNormalizedFeatureVector()-&gt;size(),</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; dataHandler-&gt;getClassCounts(),</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">0.25</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; netw-&gt;setTrainingData(dataHandler-&gt;getTrainingData());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; netw-&gt;setTestData(dataHandler-&gt;getTestData());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; netw-&gt;setValidationData(dataHandler-&gt;getValidationData());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Initial Validation: \n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; netw-&gt;validate();</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Now training...\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; </span><span class="c7">100</span><span class="c1">; i++) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; TimeVar t1 = timeNow();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; netw-&gt;train(</span><span class="c7">2</span><span>, i); </span><span class="c6 c3">// This takes 674923436000 nanoseconds = 674.92 seconds = 11:15 minutes</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;trainTime = duration(timeNow() - t1);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; TimeVar t2 = timeNow();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; netw-&gt;validate();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;validateTime = duration(timeNow() - t2); &nbsp; &nbsp; </span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Training time: %.2f miliseconds\n&quot;</span><span class="c1">, trainTime);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Validating time: %.2f miliseconds\n&quot;</span><span class="c1">, validateTime);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i % </span><span class="c7">10</span><span>&nbsp;== </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Test Performance: %.3f\n&quot;</span><span class="c1">, netw-&gt;test());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Test Performance: %.3f\n&quot;</span><span class="c1">, netw-&gt;test());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h3 class="c39" id="h.8nkeqr817z3g"><span class="c4 c15 c18">Improved Neural Network</span></h3><p class="c17"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This version of the neural network is simply the previous version except with all the improvements listed in </span><span class="c20"><a class="c8" href="#h.ihrlc1lrddvk">Evolvement - Practical Research</a></span><span class="c1">. The main difference is that we used C code almost exclusively, instead of std::vector - which is a C++ class.</span></p><h4 class="c52" id="h.k856hxxaptyk"><span class="c4 c15 c23">Final Result</span></h4><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 652.00px;"><img alt="" src="images/image15.png" style="width: 601.70px; height: 652.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;As you can see, this version of the network reduced training time from ~674923436000 nanoseconds (674.92 seconds) to ~2661079700 nanoseconds (2.66 seconds); a 99.61% time reduction.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This improvement means we can compile and train a more complex network with more data samples in significantly less time.</span></p><p class="c17"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Training the network for about an hour yielded a test performance of just over 80% with a simple network of one hidden layer with 32 neurons, which was plenty of proof to show that the network is in-fact </span><span class="c29">learning</span><span>. Thus, we conclude our proof-of-concept machine learning phase, and move to our actual goal.</span></p><h4 class="c52" id="h.mr82aqcu7e5f"><span class="c4 c15 c23">Code</span></h4><h5 class="c59" id="h.gh185xtq3j72"><span class="c1">data.h + data.cpp</span></h5><p class="c17 c12"><span class="c1"></span></p><a id="t.1cc27e0f126fc7185c764b15e43a0a81a1d43254"></a><a id="t.25"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">stdint.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">stdio.h</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">class</span><span class="c1">&nbsp;data</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c5">private</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;uint8_t&gt; * feature_vector;</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * normalized_feature_vector;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* normalized_feature_array;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint32_t normalized_feature_array_size;</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">int</span><span class="c1">&gt; * class_vector;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;* class_array;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;class_array_size;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint8_t label;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint8_t enumerated_label;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;distance;</span></p><p class="c0"><span class="c5">public</span><span class="c1">:</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;set_distance(</span><span class="c5">double</span><span class="c1">&nbsp;distance);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;set_feature_vector(std::vector&lt;uint8_t&gt; * vect);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;set_normalized_feature_vector(std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * norm_vect);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;update_normalized_feature_array();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;set_class_vector(</span><span class="c5">int</span><span class="c1">&nbsp;counts);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;set_class_array(</span><span class="c5">int</span><span class="c1">&nbsp;counts);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;append_to_feature_vector(uint8_t val);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;append_to_feature_vector(</span><span class="c5">double</span><span class="c1">&nbsp;val);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;set_label(uint8_t label);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;set_enumerated_label(uint8_t label);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;get_distance();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;get_feature_vector_size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;get_feature_array_size();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint8_t get_label();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint8_t get_enumerated_label();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;uint8_t&gt; * get_feature_vector();</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * get_normalized_feature_vector();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* get_normalized_feature_array();</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">int</span><span class="c1">&gt; * get_class_vector();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;* get_class_array();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;get_class_array_size();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;c_only();</span></p><p class="c0"><span class="c1">};</span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">data.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span>&nbsp;data::set_distance(</span><span class="c5">double</span><span class="c1">&nbsp;distance) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;distance = distance;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data::set_feature_vector(std::vector&lt;uint8_t&gt; * vect) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;feature_vector = vect;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;data::set_normalized_feature_vector(std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * norm_vect) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;normalized_feature_vector = norm_vect;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span>&nbsp;data::set_class_vector(</span><span class="c5">int</span><span class="c1">&nbsp;counts) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span>-&gt;class_vector = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;</span><span class="c5">int</span><span class="c1">&gt;();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; counts; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(i == label)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">this</span><span>-&gt;class_vector-&gt;push_back(</span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">this</span><span>-&gt;class_vector-&gt;push_back(</span><span class="c7">0</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;data::set_class_array(</span><span class="c5">int</span><span class="c1">&nbsp;counts) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(class_array != NULL) { free(class_array); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;{ class_array = (</span><span class="c5">int</span><span>*)calloc(counts, </span><span class="c5">sizeof</span><span>(</span><span class="c5">int</span><span class="c1">)); }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span>&nbsp; &nbsp; class_array[label] = </span><span class="c7">1</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; class_array_size = counts;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data::append_to_feature_vector(uint8_t val) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; feature_vector-&gt;push_back(val);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;data::append_to_feature_vector(</span><span class="c5">double</span><span class="c1">&nbsp;val) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; normalized_feature_vector-&gt;push_back(val);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data::set_label(uint8_t label) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;label = label;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data::set_enumerated_label(uint8_t label) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;enumerated_label = label;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;data::get_distance() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">this</span><span class="c1">-&gt;distance;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;data::get_feature_vector_size() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;feature_vector-&gt;size();</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">uint8_t data::get_label() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">this</span><span class="c1">-&gt;label;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">uint8_t data::get_enumerated_label() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">this</span><span class="c1">-&gt;enumerated_label;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">std::vector&lt;uint8_t&gt; * data::get_feature_vector() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">this</span><span class="c1">-&gt;feature_vector;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span>std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * data::get_normalized_feature_vector() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">this</span><span class="c1">-&gt;normalized_feature_vector;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span>std::vector&lt;</span><span class="c5">int</span><span class="c1">&gt; * data::get_class_vector() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">this</span><span class="c1">-&gt;class_vector;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;* data::get_class_array() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">this</span><span class="c1">-&gt;class_array;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;* data::get_normalized_feature_array() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;normalized_feature_array;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data::update_normalized_feature_array() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(normalized_feature_array != NULL) { free(normalized_feature_array); }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; normalized_feature_array_size = normalized_feature_vector-&gt;size();</span></p><p class="c0"><span>&nbsp; &nbsp; normalized_feature_array = (</span><span class="c5">double</span><span>&nbsp;*)malloc(normalized_feature_array_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; normalized_feature_vector-&gt;size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; normalized_feature_array[i] = normalized_feature_vector-&gt;at(i);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;data::get_feature_array_size() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;normalized_feature_array_size;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;data::get_class_array_size() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;class_array_size;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data::c_only() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; update_normalized_feature_array();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(class_array != NULL) { free(class_array); }</span></p><p class="c0"><span>&nbsp; &nbsp; class_array = (</span><span class="c5">int</span><span>&nbsp;*)malloc(class_vector-&gt;size() * </span><span class="c5">sizeof</span><span>(</span><span class="c5">int</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; class_vector-&gt;size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; class_array[i] = class_vector-&gt;at(i);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;normalized_feature_vector;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;feature_vector;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;class_vector;</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h5 class="c59" id="h.1vsjm9qv6qjp"><span class="c1">data_handler.h + data_handler.cpp</span></h5><p class="c17 c12"><span class="c1"></span></p><a id="t.297924edee1d45500a62202d8a51d29d3bc9b29e"></a><a id="t.26"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">fstream</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">stdint.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">data.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">string</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">map</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">unordered_set</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">math.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">algorithm</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">random</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">class</span><span class="c1">&nbsp;data_handler</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c5">private</span><span class="c1">:</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;data *&gt; * data_vector; </span><span class="c6 c3">// all the data vectors</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;data *&gt; * training_data;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;data *&gt; * validation_data;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;data *&gt; * test_data;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;class_counts;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;feature_vector_size;</span></p><p class="c0"><span>&nbsp; &nbsp; std::map&lt;uint8_t, </span><span class="c5">int</span><span class="c1">&gt; class_from_int;</span></p><p class="c0"><span>&nbsp; &nbsp; std::map&lt;std::string, </span><span class="c5">int</span><span class="c1">&gt; class_from_string;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t max_data_vector_size = </span><span class="c7">60000</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">public</span><span class="c1">:</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">double</span><span>&nbsp;TRAIN_SET_PERCENT = </span><span class="c7">0.70</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">double</span><span>&nbsp;TEST_SET_PERCENT = </span><span class="c7">0.20</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">double</span><span>&nbsp;VALID_SET_PERCENT = </span><span class="c7">0.10</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; data_handler(); &nbsp; &nbsp; </span><span class="c6 c3">// ctor</span></p><p class="c0"><span>&nbsp; &nbsp; ~data_handler(); &nbsp; &nbsp;</span><span class="c6 c3">// dtor</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;read_input_data_file(std::string file_path);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;read_input_label_file(std::string file_path);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;split_data();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;count_classes();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;normalize_data();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;log();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;get_class_count();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;get_data_vector_size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;get_training_data_size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;get_test_data_size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;get_validation_data_size();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;data *&gt; * get_training_data();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;data *&gt; * get_validation_data();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;data *&gt; * get_test_data();</span></p><p class="c0"><span>&nbsp; &nbsp; std::map&lt;uint8_t, </span><span class="c5">int</span><span class="c1">&gt; get_class_map();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t format(</span><span class="c5">const</span><span>&nbsp;</span><span class="c5">unsigned</span><span>&nbsp;</span><span class="c5">char</span><span class="c1">* bytes);</span></p><p class="c0"><span class="c1">};</span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">data_handler.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">data_handler::data_handler() {</span></p><p class="c0"><span>&nbsp; &nbsp; data_vector = </span><span class="c5">new</span><span class="c1">&nbsp;std::vector&lt;data *&gt;;</span></p><p class="c0"><span>&nbsp; &nbsp; training_data = </span><span class="c5">new</span><span class="c1">&nbsp;std::vector&lt;data *&gt;;</span></p><p class="c0"><span>&nbsp; &nbsp; test_data = </span><span class="c5">new</span><span class="c1">&nbsp;std::vector&lt;data *&gt;;</span></p><p class="c0"><span>&nbsp; &nbsp; validation_data = </span><span class="c5">new</span><span class="c1">&nbsp;std::vector&lt;data *&gt;;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">data_handler::~data_handler() {</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data_handler::read_input_data_file(std::string file_path) {</span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t magic = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t num_images = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t num_rows = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t num_cols = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">unsigned</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;bytes[</span><span class="c7">4</span><span class="c1">];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE *f;</span></p><p class="c0"><span>&nbsp; &nbsp; errno_t err = fopen_s(&amp;f, file_path.c_str(), </span><span class="c14">&quot;rb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(f)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(i &lt; </span><span class="c7">4</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(fread(bytes, </span><span class="c5">sizeof</span><span>(bytes), </span><span class="c7">1</span><span class="c1">, f))</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">switch</span><span class="c1">&nbsp;(i)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">case</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magic = format(bytes);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">case</span><span>&nbsp;</span><span class="c7">1</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_images = format(bytes);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">case</span><span>&nbsp;</span><span class="c7">2</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_rows = format(bytes);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">case</span><span>&nbsp;</span><span class="c7">3</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_cols = format(bytes);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; num_images = std::min(num_images, max_data_vector_size);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Done getting input data file header.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint32_t image_size = num_rows * num_cols;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(i = </span><span class="c7">0</span><span class="c1">; i &lt; num_images; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data * d = </span><span class="c5">new</span><span class="c1">&nbsp;data();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d-&gt;set_feature_vector(</span><span class="c5">new</span><span class="c1">&nbsp;std::vector&lt;uint8_t&gt;());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t element[</span><span class="c7">1</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; image_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(fread(element, </span><span class="c5">sizeof</span><span>(element), </span><span class="c7">1</span><span class="c1">, f))</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d-&gt;append_to_feature_vector(element[</span><span class="c7">0</span><span class="c1">]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;data_vector-&gt;push_back(d);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d-&gt;set_class_vector(class_counts);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; normalize_data();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; feature_vector_size = data_vector-&gt;at(</span><span class="c7">0</span><span class="c1">)-&gt;get_feature_vector_size();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Successfully read %lu data entries.\n&quot;</span><span class="c1">, data_vector-&gt;size());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;The Feature Vector Size is: %d\n&quot;</span><span class="c1">, feature_vector_size);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Could not open or read input vectors file!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Now exiting...\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; exit(</span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data_handler::read_input_label_file(std::string file_path) {</span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t magic = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t num_images = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">unsigned</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;bytes[</span><span class="c7">4</span><span class="c1">];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE *f;</span></p><p class="c0"><span>&nbsp; &nbsp; errno_t err = fopen_s(&amp;f, file_path.c_str(), </span><span class="c14">&quot;rb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(f)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(i &lt; </span><span class="c7">2</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(fread(bytes, </span><span class="c5">sizeof</span><span>(bytes), </span><span class="c7">1</span><span class="c1">, f))</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">switch</span><span class="c1">&nbsp;(i)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">case</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; magic = format(bytes);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">case</span><span>&nbsp;</span><span class="c7">1</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_images = format(bytes);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Done getting Label header.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; num_images = std::min(num_images, max_data_vector_size);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">unsigned</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; num_images; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t element[</span><span class="c7">1</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(fread(element, </span><span class="c5">sizeof</span><span>(element), </span><span class="c7">1</span><span class="c1">, f))</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_vector-&gt;at(j)-&gt;set_label(element[</span><span class="c7">0</span><span class="c1">]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Successfully labeled %lu data entries.\n&quot;</span><span class="c1">, num_images);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Could not open or read input labels file!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Now exiting...\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; exit(</span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data_handler::split_data() {</span></p><p class="c0"><span>&nbsp; &nbsp; std::unordered_set&lt;</span><span class="c5">int</span><span class="c1">&gt; used_indexes;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;train_size = data_vector-&gt;size() * TRAIN_SET_PERCENT;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;validation_size = data_vector-&gt;size() * VALID_SET_PERCENT;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;test_size = data_vector-&gt;size() * TEST_SET_PERCENT;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::random_shuffle(data_vector-&gt;begin(), data_vector-&gt;end());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// Training Data</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;index = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(count &lt; train_size)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; training_data-&gt;push_back(data_vector-&gt;at(index++));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// Validation Data</span></p><p class="c0"><span>&nbsp; &nbsp; count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(count &lt; validation_size)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; validation_data-&gt;push_back(data_vector-&gt;at(index++));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// Test Data</span></p><p class="c0"><span>&nbsp; &nbsp; count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(count &lt; test_size)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; test_data-&gt;push_back(data_vector-&gt;at(index++));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Training Data Size: %lu.\n&quot;</span><span class="c1">, training_data-&gt;size());</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Validation Data Size: %lu.\n&quot;</span><span class="c1">, validation_data-&gt;size());</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Test Data Size: %lu.\n&quot;</span><span class="c1">, test_data-&gt;size());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(training_data-&gt;size() + validation_data-&gt;size() + test_data-&gt;size() != data_vector-&gt;size()) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint32_t amount_used = training_data-&gt;size() + validation_data-&gt;size() + test_data-&gt;size();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Only %.2f%% of vectors were used. %d were not sorted.\n&quot;</span><span>, </span><span class="c7">100.0</span><span class="c1">&nbsp;* amount_used / data_vector-&gt;size(), data_vector-&gt;size() - amount_used);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data_handler::count_classes() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">unsigned</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; data_vector-&gt;size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(class_from_int.find(data_vector-&gt;at(i)-&gt;get_label()) == class_from_int.end())</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class_from_int[data_vector-&gt;at(i)-&gt;get_label()] = count;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_vector-&gt;at(i)-&gt;set_enumerated_label(count);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_vector-&gt;at(i)-&gt;set_enumerated_label(class_from_int[data_vector-&gt;at(i)-&gt;get_label()]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; class_counts = count;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(data * data : *data_vector) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; data-&gt;set_class_vector(class_counts);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; data-&gt;set_class_array(class_counts);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Successfully Extracted %d Unique Classes.\n&quot;</span><span class="c1">, class_counts);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data_handler::normalize_data() {</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; mins, maxs;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// fill min and max lists</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; data * d = data_vector-&gt;at(</span><span class="c7">0</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(uint8_t val : *(d-&gt;get_feature_vector()))</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; mins.push_back(val);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; maxs.push_back(val);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">1</span><span class="c1">; i &lt; data_vector-&gt;size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; d = data_vector-&gt;at(i);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; d-&gt;get_feature_vector_size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;value = (</span><span class="c5">double</span><span class="c1">)d-&gt;get_feature_vector()-&gt;at(j);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(value &lt; mins.at(j)) mins[j] = value;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(value &gt; maxs.at(j)) maxs[j] = value;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// normalize data array</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; data_vector-&gt;size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; data_vector-&gt;at(i)-&gt;set_normalized_feature_vector(</span><span class="c5">new</span><span>&nbsp;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt;());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; data_vector-&gt;at(i)-&gt;set_class_vector(class_counts);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; data_vector-&gt;at(i)-&gt;get_feature_vector_size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// add normalized value to normalized_feature_vector</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(maxs[j] - mins[j] == </span><span class="c7">0</span><span class="c1">) </span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { data_vector-&gt;at(i)-&gt;append_to_feature_vector(</span><span class="c7">0.0</span><span class="c1">); }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_vector-&gt;at(i)-&gt;append_to_feature_vector((</span><span class="c5">double</span><span class="c1">)(data_vector-&gt;at(i)-&gt;get_feature_vector()-&gt;at(j) - mins[j]) / (maxs[j] - mins[j]));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;data_handler::log() {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;data_handler::get_class_count() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;class_counts;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;data_handler::get_data_vector_size() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;data_vector-&gt;size();</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;data_handler::get_training_data_size() { </span><span class="c5">return</span><span class="c1">&nbsp;training_data-&gt;size(); }</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;data_handler::get_test_data_size() { </span><span class="c5">return</span><span class="c1">&nbsp;test_data-&gt;size(); }</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;data_handler::get_validation_data_size() { </span><span class="c5">return</span><span class="c1">&nbsp;validation_data-&gt;size(); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>std::vector&lt;data *&gt; * data_handler::get_training_data() { </span><span class="c5">return</span><span class="c1">&nbsp;training_data; }</span></p><p class="c0"><span>std::vector&lt;data *&gt; * data_handler::get_validation_data() { </span><span class="c5">return</span><span class="c1">&nbsp;validation_data; }</span></p><p class="c0"><span>std::vector&lt;data *&gt; * data_handler::get_test_data() { </span><span class="c5">return</span><span class="c1">&nbsp;test_data; }</span></p><p class="c0"><span>std::map&lt;uint8_t, </span><span class="c5">int</span><span>&gt; data_handler::get_class_map() { </span><span class="c5">return</span><span class="c1">&nbsp;class_from_int; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>uint32_t data_handler::format(</span><span class="c5">const</span><span>&nbsp;</span><span class="c5">unsigned</span><span>&nbsp;</span><span class="c5">char</span><span class="c1">* bytes)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(uint32_t)((bytes[</span><span class="c7">0</span><span>] &lt;&lt; </span><span class="c7">24</span><span class="c1">) |</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; (bytes[</span><span class="c7">1</span><span>] &lt;&lt; </span><span class="c7">16</span><span class="c1">) |</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; (bytes[</span><span class="c7">2</span><span>] &lt;&lt; </span><span class="c7">8</span><span class="c1">) |</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; (bytes[</span><span class="c7">3</span><span class="c1">]));</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h5 class="c59" id="h.pmeee8ak5uo1"><span class="c1">common_data.h + common_data.cpp</span></h5><p class="c17 c12"><span class="c1"></span></p><a id="t.d094a85a62395fea5a3ec1541336d2efca3ee875"></a><a id="t.27"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">data.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">class</span><span class="c1">&nbsp;common_data</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c5">protected</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;data *&gt; * training_data;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;data *&gt; * validation_data;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;data *&gt; * test_data;</span></p><p class="c0"><span class="c5">public</span><span class="c1">:</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;set_training_data(std::vector&lt;data *&gt; * vect);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;set_validation_data(std::vector&lt;data *&gt; * vect);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;set_test_data(std::vector&lt;data *&gt; * vect);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;data *&gt; * get_validation_data();</span></p><p class="c0"><span class="c1">};</span></p><p class="c11 c12"><span class="c1"></span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">common_data.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;common_data::set_training_data(std::vector&lt;data *&gt; * vect) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; training_data = vect;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;common_data::set_validation_data(std::vector&lt;data *&gt; * vect) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; validation_data = vect;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;common_data::set_test_data(std::vector&lt;data *&gt; * vect) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; test_data = vect;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">std::vector&lt;data *&gt; * common_data::get_validation_data() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;validation_data;</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h5 class="c59" id="h.oky7k09rwrar"><span class="c1">neuron.h + neuron.cpp</span></h5><p class="c17 c12"><span class="c1"></span></p><a id="t.06ff8f837c28540d3e927a7aae8c8ba5876d43fa"></a><a id="t.28"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">stdio.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">cmath</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">random</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">time.h</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">class</span><span class="c1">&nbsp;neuron</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c5">public</span><span class="c1">:</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;output;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;delta;</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; weights;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* weights_array;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint32_t weights_array_size;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; neuron(</span><span class="c5">int</span><span>, </span><span class="c5">int</span><span>); </span><span class="c6 c3">// ctor</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;initialize_weights(</span><span class="c5">int</span><span>); </span><span class="c6 c3">// randomize weight values</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;activate(std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; inputs);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;activate(</span><span class="c5">int</span><span>&nbsp;inputs_size, </span><span class="c5">double</span><span>&nbsp;* inputs); </span><span class="c6 c3">// c</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;c_only();</span></p><p class="c0"><span class="c1">};</span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">neuron.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span>&nbsp;generateRandomNumber(</span><span class="c5">double</span><span>&nbsp;min, </span><span class="c5">double</span><span class="c1">&nbsp;max)</span></p><p class="c0"><span class="c1">{ &nbsp; </span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;random = (</span><span class="c5">double</span><span class="c1">)rand() / RAND_MAX;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;min + random * (max - min);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>neuron::neuron(</span><span class="c5">int</span><span>&nbsp;prev_layer_size, </span><span class="c5">int</span><span class="c1">&nbsp;curr_layer_size)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; initialize_weights(prev_layer_size);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;neuron::initialize_weights(</span><span class="c5">int</span><span class="c1">&nbsp;prev_layer_size)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; prev_layer_size + </span><span class="c7">1</span><span class="c1">; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; weights.push_back(generateRandomNumber(-</span><span class="c7">1.0</span><span>, </span><span class="c7">1.0</span><span class="c1">));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span>&nbsp;neuron::activate(std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; inputs) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;activation = weights.back(); </span><span class="c6 c3">// bias</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; weights.size() - </span><span class="c7">1</span><span class="c1">; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; activation += weights[i] * inputs[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;activation;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">double</span><span>&nbsp;neuron::activate(</span><span class="c5">int</span><span>&nbsp;input_size, </span><span class="c5">double</span><span class="c1">&nbsp;* inputs) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;activation = weights_array[input_size]; </span><span class="c6 c3">// bias</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; input_size; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; activation += weights_array[i] * inputs[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;activation;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;neuron::c_only() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(weights.size() &gt; </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; weights_array = (</span><span class="c5">double</span><span>*)malloc(weights.size() * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; weights_array_size = weights.size();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; weights.size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weights_array[i] = weights.at(i);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; weights.clear();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h5 class="c59" id="h.ubsi1zc54qk2"><span class="c1">layer.h + layer.cpp</span></h5><p class="c17 c12"><span class="c1"></span></p><a id="t.778eb339055dabff4231567e1715d7a662d150a9"></a><a id="t.29"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">neuron.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">stdint.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">class</span><span class="c1">&nbsp;layer</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c5">public</span><span class="c1">:</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;current_layer_size;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;neuron *&gt; neurons;</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; layer_outputs;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; neuron ** neurons_array;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;neurons_size;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* layer_outputs_array;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; layer(</span><span class="c5">int</span><span>&nbsp;prev_layer_size, </span><span class="c5">int</span><span>&nbsp;curr_layer_size); </span><span class="c6 c3">// ctor</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;c_only();</span></p><p class="c0"><span class="c1">};</span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">layer.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>layer::layer(</span><span class="c5">int</span><span>&nbsp;prev_layer_size, </span><span class="c5">int</span><span class="c1">&nbsp;curr_layer_size)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; curr_layer_size; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; neurons.push_back(</span><span class="c5">new</span><span class="c1">&nbsp;neuron(prev_layer_size, curr_layer_size));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;current_layer_size = curr_layer_size;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;layer::c_only() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; neurons_size = neurons.size();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; neurons_array = (neuron**)malloc(neurons_size * </span><span class="c5">sizeof</span><span class="c1">(neuron*));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; neurons_size; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; neurons_array[i] = neurons.at(i);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; neurons_array[i]-&gt;c_only();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; layer_outputs_array = (</span><span class="c5">double</span><span>&nbsp;*)malloc(neurons_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; neurons.clear();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; layer_outputs.clear();</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h5 class="c59" id="h.g541qnwrwqsn"><span class="c1">network.h + network.cpp</span></h5><p class="c17 c12"><span class="c1"></span></p><a id="t.d2357ee16b3735902b846ad91af23cba6d8aaaf4"></a><a id="t.30"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">data.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">neuron.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">layer.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">common_data.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">data_handler.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">numeric</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">algorithm</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">thread</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">class</span><span>&nbsp;network : </span><span class="c5">public</span><span class="c1">&nbsp;common_data</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c5">public</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;layer *&gt; layers;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; layer ** layers_array;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;layers_size;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;learning_rate;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;test_performance;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; network(std::vector&lt;</span><span class="c5">int</span><span>&gt; hidden_layers_specification, </span><span class="c5">int</span><span>, </span><span class="c5">int</span><span>, </span><span class="c5">double</span><span>); </span><span class="c6 c3">// ctor</span></p><p class="c0"><span>&nbsp; &nbsp; ~network(); </span><span class="c6 c3">// dtor</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;c_only();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span>&gt; fprop(data * d); </span><span class="c6 c3">// forward propagation</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;bprop(std::vector&lt;</span><span class="c5">double</span><span>&gt; deriv_errors); </span><span class="c6 c3">// back propagation</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;update_weights(data * data); </span><span class="c6 c3">// update weights after bprop</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;fprop_c(data * d, </span><span class="c5">double</span><span>&nbsp;** output); </span><span class="c6 c3">// forward propagation - c | returns class count</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;bprop_c(</span><span class="c5">double</span><span>&nbsp;* deriv_errors); </span><span class="c6 c3">// back propagation - c</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;update_weights_c(data * data); </span><span class="c6 c3">// update weights after bprop - c</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;train(); </span><span class="c6 c3">// returns error</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;validate(); </span><span class="c6 c3">// return percentage correct</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;test(); </span><span class="c6 c3">// return percentage correct</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;train_c(); </span><span class="c6 c3">// returns error - c</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;validate_c(); </span><span class="c6 c3">// return percentage correct - c</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;test_c(); </span><span class="c6 c3">// return percentage correct - c</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;transfer_activation(</span><span class="c5">double</span><span class="c1">&nbsp;activat);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;predict(data * data);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;predict_c(data * data);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">};</span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">network.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>network::network(std::vector&lt;</span><span class="c5">int</span><span>&gt; hidden_layers_specification, </span><span class="c5">int</span><span>&nbsp;input_size, </span><span class="c5">int</span><span>&nbsp;number_of_classes, </span><span class="c5">double</span><span class="c1">&nbsp;learning_rate) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; hidden_layers_specification.size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i == </span><span class="c7">0</span><span class="c1">)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; layers.push_back(</span><span class="c5">new</span><span class="c1">&nbsp;layer(input_size, hidden_layers_specification.at(i)));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; layers.push_back(</span><span class="c5">new</span><span>&nbsp;layer(layers.at(i - </span><span class="c7">1</span><span class="c1">)-&gt;neurons.size(), hidden_layers_specification.at(i)));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; layers.push_back(</span><span class="c5">new</span><span>&nbsp;layer(layers.at(layers.size() - </span><span class="c7">1</span><span class="c1">)-&gt;neurons.size(), number_of_classes));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;learning_rate = learning_rate;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">network::~network() {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span>std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; network::fprop(data * d) {</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; inputs = *d-&gt;get_normalized_feature_vector();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers.size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; layer * l = layers.at(i);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; new_inputs;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;neuron_index = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(neuron * n : l-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;activation = n-&gt;activate(inputs);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;output = </span><span class="c5">this</span><span class="c1">-&gt;transfer_activation(activation);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_inputs.push_back(n-&gt;output);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; l-&gt;layer_outputs = new_inputs;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; inputs = new_inputs;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;inputs; </span><span class="c6 c3">// output layer outputs</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;network::fprop_c(data * d, </span><span class="c5">double</span><span>&nbsp;** output) { </span><span class="c6 c3">// fprop with only c</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;inputs_size = d-&gt;get_feature_array_size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;* inputs = (</span><span class="c5">double</span><span>*)malloc(inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(inputs, d-&gt;get_normalized_feature_array(), inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;layer_index = </span><span class="c7">0</span><span class="c1">; layer_index &lt; layers_size; layer_index++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; layer * l = (layers_array[layer_index]);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;* new_inputs = (</span><span class="c5">double</span><span>&nbsp;*)malloc(l-&gt;neurons_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;neuron_index = </span><span class="c7">0</span><span class="c1">; neuron_index &lt; l-&gt;neurons_size; neuron_index++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neuron * n = (l-&gt;neurons_array[neuron_index]);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;activation = n-&gt;activate(inputs_size, inputs);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;output = </span><span class="c5">this</span><span class="c1">-&gt;transfer_activation(activation);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_inputs[neuron_index] = n-&gt;output;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; inputs_size = l-&gt;neurons_size;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(l-&gt;layer_outputs_array, new_inputs, inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; inputs = (</span><span class="c5">double</span><span>&nbsp;*)realloc(inputs, inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(inputs, new_inputs, inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; free(new_inputs);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; *output = (</span><span class="c5">double</span><span>&nbsp;*)malloc(inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(*output, inputs, inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(inputs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;inputs_size;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span>&nbsp;network::bprop(std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; deriv_errors) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = layers.size() - </span><span class="c7">1</span><span>; i &gt;= </span><span class="c7">0</span><span class="c1">; i--)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; layer * l = layers.at(i);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; errors;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i != layers.size() - </span><span class="c7">1</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; l-&gt;neurons.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(neuron *n : layers.at(i + </span><span class="c7">1</span><span class="c1">)-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error += (n-&gt;weights.at(j) * n-&gt;delta);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors.push_back(error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// If is last layer (i == layers.size()-1)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors = deriv_errors;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; l-&gt;neurons.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neuron * n = l-&gt;neurons.at(j);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;delta = errors[j];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;network::bprop_c(</span><span class="c5">double</span><span class="c1">&nbsp;* deriv_errors) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* errors;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = layers_size - </span><span class="c7">1</span><span>; i &gt;= </span><span class="c7">0</span><span class="c1">; i--)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; layer * l = (layers_array[i]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i != layers_size - </span><span class="c7">1</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors = (</span><span class="c5">double</span><span>&nbsp;*)malloc(l-&gt;neurons_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; l-&gt;neurons_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// for each neuron in current layer.</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;k = </span><span class="c7">0</span><span>; k &lt; layers_array[i + </span><span class="c7">1</span><span class="c1">]-&gt;neurons_size; k++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// for each neuron in next layer</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neuron * n = (layers_array[i + </span><span class="c7">1</span><span class="c1">]-&gt;neurons_array[k]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error += (n-&gt;weights_array[j] * n-&gt;delta);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors[j] = error;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// If is last layer (i == layers.size()-1)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors = deriv_errors;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; l-&gt;neurons_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neuron * n = (l-&gt;neurons_array[j]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;delta = errors[j];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(deriv_errors != errors) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(errors);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;network::update_weights(data * d) {</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; inputs = * d-&gt;get_normalized_feature_vector();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers.size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i != </span><span class="c7">0</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(neuron *n : layers.at(i - </span><span class="c7">1</span><span class="c1">)-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputs.push_back(n-&gt;output);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(neuron *n : layers.at(i)-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; inputs.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;weights.at(j) += </span><span class="c5">this</span><span class="c1">-&gt;learning_rate * n-&gt;delta * inputs.at(j);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;weights.back() += </span><span class="c5">this</span><span class="c1">-&gt;learning_rate * n-&gt;delta;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; inputs.clear();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;network::update_weights_c(data * d) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;inputs_size = d-&gt;get_feature_array_size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;* inputs = (</span><span class="c5">double</span><span>&nbsp;*)malloc(inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(inputs, d-&gt;get_normalized_feature_array(), inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers_size; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i != </span><span class="c7">0</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputs_size = layers_array[i - </span><span class="c7">1</span><span class="c1">]-&gt;neurons_size;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputs = (</span><span class="c5">double</span><span>&nbsp;*)realloc(inputs, inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span>; j &lt; layers_array[i - </span><span class="c7">1</span><span class="c1">]-&gt;neurons_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neuron * n = (layers_array[i-</span><span class="c7">1</span><span class="c1">]-&gt;neurons_array[j]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputs[i] = n-&gt;output;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; layers_array[i]-&gt;neurons_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neuron * n = (layers_array[i]-&gt;neurons_array[j]);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;k = </span><span class="c7">0</span><span class="c1">; k &lt; inputs_size; k++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;weights_array[k] += </span><span class="c5">this</span><span class="c1">-&gt;learning_rate * n-&gt;delta * inputs[k];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;weights_array[inputs_size] += </span><span class="c5">this</span><span class="c1">-&gt;learning_rate * n-&gt;delta;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(inputs);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;network::train() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;sum_error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; deriv_error;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;output_vector_size = </span><span class="c5">this</span><span>-&gt;training_data-&gt;at(</span><span class="c7">0</span><span class="c1">)-&gt;get_class_vector()-&gt;size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; output_vector_size; i++) { deriv_error.push_back(</span><span class="c7">0.0</span><span class="c1">); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(data * d : *</span><span class="c5">this</span><span class="c1">-&gt;training_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; outputs = fprop(d);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">int</span><span class="c1">&gt; expected = *(d-&gt;get_class_vector());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;tmp_sum_error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; outputs.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_sum_error += pow((</span><span class="c5">double</span><span>)expected.at(j) - outputs.at(j), </span><span class="c7">2</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] += (</span><span class="c5">double</span><span class="c1">)expected.at(j) - outputs.at(j);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; sum_error += tmp_sum_error;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error.at(j) /= </span><span class="c5">this</span><span class="c1">-&gt;training_data-&gt;size();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error.at(j) *= </span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; bprop(deriv_error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; update_weights(d);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error.at(j) = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;sum_error;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;network::validate() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;num_correct = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;count = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(data * d : *</span><span class="c5">this</span><span class="c1">-&gt;validation_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = predict(d);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(d-&gt;get_class_vector()-&gt;at(index) == </span><span class="c7">1</span><span class="c1">) { num_correct++; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;num_correct / count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;network::test() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;num_correct = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;count = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(data * d : *</span><span class="c5">this</span><span class="c1">-&gt;test_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = predict(d);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(d-&gt;get_class_vector()-&gt;at(index) == </span><span class="c7">1</span><span class="c1">) { num_correct++; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;num_correct / count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;network::train_c() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;sum_error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;output_vector_size = </span><span class="c5">this</span><span>-&gt;training_data-&gt;at(</span><span class="c7">0</span><span class="c1">)-&gt;get_class_array_size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;* deriv_error = (</span><span class="c5">double</span><span>&nbsp;*)calloc(output_vector_size, </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(data * d : *</span><span class="c5">this</span><span class="c1">-&gt;training_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* outputs;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fprop_c(d, &amp;outputs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;* expected = d-&gt;get_class_array();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;tmp_sum_error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;exp = (</span><span class="c5">double</span><span class="c1">)expected[j];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;out = outputs[j];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_sum_error += pow(exp - out, </span><span class="c7">2</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] += exp - out;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; sum_error += tmp_sum_error;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] /= </span><span class="c5">this</span><span class="c1">-&gt;training_data-&gt;size();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] *= </span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; bprop_c(deriv_error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; update_weights_c(d);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; free(outputs);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(deriv_error);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;sum_error;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;network::validate_c() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;num_correct = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;count = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(data * d : *</span><span class="c5">this</span><span class="c1">-&gt;validation_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = predict_c(d);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(d-&gt;get_class_array()[index] == </span><span class="c7">1</span><span class="c1">) { num_correct++; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;num_correct / count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;network::test_c() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;num_correct = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;count = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(data * d : *</span><span class="c5">this</span><span class="c1">-&gt;test_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = predict_c(d);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(d-&gt;get_class_array()[index] == </span><span class="c7">1</span><span class="c1">) { num_correct++; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;num_correct / count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span>&nbsp;network::transfer_activation(</span><span class="c5">double</span><span class="c1">&nbsp;activat) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">1.0</span><span>&nbsp;/ (</span><span class="c7">1.0</span><span class="c1">&nbsp;+ exp(-activat));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;network::predict(data * data) {</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; outputs = fprop(data);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;std::distance(outputs.begin(), std::max_element(outputs.begin(), outputs.end()));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;network::predict_c(data * data) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* outputs;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;class_count = fprop_c(data, &amp;outputs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;max_ind = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;max = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = class_count - </span><span class="c7">1</span><span>; i &gt;= </span><span class="c7">0</span><span class="c1">; i--) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(outputs[i] &gt; max) { max_ind = i; max = outputs[i]; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(outputs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;max_ind;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;network::c_only() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; layers_size = layers.size();</span></p><p class="c0"><span>&nbsp; &nbsp; layers_array = (layer **)malloc(layers_size * </span><span class="c5">sizeof</span><span class="c1">(layer *));</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers_size; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; layers_array[i] = (layers.at(i));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; layers.clear();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; training_data-&gt;size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; training_data-&gt;at(i)-&gt;c_only();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; validation_data-&gt;size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; validation_data-&gt;at(i)-&gt;c_only();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; test_data-&gt;size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; test_data-&gt;at(i)-&gt;c_only();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers_size; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; layer * l = layers_array[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; l-&gt;c_only();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Network is now C only!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h5 class="c59" id="h.er37jyz7h1mk"><span class="c1">main.cpp</span></h5><p class="c17 c12"><span class="c1"></span></p><a id="t.3454361b927ffaa5dbce0405e8721d46c5d11f66"></a><a id="t.31"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">iostream</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">network.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">chrono</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">utility</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">typedef</span><span class="c1">&nbsp;std::chrono::high_resolution_clock::time_point TimeVar;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#define</span><span class="c1">&nbsp;duration(a) std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(a).count()</span></p><p class="c0"><span class="c5">#define</span><span class="c1">&nbsp;timeNow() std::chrono::high_resolution_clock::now()</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;main()</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; srand(time(NULL));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; data_handler * _data_handler = </span><span class="c5">new</span><span class="c1">&nbsp;data_handler();</span></p><p class="c0"><span>&nbsp; &nbsp; _data_handler-&gt;read_input_data_file(</span><span class="c14">&quot;C:\\Users\\stein\\Desktop\\Research Project 2020\\Neural Networks\\MNIST\\Training Data\\train-images.idx3-ubyte&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; _data_handler-&gt;read_input_label_file(</span><span class="c14">&quot;C:\\Users\\stein\\Desktop\\Research Project 2020\\Neural Networks\\MNIST\\Training Data\\train-labels.idx1-ubyte&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; _data_handler-&gt;count_classes();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; _data_handler-&gt;split_data();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">int</span><span>&gt; hidden_layers = { </span><span class="c7">10</span><span>,</span><span class="c7">10</span><span class="c1">&nbsp;};</span></p><p class="c0"><span>&nbsp; &nbsp; network * netw = </span><span class="c5">new</span><span class="c1">&nbsp;network(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; hidden_layers,</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; _data_handler-&gt;get_training_data()-&gt;at(</span><span class="c7">0</span><span class="c1">)-&gt;get_feature_vector_size(),</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; _data_handler-&gt;get_class_count(),</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">0.25</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; netw-&gt;set_training_data(_data_handler-&gt;get_training_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; netw-&gt;set_validation_data(_data_handler-&gt;get_validation_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; netw-&gt;set_test_data(_data_handler-&gt;get_test_data());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Initial Validation: \n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Validation performance: %.4f%%\n&quot;</span><span>, </span><span class="c7">100.0</span><span class="c1">&nbsp;* netw-&gt;validate());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; netw-&gt;c_only();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Initial Validation - C: \n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Validation performance: %.4f%%\n&quot;</span><span>, </span><span class="c7">100.0</span><span class="c1">&nbsp;* netw-&gt;validate_c());</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Now training...\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; </span><span class="c7">100000</span><span class="c1">; i++) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; TimeVar t1 = timeNow();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Training error @ iteration %d: %.4f\n&quot;</span><span class="c1">, i, netw-&gt;train_c());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;train_time = duration(timeNow() - t1);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Training time: %.2f nanoseconds\n&quot;</span><span class="c1">, train_time);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i % </span><span class="c7">5</span><span>&nbsp;== </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeVar t2 = timeNow();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Validation performance: %.4f%%\n&quot;</span><span>, </span><span class="c7">100.0</span><span class="c1">&nbsp;* netw-&gt;validate_c());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;validate_time = duration(timeNow() - t2);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Validating time: %.2f nanoseconds\n&quot;</span><span class="c1">, validate_time);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i % </span><span class="c7">25</span><span>&nbsp;== </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Test Performance: %.4f%%\n&quot;</span><span>, </span><span class="c7">100.0</span><span class="c1">&nbsp;* netw-&gt;test_c());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Test Performance: %.4f%%\n&quot;</span><span>, </span><span class="c7">100.0</span><span class="c1">&nbsp;* netw-&gt;test_c());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><p class="c17 c12 c46 c78"><span class="c1"></span></p><hr style="page-break-before:always;display:none;"><h1 class="c36 c79" id="h.xczgbhj0hiok"><span class="c4 c15 c56"></span></h1><h1 class="c36" id="h.idlcnp4e5ye6"><span class="c4 c15 c56">FFT - Fast Fourier Transform</span></h1><p class="c17 c46"><span class="c16">&nbsp;Fast Fourier Transform is a fast algorithm to calculate the Discrete Fourier Transform of a complex set. FFT improves DFT, as it reduces the time complexity from O(N</span><span>&sup2;</span><span class="c1">) to O(N log(N)).</span></p><h2 class="c46 c54" id="h.bsnz3inlejru"><span class="c4 c15 c32">DFT - Discrete Fourier Transform</span></h2><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DFT transforms a finite sequence of equally-spaced samples of a function into a same-length sequence of equally spaced samples of the discrete-time Fourier Transform. DFT can be used to calculate the coefficients of the complex sinusoids which built the input.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DFT can be regarded as transforming a functions&rsquo; time/space domain into a frequency domain.</span></p><p class="c17"><span class="c16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Discrete Fourier Transform of </span><img src="images/image3.png"><span class="c16">&nbsp;to </span><img src="images/image4.png"><span class="c1">is defined by: </span></p><p class="c17"><span class="c16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><img src="images/image5.png"><span class="c4 c15 c56">&nbsp;</span></p><p class="c17"><span class="c1">and following Euler&rsquo;s formula:</span></p><p class="c17"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><img src="images/image6.png"></p><p class="c17"><span class="c1">We will be using FFT to transform audio data into a fixed size array of the relative amplitudes on each frequency from 1 to 4000. The input we will be giving the FFT function is the time-amplitude coordinates of an audio wave, and it will return an array with the amplitudes of the frequencies. A simple example of a fourier transform:</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 354.00px;"><img alt="" src="images/image8.png" style="width: 601.70px; height: 354.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17 c46"><span class="c1">We will be using the classic Cooley-Tukey FFT algorithm. The Cooley-Tukey algorithm recursively breaks down a Discrete Fourier Transform into Discrete Fourier Transforms of smaller sizes, a divide-and-conquer approach. The divide-and-conquer algorithmic approach is a design paradigm which recursively breaks down a problem into multiple subproblems of a similar type until these subproblems are elementary enough to be directly solved. The solutions to the subproblems are then combined to solve the original problem.</span></p><p class="c17 c46"><span class="c1">The method used here is to divide the Discrete Transform into two sets of size N/2 (N being the size of the input set at each recursive calling) each time. Each calling then combines, by summation, the results into the passed array.</span></p><p class="c17 c12 c46"><span class="c1"></span></p><p class="c17 c46"><span class="c1">The code we will use to perform this Cooley-Tukey Fast Fourier Transform is:</span></p><a id="t.4d1c3a7637379036309a937366bf0d4661543a9e"></a><a id="t.32"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;fft(CArray&amp; x) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">const</span><span class="c1">&nbsp;size_t N = x.size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(N &lt;= </span><span class="c7">1</span><span>) </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// divide</span></p><p class="c0"><span>&nbsp; &nbsp; CArray even = x[std::slice(</span><span class="c7">0</span><span>, N/</span><span class="c7">2</span><span>, </span><span class="c7">2</span><span class="c1">)];</span></p><p class="c0"><span>&nbsp; &nbsp; CArray &nbsp;odd = x[std::slice(</span><span class="c7">1</span><span>, N/</span><span class="c7">2</span><span>, </span><span class="c7">2</span><span class="c1">)];</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// conquer</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fft(even);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fft(odd);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// combine</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(size_t k = </span><span class="c7">0</span><span>; k &lt; N/</span><span class="c7">2</span><span class="c1">; ++k)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; Complex t = std::polar(</span><span class="c7">1.0</span><span>, -</span><span class="c7">2</span><span class="c1">&nbsp;* PI * k / N) * odd[k];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; x[k &nbsp; &nbsp;] = even[k] + t;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; x[k+N/</span><span class="c7">2</span><span class="c1">] = even[k] - t;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12 c46"><span class="c1"></span></p><p class="c17 c46"><span class="c1">And in order to alleviate the tension on the rest of the code, we built a wrapper class for the Fast Fourier Transform which will take care of all the processing.</span></p><p class="c17 c12 c46"><span class="c1"></span></p><h2 class="c54" id="h.lyt2xx7z5s4f"><span class="c4 c15 c32">Code - FFT.h + FFT.cpp:</span></h2><p class="c17"><span class="c1">FFT.h</span></p><p class="c17 c12"><span class="c1"></span></p><a id="t.6f71a89f60cb01a19e1473d64b08fd7cd975b6f6"></a><a id="t.33"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#ifndef</span><span class="c1">&nbsp;FFT_H</span></p><p class="c0"><span class="c5">#define</span><span class="c1">&nbsp;FFT_H</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">complex</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">iostream</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">valarray</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">float.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">algorithm</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">typedef</span><span>&nbsp;std::complex&lt;</span><span class="c5">double</span><span class="c1">&gt; Complex;</span></p><p class="c0"><span class="c5">typedef</span><span class="c1">&nbsp;std::valarray&lt;Complex&gt; CArray;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">class</span><span class="c1">&nbsp;FFT</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">public</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FFT();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">virtual</span><span class="c1">&nbsp;~FFT();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;LoadWave(</span><span class="c5">double</span><span class="c1">[]);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;AppendToWave(</span><span class="c5">double</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;Complex&gt; * FourierTransfer(uint32_t samplingRate); </span><span class="c6 c3">/// Returns the frequency outputs for an entire</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;Complex&gt; * FourierTransfer_Part(uint32_t samplintRate, uint32_t index);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">double</span><span>&nbsp;PI = </span><span class="c7">3.141592653589793238460</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Complex * getOriginalWave();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;getOriginalWaveSize();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Complex * getFrequencyOutput();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * ActualValues;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;Complex&gt; * FrequencyOutput;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * &gt; * splitValues;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span>&gt; * getNormalizedFrequency(); </span><span class="c6 c3">// Frequencies ranged from 0 to 255. Relative to Frequency output, obviously.</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * &gt; * OrderFrequencyOutputs(std::vector&lt;Complex&gt; * freqOut);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;peakHigh;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;peakLow;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;range;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt;&gt; * peaks;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt;&gt; * NormalizedPeaks;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;getK() { </span><span class="c5">return</span><span class="c1">&nbsp;k; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint32_t MaxFrequency(); </span><span class="c6 c3">// The highest frequency to check.</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">protected</span><span class="c1">:</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">private</span><span class="c1">:</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;fft(CArray&amp; x);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;inverse_fft(CArray&amp; x);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;SplitValues();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;ReloadArrays();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;k = </span><span class="c7">25</span><span>; </span><span class="c6 c3">// Amount of peaks to keep track of</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint32_t FrequencyRange = </span><span class="c7">4096</span><span>; </span><span class="c6 c3">// The highest frequency to check. (To speed up processing)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint32_t SamplingRate = </span><span class="c7">8000</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;ValidatePeak(</span><span class="c5">double</span><span>&nbsp;ind, </span><span class="c5">double</span><span class="c1">&nbsp;p);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;ValidateNormalizedPeak(</span><span class="c5">double</span><span>&nbsp;ind, </span><span class="c5">double</span><span class="c1">&nbsp;p);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;ResetPeaks();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;ResetNormalizedPeaks();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#endif</span><span>&nbsp;</span><span class="c6 c3">// FFT_H</span></p><p class="c0 c12"><span class="c1"></span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span class="c1">FFT.cpp</span></p><p class="c17 c12"><span class="c1"></span></p><a id="t.abf451bc219955fe8ad228560802f10fa92b4959"></a><a id="t.34"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">FFT.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">FFT::FFT() &nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//ctor</span></p><p class="c0"><span>&nbsp; &nbsp; ActualValues = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt;();</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">FFT::~FFT() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//dtor</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;FFT::ResetPeaks() {</span></p><p class="c0"><span>&nbsp; &nbsp; peaks = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt;&gt;();</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span>&gt; demoPeak = std::vector&lt;</span><span class="c5">double</span><span>&gt;(); demoPeak.push_back(-</span><span class="c7">1.0</span><span class="c1">); demoPeak.push_back(-DBL_MAX);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; k; i++) { peaks-&gt;push_back(demoPeak); }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;FFT::ResetNormalizedPeaks() {</span></p><p class="c0"><span>&nbsp; &nbsp; NormalizedPeaks = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt;&gt;();</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span>&gt; demoPeak2 = std::vector&lt;</span><span class="c5">double</span><span>&gt;(); demoPeak2.push_back(-</span><span class="c7">1.0</span><span class="c1">); demoPeak2.push_back(-DBL_MAX);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; k; i++) { NormalizedPeaks-&gt;push_back(demoPeak2); }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;FFT::fft(CArray&amp; x) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">const</span><span class="c1">&nbsp;size_t N = x.size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(N &lt;= </span><span class="c7">1</span><span>) </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// divide</span></p><p class="c0"><span>&nbsp; &nbsp; CArray even = x[std::slice(</span><span class="c7">0</span><span>, N/</span><span class="c7">2</span><span>, </span><span class="c7">2</span><span class="c1">)];</span></p><p class="c0"><span>&nbsp; &nbsp; CArray &nbsp;odd = x[std::slice(</span><span class="c7">1</span><span>, N/</span><span class="c7">2</span><span>, </span><span class="c7">2</span><span class="c1">)];</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// conquer</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fft(even);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fft(odd);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// combine</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(size_t k = </span><span class="c7">0</span><span>; k &lt; N/</span><span class="c7">2</span><span class="c1">; ++k)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; Complex t = std::polar(</span><span class="c7">1.0</span><span>, -</span><span class="c7">2</span><span class="c1">&nbsp;* PI * k / N) * odd[k];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; x[k &nbsp; &nbsp;] = even[k] + t;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; x[k+N/</span><span class="c7">2</span><span class="c1">] = even[k] - t;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;FFT::inverse_fft(CArray&amp; x) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// conjugate the complex numbers</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; x = x.apply(std::conj);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// forward fft</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fft( x );</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// conjugate the complex numbers again</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; x = x.apply(std::conj);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// scale the numbers</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; x /= x.size();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;FFT::SplitValues() {</span></p><p class="c0"><span>&nbsp; &nbsp; splitValues = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; *&gt;();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;amtSplits = std::ceil(ActualValues-&gt;size() / SamplingRate);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; amtSplits; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span>&gt; * partSamps = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt;();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;x = </span><span class="c7">0</span><span class="c1">; x &lt; SamplingRate; x++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partSamps-&gt;push_back(ActualValues-&gt;at((i * SamplingRate) + x));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; splitValues-&gt;push_back(partSamps);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;FFT::LoadWave(</span><span class="c5">double</span><span class="c1">&nbsp;wave[]) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; </span><span class="c5">sizeof</span><span>(wave) / </span><span class="c5">sizeof</span><span>(wave[</span><span class="c7">0</span><span class="c1">]); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ActualValues-&gt;push_back(wave[i]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(ActualValues-&gt;size() == </span><span class="c5">sizeof</span><span>(wave) / </span><span class="c5">sizeof</span><span>(wave[</span><span class="c7">0</span><span class="c1">]));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;FFT::AppendToWave(</span><span class="c5">double</span><span class="c1">&nbsp;val) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ActualValues-&gt;push_back(val);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">std::vector&lt;Complex&gt; * FFT::FourierTransfer(uint32_t samplingRate) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; SamplingRate = samplingRate;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; SplitValues();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; FrequencyOutput = </span><span class="c5">new</span><span class="c1">&nbsp;std::vector&lt;Complex&gt;();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; samplingRate; i++) { FrequencyOutput-&gt;push_back(</span><span class="c7">0</span><span class="c1">); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;amtSplits = std::ceil(ActualValues-&gt;size() / SamplingRate);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;splitInd = </span><span class="c7">0</span><span class="c1">; splitInd &lt; amtSplits; splitInd++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * liveValues = splitValues-&gt;at(splitInd);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; Complex originalWave[</span><span class="c7">8000</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; liveValues-&gt;size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; originalWave[i] = liveValues-&gt;at(i);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; CArray data(originalWave, </span><span class="c5">sizeof</span><span>(originalWave) / </span><span class="c5">sizeof</span><span>(originalWave[</span><span class="c7">0</span><span class="c1">]));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FFT::fft(data);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;Complex&gt; * liveFrequencyOutput = </span><span class="c5">new</span><span class="c1">&nbsp;std::vector&lt;Complex&gt;();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;pHigh = data[</span><span class="c7">0</span><span class="c1">].real();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;pLow = data[</span><span class="c7">0</span><span class="c1">].real();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;pHighInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;pLowInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ResetNormalizedPeaks();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; MaxFrequency(); i++){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pHigh = std::max(pHigh, data[i].real());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(pHigh == data[i].real()) { pHighInd = i; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pLow = std::min(pLow, data[i].real());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(pLow == data[i].real()) { pLowInd = i; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; liveFrequencyOutput-&gt;push_back(data[i]);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ValidatePeak((</span><span class="c5">double</span><span class="c1">)(i), data[i].real());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FrequencyOutput-&gt;at(i) = FrequencyOutput-&gt;at(i) + data[i].real();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; peakHigh = pHigh;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; peakLow = pLow;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; range = pHigh - pLow;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;Sample #&quot;</span><span>&nbsp;&lt;&lt; splitInd &lt;&lt; </span><span class="c14">&quot;: {&quot;</span><span>&nbsp;&lt;&lt; pHighInd &lt;&lt; </span><span class="c14">&quot;, &quot;</span><span>&nbsp;&lt;&lt; peakHigh &lt;&lt; </span><span class="c14">&quot;}, {&quot;</span><span>&nbsp;&lt;&lt; pLowInd &lt;&lt; </span><span class="c14">&quot;, &quot;</span><span>&nbsp;&lt;&lt; peakLow &lt;&lt; </span><span class="c14">&quot;}&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; SamplingRate; i++) { FrequencyOutput-&gt;at(i) = (</span><span class="c5">double</span><span>)FrequencyOutput-&gt;at(i).real() / (</span><span class="c5">double</span><span class="c1">)amtSplits; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;FrequencyOutput;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">std::vector&lt;Complex&gt; * FFT::FourierTransfer_Part(uint32_t samplingRate, uint32_t index) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; SamplingRate = samplingRate;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; Complex originalWave[</span><span class="c7">8000</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; SamplingRate; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; originalWave[i] = ActualValues-&gt;at((index * SamplingRate) + i);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; CArray data(originalWave, </span><span class="c5">sizeof</span><span>(originalWave) / </span><span class="c5">sizeof</span><span>(originalWave[</span><span class="c7">0</span><span class="c1">]));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FFT::fft(data);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;Complex&gt; * liveFrequencyOutput = </span><span class="c5">new</span><span class="c1">&nbsp;std::vector&lt;Complex&gt;();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;pHigh = std::abs(data[</span><span class="c7">0</span><span class="c1">].real());</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;pLow = std::abs(data[</span><span class="c7">0</span><span class="c1">].real());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;pHighInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;pLowInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; MaxFrequency(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; data[i] = std::abs(data[i].real());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pHigh = std::max(pHigh, data[i].real());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(pHigh == data[i].real()) { pHighInd = i; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pLow = std::min(pLow, data[i].real());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(pLow == data[i].real()) { pLowInd = i; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; MaxFrequency(); i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; liveFrequencyOutput-&gt;push_back(((</span><span class="c7">255.0</span><span>&nbsp;* (data[i] - pLow)) / (pHigh - pLow))); &nbsp; &nbsp;</span><span class="c6 c3">// Normalize the frequency amplitudes (convert arbitrary values to 0-255)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;Sample #&quot;</span><span>&nbsp;&lt;&lt; index &lt;&lt; </span><span class="c14">&quot;: {&quot;</span><span>&nbsp;&lt;&lt; pHighInd &lt;&lt; </span><span class="c14">&quot;, &quot;</span><span>&nbsp;&lt;&lt; pHigh &lt;&lt; </span><span class="c14">&quot;}, {&quot;</span><span>&nbsp;&lt;&lt; pLowInd &lt;&lt; </span><span class="c14">&quot;, &quot;</span><span>&nbsp;&lt;&lt; pLow &lt;&lt; </span><span class="c14">&quot;}&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;liveFrequencyOutput;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>std::vector&lt;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * &gt; * FFT::OrderFrequencyOutputs(std::vector&lt;Complex&gt; * freqOut) {</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;std::vector&lt;</span><span class="c5">double</span><span>&gt; * &gt; * ordFreqOut = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * &gt;();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span>&gt; * tmpV = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;</span><span class="c5">double</span><span>&gt;(); tmpV-&gt;push_back(</span><span class="c7">0</span><span>); tmpV-&gt;push_back(-</span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;( </span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; k; i++) { ordFreqOut-&gt;push_back(tmpV); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//uint32_t usedIndexs[freqOut-&gt;size()];</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(uint32_t ind = </span><span class="c7">0</span><span class="c1">; ind &lt; MaxFrequency(); ind++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; k; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;( freqOut-&gt;at(ind).real() &gt; ordFreqOut-&gt;at(i)-&gt;at(</span><span class="c7">1</span><span class="c1">) ) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// Move back the rest</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;ii = k-</span><span class="c7">1</span><span class="c1">; ii &gt; i; ii--){</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordFreqOut-&gt;at(ii) = ordFreqOut-&gt;at(ii-</span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span>&gt; * tV = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt;(); tV-&gt;push_back(ind); tV-&gt;push_back(freqOut-&gt;at(ind).real());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ordFreqOut-&gt;at(i) = tV;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;ordFreqOut;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; * FFT::getNormalizedFrequency() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// Absolute Value EVERYTHING</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span>&gt; * ABSFrequencyOutput = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt;();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;pHigh = -</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;pLow = -</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; MaxFrequency(); i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;NormalizedValue = std::abs(FrequencyOutput-&gt;at(i).real());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ABSFrequencyOutput-&gt;push_back(NormalizedValue);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pHigh = std::max(pHigh, NormalizedValue);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pLow = std::min(pLow, NormalizedValue);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span>&gt; * NormalizedFrequencies = </span><span class="c5">new</span><span>&nbsp;std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt;();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; MaxFrequency(); i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;NormalizedValue = ( ( </span><span class="c7">255.0</span><span class="c1">&nbsp;* ( ABSFrequencyOutput-&gt;at(i) - pLow ) ) / ( pHigh - pLow ) );</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; NormalizedFrequencies-&gt;push_back(NormalizedValue);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; ValidateNormalizedPeak((</span><span class="c5">double</span><span class="c1">)i, NormalizedValue);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;NormalizedFrequencies;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span>&nbsp;FFT::ValidatePeak(</span><span class="c5">double</span><span>&nbsp;ind, </span><span class="c5">double</span><span class="c1">&nbsp;p) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span>&nbsp;repl = </span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; k; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(p &gt; peaks-&gt;at(i).at(</span><span class="c7">1</span><span class="c1">) &amp;&amp; !repl) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;ii = k-</span><span class="c7">2</span><span class="c1">; ii &gt;= i; ii--) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peaks-&gt;at(ii + </span><span class="c7">1</span><span>).at(</span><span class="c7">0</span><span>) = peaks-&gt;at(ii).at(</span><span class="c7">0</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peaks-&gt;at(ii + </span><span class="c7">1</span><span>).at(</span><span class="c7">1</span><span>) = peaks-&gt;at(ii).at(</span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peaks-&gt;at(i).at(</span><span class="c7">0</span><span class="c1">) = ind;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; peaks-&gt;at(i).at(</span><span class="c7">1</span><span class="c1">) = p;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repl = </span><span class="c5">true</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span>&nbsp;FFT::ValidateNormalizedPeak(</span><span class="c5">double</span><span>&nbsp;ind, </span><span class="c5">double</span><span class="c1">&nbsp;p) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span>&nbsp;repl = </span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; k; i++) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; t1 = NormalizedPeaks-&gt;at(i);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;t2 = NormalizedPeaks-&gt;at(i).at(</span><span class="c7">0</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(p &gt; NormalizedPeaks-&gt;at(i).at(</span><span class="c7">1</span><span class="c1">) &amp;&amp; !repl) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;ii = k-</span><span class="c7">2</span><span class="c1">; ii &gt;= i; ii--) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NormalizedPeaks-&gt;at(ii + </span><span class="c7">1</span><span>).at(</span><span class="c7">0</span><span>) = NormalizedPeaks-&gt;at(ii).at(</span><span class="c7">0</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NormalizedPeaks-&gt;at(ii + </span><span class="c7">1</span><span>).at(</span><span class="c7">1</span><span>) = NormalizedPeaks-&gt;at(ii).at(</span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NormalizedPeaks-&gt;at(i).at(</span><span class="c7">0</span><span class="c1">) = ind;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NormalizedPeaks-&gt;at(i).at(</span><span class="c7">1</span><span class="c1">) = p;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; repl = </span><span class="c5">true</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">uint32_t FFT::MaxFrequency() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;std::min( FrequencyRange , SamplingRate/</span><span class="c7">2</span><span class="c1">&nbsp;);</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17"><span class="c16">Note: this class uses a static sampling rate of 8000Hz, and as such we will preprocess all our files to this sampling rate.</span><hr style="page-break-before:always;display:none;"></p><h1 class="c36" id="h.endqd0rjle1y"><span class="c4 c15 c56">Music Genre Classifier</span></h1><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Now to combine everything I researched into one product, I implemented a program which takes as input wav files of a few songs and their corresponding genres, and one wav file whose genre we want to predict, and outputs a guess of the genre of the prediction file.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The first thing we need is a dataset. So I wrote a small wrapper program which helps us create datasets on the fly, and test them.</span></p><h2 class="c54" id="h.kryixj2nhzc0"><span class="c4 c15 c32">CreateDataSet - Data Set Creator for Music Genre Classifier</span></h2><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateDataSet is a wrapper program for our actual classifier (ClassifyFrequencyArray.exe). CreateDataSet (CDS) allows us to create datasets, update existing datasets, preview them, and most importantly; test them.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDS works on a directory, wherein all necessary files are placed, including temporary prediction files. There are four file types used by CDS: &ldquo;vectors&rdquo;, &ldquo;labels&rdquo;, &ldquo;label_map&rdquo;, &ldquo;data_map&rdquo;.</span></p><ol class="c24 lst-kix_uqp80nmditom-0 start" start="1"><li class="c17 c73 li-bullet-0"><span class="c1">Vectors: A vectors file contains the actual data of a single or of multiple wav files. A vectors file has a header of three uint32_t in big endian: a magic number (2612), the sample count (how many vectors are in the file), and the vector size (currently 4,000).</span></li><li class="c17 c73 li-bullet-0"><span class="c1">Labels: A labels file contains the labels (uint8_t) corresponding to each vector in the vectors file. Label files begin with a two uint32_t header or a magic &nbsp;number (2211) and the sample count. The sample count written in the labels file and in the vectors file should be exactly the same. Notice that the labels and vectors files are codependent and must be written in the same order - the first label corresponds to the first vector, the second with the second, and so on. Therefore, they should be named the same (excluding the file extension) to keep track of which labels file corresponds to which vectors file.</span></li><li class="c17 c73 li-bullet-0"><span class="c1">Data Map: A data map file contains the file paths to the files already imported into the dataset. The data map file maps these file paths with the sound&rsquo;s label. This file is useful when adding multiple files into the dataset as it keeps track of which files are already in the dataset and what their labels are. The format is such (Notice there is no header): </span></li></ol><a id="t.c23972ad3b3c039bb1c21a0d7af209f3ddc624d3"></a><a id="t.35"></a><table class="c60"><tbody><tr class="c34"><td class="c72" colspan="1" rowspan="1"><p class="c11"><span class="c1">File Label (1 byte)</span></p></td><td class="c70" colspan="1" rowspan="1"><p class="c11"><span class="c1">File Path (As null terminated string [ASCII only])</span></p></td></tr><tr class="c34"><td class="c72" colspan="1" rowspan="1"><p class="c11"><span class="c1">...</span></p></td><td class="c70" colspan="1" rowspan="1"><p class="c11"><span class="c1">...</span></p></td></tr><tr class="c34"><td class="c72" colspan="1" rowspan="1"><p class="c11"><span class="c1">File Label (1 byte)</span></p></td><td class="c70" colspan="1" rowspan="1"><p class="c11"><span class="c1">File Path (As null terminated string [ASCII only])</span></p></td></tr></tbody></table><ol class="c24 lst-kix_uqp80nmditom-0" start="4"><li class="c17 c73 li-bullet-0"><span class="c1">Label Map: A label map file, similarly to a data map file, contains information to make the program more user-friendly. The label map file of a dataset contains a map of each label - as uint8_t - to a literal label - as a 255 character (maximum) string. This file is used when showing the classes, or after a prediction is made, to convert the uint8_t label into a human-legible and understandable string. Label map files also do not have a header.</span></li></ol><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span class="c1">We will also use CDS as a command-line tool to interface with the classifier (We will probably change this later, as this method wastes vast amounts of time loading and unloading data from files into memory).</span></p><p class="c17 c12"><span class="c1"></span></p><p class="c17"><span class="c1">Code:</span></p><p class="c17 c46"><span>Notice that although this is a C++ program, most of the code is in pure C as to increase performance (See </span><span class="c20"><a class="c8" href="#h.ihrlc1lrddvk">Evolvement - Practical Research</a></span><span class="c1">, where there is further explanation of the benefits of using C in C++).</span></p><h3 class="c39" id="h.jolwscus14lq"><span class="c4 c15 c18">CreateDataSet.cpp</span></h3><p class="c17 c12"><span class="c1"></span></p><a id="t.7c086677b5952301b04987a1a2e18fc553d5964e"></a><a id="t.36"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">iostream</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">sys/stat.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">time.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">map</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">AudioFile.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">FFT.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">direct.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#define</span><span class="c1">&nbsp;GetCurrentDir _getcwd</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#define</span><span>&nbsp;MaximumLabelLength </span><span class="c3 c15 c7">255</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">std::string get_current_dir() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;buff[FILENAME_MAX];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; GetCurrentDir(buff, FILENAME_MAX);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::string current_working_dir(buff);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;current_working_dir;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">inline</span><span>&nbsp;</span><span class="c5">bool</span><span>&nbsp;file_exists(</span><span class="c5">const</span><span class="c1">&nbsp;std::string&amp; name) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">struct</span><span class="c1">&nbsp;stat buffer;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(stat(name.c_str(), &amp;buffer) == </span><span class="c7">0</span><span class="c1">);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;getFileSize(FILE * f) { </span><span class="c6 c3">// This will move the file pointer to SEEK_SET + 0</span></p><p class="c0"><span>&nbsp; &nbsp; fseek(f, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;size = ftell(f);</span></p><p class="c0"><span>&nbsp; &nbsp; fseek(f, </span><span class="c7">0</span><span class="c1">, SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;size;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">uint32_t convert_to_big_endian(uint32_t b) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">unsigned</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;bytes[</span><span class="c7">4</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(bytes, &amp;b, </span><span class="c5">sizeof</span><span class="c1">(b));</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(uint32_t)((bytes[</span><span class="c7">0</span><span>] &lt;&lt; </span><span class="c7">24</span><span>) | (bytes[</span><span class="c7">1</span><span>] &lt;&lt; </span><span class="c7">16</span><span>) | (bytes[</span><span class="c7">2</span><span>] &lt;&lt; </span><span class="c7">8</span><span>) | (bytes[</span><span class="c7">3</span><span class="c1">]));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">uint32_t convert_to_little_endian(uint32_t b) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">unsigned</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;bytes[</span><span class="c7">4</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(bytes, &amp;b, </span><span class="c5">sizeof</span><span class="c1">(b));</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(uint32_t)((bytes[</span><span class="c7">0</span><span>] &lt;&lt; </span><span class="c7">24</span><span>) | (bytes[</span><span class="c7">1</span><span>] &lt;&lt; </span><span class="c7">16</span><span>) | (bytes[</span><span class="c7">2</span><span>] &lt;&lt; </span><span class="c7">8</span><span>) | (bytes[</span><span class="c7">3</span><span class="c1">]));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Change the last character of a string into a null byte (if it&#39;s a newline).</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;fix_fgets(</span><span class="c5">char</span><span class="c1">&nbsp;* inp) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(inp[strlen(inp) - </span><span class="c7">1</span><span>] == </span><span class="c14">&#39;\n&#39;</span><span>) { inp[strlen(inp) - </span><span class="c7">1</span><span>] = </span><span class="c50">0x0</span><span class="c1">; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Check if an input matches a command</span></p><p class="c0"><span class="c5">bool</span><span>&nbsp;cmpcommand(</span><span class="c5">char</span><span>&nbsp;* inp, </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(memcmp(inp, command, strlen(command)) == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;fin_char = inp[strlen(command)];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// the format specified is that a command ends with one of the following four characters.</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(fin_char == </span><span class="c14">&#39; &#39;</span><span>&nbsp;|| fin_char == </span><span class="c14">&#39;\t&#39;</span><span>&nbsp;|| fin_char == </span><span class="c14">&#39;\n&#39;</span><span>&nbsp;|| fin_char == </span><span class="c14">&#39;</span><span>\</span><span class="c7">0</span><span class="c14">&#39;</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">true</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Global strings (character arrays)</span></p><p class="c0"><span class="c5">char</span><span>&nbsp;DataSetLabel[</span><span class="c7">128</span><span>] = { </span><span class="c7">0</span><span class="c1">&nbsp;};</span></p><p class="c0"><span class="c5">char</span><span>&nbsp;OutputPath[</span><span class="c7">128</span><span>] = { </span><span class="c7">0</span><span class="c1">&nbsp;};</span></p><p class="c0"><span class="c5">char</span><span>&nbsp;fn_label_map[</span><span class="c7">128</span><span class="c1">];</span></p><p class="c0"><span class="c5">char</span><span>&nbsp;fn_data_map[</span><span class="c7">128</span><span class="c1">];</span></p><p class="c0"><span class="c5">char</span><span>&nbsp;fn_vectors[</span><span class="c7">128</span><span class="c1">];</span></p><p class="c0"><span class="c5">char</span><span>&nbsp;fn_labels[</span><span class="c7">128</span><span class="c1">];</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Count the amount of arguments given in an input command (as &#39; &#39; delimiter)</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;CountCommandArgs(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* tmpCommand = (</span><span class="c5">char</span><span>&nbsp;*)malloc((strlen(command) + </span><span class="c7">1</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(tmpCommand, command, strlen(command) + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;delim[</span><span class="c7">2</span><span>] = </span><span class="c14">&quot; &quot;</span><span>; </span><span class="c6 c3">// delimiter</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* next_tok;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* tok = strtok_s(tmpCommand, delim, &amp;next_tok);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(tok != NULL) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Arg #%d: &#39;%s&#39;\n&quot;</span><span class="c1">, count, tok);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; tok = strtok_s(NULL, delim, &amp;next_tok);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(tmpCommand);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Get command input argument at index as place it into output (also allocate memory for output)</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;GetCommandArg(</span><span class="c5">char</span><span>&nbsp;* command, </span><span class="c5">int</span><span>&nbsp;index, </span><span class="c5">char</span><span class="c1">&nbsp;** output) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* tmpCommand = (</span><span class="c5">char</span><span>&nbsp;*)malloc((strlen(command) + </span><span class="c7">1</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(tmpCommand, command, strlen(command) + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;delim[</span><span class="c7">2</span><span>] = </span><span class="c14">&quot; &quot;</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* next_tok;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* tok = strtok_s(tmpCommand, delim, &amp;next_tok);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(tok != NULL &amp;&amp; count &lt; index) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Arg #%d: &#39;%s&#39;\n&quot;</span><span class="c1">, count, tok);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; tok = strtok_s(NULL, delim, &amp;next_tok);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(index &gt; count) { free(tmpCommand); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; *output = (</span><span class="c5">char</span><span>*)malloc((strlen(tok) + </span><span class="c7">1</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(*output, tok, strlen(tok) + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(tmpCommand);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Update file paths using the user specified outputpath and the dataset global name</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;UpdateFilePaths() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/*fn_label_map = (char*)calloc(128, sizeof(char));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; fn_data_map = (char*)calloc(128, sizeof(char));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; fn_vectors = (char*)calloc(128, sizeof(char));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; fn_labels = (char*)calloc(128, sizeof(char));*/</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; sprintf_s(fn_label_map, </span><span class="c7">128</span><span>, </span><span class="c14">&quot;%s/%s.label_map&quot;</span><span class="c1">, OutputPath, DataSetLabel);</span></p><p class="c0"><span>&nbsp; &nbsp; sprintf_s(fn_data_map, </span><span class="c7">128</span><span>, </span><span class="c14">&quot;%s/%s.data_map&quot;</span><span class="c1">, OutputPath, DataSetLabel);</span></p><p class="c0"><span>&nbsp; &nbsp; sprintf_s(fn_vectors, </span><span class="c7">128</span><span>, </span><span class="c14">&quot;%s/%s.vectors&quot;</span><span class="c1">, OutputPath, DataSetLabel);</span></p><p class="c0"><span>&nbsp; &nbsp; sprintf_s(fn_labels, </span><span class="c7">128</span><span>, </span><span class="c14">&quot;%s/%s.labels&quot;</span><span class="c1">, OutputPath, DataSetLabel);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ChangeOutputPath() {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# Please choose an output path for generated files.\n&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; memset(OutputPath, </span><span class="c50">0x0</span><span>, </span><span class="c7">128</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; fgets(OutputPath, </span><span class="c7">127</span><span class="c1">, stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fix_fgets(OutputPath);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; UpdateFilePaths();</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# The data set will output to (vectors file example): &#39;%s&#39;\n&quot;</span><span class="c1">, fn_vectors);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ChangeDataSetName() {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# Please choose a name for this data set.\n&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; memset(DataSetLabel, </span><span class="c50">0x0</span><span>, </span><span class="c7">128</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; fgets(DataSetLabel, </span><span class="c7">127</span><span class="c1">, stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fix_fgets(DataSetLabel);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; UpdateFilePaths();</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# The data set will output to (vectors file example): &#39;%s&#39;\n&quot;</span><span class="c1">, fn_vectors);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Count how many labels exist in the label map file.</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;getExistingLabelsCount(uint8_t * existing_labels, FILE * fLabelMap) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;existing_labels_count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_pair[MaximumLabelLength + </span><span class="c7">2</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(fread_s(label_pair, (MaximumLabelLength + </span><span class="c7">2</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), MaximumLabelLength + </span><span class="c7">1</span><span class="c1">, fLabelMap)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint8_t label_key = label_pair[</span><span class="c7">0</span><span class="c1">];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; existing_labels[existing_labels_count] = label_key;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; existing_labels_count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;existing_labels_count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Prints the classes and their labels, which are stored in the label map file.</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ViewClassifications() {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# The following classifications exist in the data set: \n\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint8_t existing_labels[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; uint8_t existing_labels_count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// A file with a map (dictionary) of the label numbers (0-255) and their corresponding &quot;human&quot; definition.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errLabelMap;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// A file with a map of the actual wav files which are in the vectors file.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fDataMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errDataMap;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!file_exists(fn_label_map)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# As you can clearly see, there are none.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errDataMap || errLabelMap) { printf(</span><span class="c14">&quot;# Could not open data or label map files!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errDataMap || errLabelMap) { printf(</span><span class="c14">&quot;# Could not open data or label map files!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fseek(fDataMap, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// Every 256bytes are one pair in the dictionary. Starting at byte 0.</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_pair[MaximumLabelLength + </span><span class="c7">2</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(fread_s(label_pair, (MaximumLabelLength + </span><span class="c7">2</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), MaximumLabelLength + </span><span class="c7">1</span><span class="c1">, fLabelMap)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t label_key = label_pair[</span><span class="c7">0</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; %d | %s\n&quot;</span><span>, label_key, label_pair + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_labels[existing_labels_count] = label_key;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_labels_count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(existing_labels_count == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# As you can clearly see, there are none.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fDataMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Prints the file paths of each file in the dataset sorted by their labels.</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ViewDataFiles() {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# The following files are in the data set: \n\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint8_t existing_labels[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; uint8_t existing_labels_count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// A file with a map (dictionary) of the label numbers (0-255) and their corresponding &quot;human&quot; definition.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errLabelMap;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// A file with a map of the actual wav files which are in the vectors file.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fDataMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errDataMap;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!file_exists(fn_data_map)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# As you can clearly see, there are none.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errDataMap || errLabelMap) { printf(</span><span class="c14">&quot;# Could not open data or label map files!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errDataMap || errLabelMap) { printf(</span><span class="c14">&quot;# Could not open data or label map files!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;size = getFileSize(fDataMap); fseek(fDataMap, </span><span class="c7">0</span><span class="c1">, SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* file_data = (</span><span class="c5">char</span><span>*)malloc(size+</span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;read_count = fread_s(file_data, size, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), size, fDataMap);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(read_count == </span><span class="c7">0</span><span class="c1">) { </span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Error reading file.\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">;}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::map&lt;uint8_t,</span><span class="c5">char</span><span class="c1">*&gt; label_data_map;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// Every 256bytes are one pair in the dictionary. Starting at byte 0.</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_pair[MaximumLabelLength + </span><span class="c7">2</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(fread_s(label_pair, (MaximumLabelLength + </span><span class="c7">2</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), MaximumLabelLength + </span><span class="c7">1</span><span class="c1">, fLabelMap)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t label_key = label_pair[</span><span class="c7">0</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">//existing_labels[existing_labels_count] = label_key;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">//label_data_map.insert(std::pair&lt;uint8_t,char*&gt;(label_key, label_pair + 1));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; %u | %s\n&quot;</span><span>, label_key, label_pair + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* live_data = file_data;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;pos = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(pos &lt; size) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t data_key = live_data[pos];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(data_key == label_key) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t|--&gt; %s\n&quot;</span><span>, live_data + pos + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos += </span><span class="c7">2</span><span>&nbsp;+ strlen(live_data + pos + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_labels_count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(existing_labels_count == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# As you can clearly see, there are none.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/*else {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; existing_labels_count; i++) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t key = existing_labels[i];</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\t&gt; %u | %s\n&quot;, key, label_data_map.at(key));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char * live_data = file_data;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int pos = 0;</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (pos &lt; size) {</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t data_key = live_data[pos];</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (data_key == key) {</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\t|--&gt; %s\n&quot;, live_data + pos + 1);</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos += 2 + strlen(live_data + pos + 1);</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; }*/</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; free(file_data);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fDataMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;AddDataToSet() {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::string WAV_File_Path;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# Path for WAV file: &quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; get_current_dir() &lt;&lt; </span><span class="c14">&quot;\\&quot;</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; WAV_File_Path = get_current_dir() + </span><span class="c14">&quot;\\&quot;</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;WAV_File_Path_buffer[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; fgets(WAV_File_Path_buffer, </span><span class="c5">sizeof</span><span class="c1">(WAV_File_Path_buffer), stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fix_fgets(WAV_File_Path_buffer);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; strlen(WAV_File_Path_buffer); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; WAV_File_Path += WAV_File_Path_buffer[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; AudioFile&lt;</span><span class="c5">double</span><span>&gt; * audioFile = </span><span class="c5">new</span><span>&nbsp;AudioFile&lt;</span><span class="c5">double</span><span class="c1">&gt;();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(audioFile-&gt;load(WAV_File_Path)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# Loaded File!&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; audioFile-&gt;printSummary();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# CH: &quot;</span><span>&nbsp;&lt;&lt; audioFile-&gt;getNumChannels() &lt;&lt; </span><span class="c14">&quot; | &quot;</span><span>&nbsp;&lt;&lt; </span><span class="c14">&quot;SAMP: &quot;</span><span class="c1">&nbsp;&lt;&lt; audioFile-&gt;getNumSamplesPerChannel() * audioFile-&gt;getNumChannels() &lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; audioFile-&gt;ConcactChannels();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; FFT * FT = </span><span class="c5">new</span><span class="c1">&nbsp;FFT();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint8_t channelInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;sampInd = </span><span class="c7">0</span><span class="c1">; sampInd &lt; audioFile-&gt;getNumSamplesPerChannel(); sampInd++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FT-&gt;AppendToWave(audioFile-&gt;samples[channelInd][sampInd]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;actInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;\t&quot;</span><span>&nbsp;&lt;&lt; ++actInd &lt;&lt; </span><span class="c14">&quot;) &quot;</span><span>&nbsp;&lt;&lt; </span><span class="c14">&quot;Loaded \&quot;&quot;</span><span>&nbsp;&lt;&lt; WAV_File_Path &lt;&lt; </span><span class="c14">&quot;\&quot; into Fourier Transform!&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint32_t sample_count = audioFile-&gt;getNumSamplesPerChannel() / audioFile-&gt;getSampleRate();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// A file with a map (dictionary) of the label numbers (0-255) and their corresponding &quot;human&quot; definition.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// A file with a map of the actual wav files which are in the vectors file.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FILE * fDataMap;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errno_t errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errno_t errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errDataMap || errLabelMap) { printf(</span><span class="c14">&quot;# Could not open Data or Label map files!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// Create new vector and label files, or use existing ones and change the sample count</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FILE * fVect;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FILE * fLabel;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!file_exists(fn_vectors)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno_t errVects = fopen_s(&amp;fVect, fn_vectors, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno_t errLabels = fopen_s(&amp;fLabel, fn_labels, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t intro[</span><span class="c7">3</span><span>] = { convert_to_big_endian(</span><span class="c7">2612</span><span>), convert_to_big_endian(sample_count), convert_to_big_endian(</span><span class="c7">4000</span><span class="c1">) };</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t introLabels[</span><span class="c7">2</span><span>] = { convert_to_big_endian(</span><span class="c7">2211</span><span class="c1">), convert_to_big_endian(sample_count) };</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite((</span><span class="c5">char</span><span>*)intro, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c7">4</span><span>&nbsp;* </span><span class="c5">sizeof</span><span class="c1">(uint32_t), fVect);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite((</span><span class="c5">char</span><span>*)introLabels, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c7">2</span><span>&nbsp;* </span><span class="c5">sizeof</span><span class="c1">(uint32_t), fLabel);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno_t errVects = fopen_s(&amp;fVect, fn_vectors, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno_t errLabels = fopen_s(&amp;fLabel, fn_labels, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t old_sample_count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fLabel, </span><span class="c5">sizeof</span><span class="c1">(uint32_t), SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fread_s(&amp;old_sample_count, </span><span class="c5">sizeof</span><span>(old_sample_count), </span><span class="c5">sizeof</span><span>(uint32_t), </span><span class="c7">1</span><span class="c1">, fLabel);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count = convert_to_little_endian(old_sample_count);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count += sample_count;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count = convert_to_big_endian(old_sample_count);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fLabel, </span><span class="c5">sizeof</span><span class="c1">(uint32_t), SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fVect, </span><span class="c5">sizeof</span><span class="c1">(uint32_t), SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(&amp;old_sample_count, </span><span class="c5">sizeof</span><span>(uint32_t), </span><span class="c7">1</span><span class="c1">, fLabel);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(&amp;old_sample_count, </span><span class="c5">sizeof</span><span>(uint32_t), </span><span class="c7">1</span><span class="c1">, fVect);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fLabel, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fVect, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Please enter the label (as uint8) for this sound.\n&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_buffer[</span><span class="c7">16</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fgets(label_buffer, </span><span class="c5">sizeof</span><span class="c1">(label_buffer), stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fix_fgets(label_buffer);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">long</span><span>&nbsp;lab_long = strtol(label_buffer, NULL, </span><span class="c7">10</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint8_t lab = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;lab, &amp;lab_long, </span><span class="c5">sizeof</span><span class="c1">(uint8_t));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label[</span><span class="c7">1</span><span class="c1">] = { lab };</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/*char * label_buffer_temp = (char*)malloc(strlen(label_buffer));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; memcpy(label_buffer_temp, label_buffer, strlen(label_buffer));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\n\nGot label! %u\n\n&quot;, label_buffer_temp[0]);</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; sprintf_s(label, sizeof(label), &quot;%u&quot;, label_buffer_temp[0]);</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; free(label_buffer_temp);*/</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint8_t existing_labels[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;existing_labels_count = getExistingLabelsCount(existing_labels, fLabelMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fseek(fDataMap, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fseek(fLabelMap, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fwrite(label, </span><span class="c5">sizeof</span><span>(uint8_t), </span><span class="c7">1</span><span class="c1">, fDataMap);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/*char * WAV_File_Path_c_str = (char*)calloc(WAV_File_Path.length(), sizeof(char));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; strncpy_s(WAV_File_Path_c_str, WAV_File_Path.length(), WAV_File_Path.c_str(), WAV_File_Path.length());</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; fwrite(WAV_File_Path_c_str, sizeof(char), WAV_File_Path.length(), fDataMap);*/</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fwrite(WAV_File_Path.c_str(), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), WAV_File_Path.length(), fDataMap);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fwrite(OutputPath + </span><span class="c7">127</span><span>, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c7">1</span><span class="c1">, fDataMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">bool</span><span>&nbsp;exists = </span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(existing_labels_count &gt; </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(i &lt; </span><span class="c7">256</span><span class="c1">&nbsp;&amp;&amp; !exists) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exists = exists || existing_labels[i] == lab;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!exists) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# This is a new label, please describe it. (in 255 or less characters)\n&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_description_buffer[MaximumLabelLength + </span><span class="c7">1</span><span class="c1">];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fgets(label_description_buffer, MaximumLabelLength, stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fix_fgets(label_description_buffer);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(label, </span><span class="c7">1</span><span>, </span><span class="c7">1</span><span class="c1">, fLabelMap);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(label_description_buffer, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), MaximumLabelLength, fLabelMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Added the pair: {%u, %s} to the label_map.\n&quot;</span><span class="c1">, lab, label_description_buffer);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Now loading the file with the label %d.\n&quot;</span><span class="c1">, lab);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// Create an array of the frequencies</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;x = </span><span class="c7">0</span><span class="c1">; x &lt; sample_count; x++) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;Complex&gt; * liveFreq = FT-&gt;FourierTransfer_Part(audioFile-&gt;getSampleRate(), x);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* freqArr = (</span><span class="c5">char</span><span>&nbsp;*)calloc(FT-&gt;MaxFrequency(), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;freqInd = </span><span class="c7">0</span><span class="c1">; freqInd &lt; FT-&gt;MaxFrequency(); freqInd++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freqArr[freqInd] = liveFreq-&gt;at(freqInd).real();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(freqArr, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), FT-&gt;MaxFrequency(), fVect);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(label, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c7">1</span><span class="c1">, fLabel);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(freqArr);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fclose(fVect);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fclose(fLabel);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fclose(fDataMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;FT;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Appended sound!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;audioFile;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Initialize a new dataset</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;Initialize() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errLabelMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fDataMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errDataMap;</span></p><p class="c0"><span>&nbsp; &nbsp; errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fDataMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// predict the label of a file using the Classifier</span></p><p class="c0"><span class="c6 c3">/*</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; The predict function can take arguments such as:</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; 1) a file path.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; The first input can be the relative path to a vectors file which you want to use instead of processing a wav file into a vectors file.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; 2) the &#39;-f&#39; argument.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; This is passed into the classifier as &#39;fast&#39; which tells the program to only check some of the data points (arbitrarily) and not all of them.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; This obviously results in faster execution time (10x faster - since we take only a tenth of the vectors), but there is a penalty to the accuracy of the results. Though the final prediction is still usually correct.</span></p><p class="c0"><span class="c6 c3">*/</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;Predict(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;argc = CountCommandArgs(command);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Arg count: %d\n&quot;</span><span class="c1">, argc);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(argc == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;predictOutputFile[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;predictOutputFile_tmp[</span><span class="c7">128</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Name your prediction file: \n&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fgets(predictOutputFile_tmp, </span><span class="c5">sizeof</span><span class="c1">(predictOutputFile_tmp), stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fix_fgets(predictOutputFile_tmp);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; sprintf_s(predictOutputFile, </span><span class="c5">sizeof</span><span>(predictOutputFile), </span><span class="c14">&quot;%s/%s.vectors&quot;</span><span class="c1">, OutputPath, predictOutputFile_tmp);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; std::string WAV_File_Path;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# Path for WAV file: &quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; get_current_dir() &lt;&lt; </span><span class="c14">&quot;\\&quot;</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; WAV_File_Path = get_current_dir() + </span><span class="c14">&quot;\\&quot;</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;WAV_File_Path_buffer[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fgets(WAV_File_Path_buffer, </span><span class="c5">sizeof</span><span class="c1">(WAV_File_Path_buffer), stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fix_fgets(WAV_File_Path_buffer);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; strlen(WAV_File_Path_buffer); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAV_File_Path += WAV_File_Path_buffer[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; AudioFile&lt;</span><span class="c5">double</span><span>&gt; * audioFile = </span><span class="c5">new</span><span>&nbsp;AudioFile&lt;</span><span class="c5">double</span><span class="c1">&gt;();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// Parse audio file into FFT and export it as vectors into a vectors file</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(audioFile-&gt;load(WAV_File_Path)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# Loaded File!&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; audioFile-&gt;printSummary();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# CH: &quot;</span><span>&nbsp;&lt;&lt; audioFile-&gt;getNumChannels() &lt;&lt; </span><span class="c14">&quot; | &quot;</span><span>&nbsp;&lt;&lt; </span><span class="c14">&quot;SAMP: &quot;</span><span class="c1">&nbsp;&lt;&lt; audioFile-&gt;getNumSamplesPerChannel() * audioFile-&gt;getNumChannels() &lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FFT * FT = </span><span class="c5">new</span><span class="c1">&nbsp;FFT();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t channelInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;sampInd = </span><span class="c7">0</span><span class="c1">; sampInd &lt; audioFile-&gt;getNumSamplesPerChannel(); sampInd++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FT-&gt;AppendToWave(audioFile-&gt;samples[channelInd][sampInd]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;actInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;\t&quot;</span><span>&nbsp;&lt;&lt; ++actInd &lt;&lt; </span><span class="c14">&quot;) &quot;</span><span>&nbsp;&lt;&lt; </span><span class="c14">&quot;Loaded \&quot;&quot;</span><span>&nbsp;&lt;&lt; WAV_File_Path &lt;&lt; </span><span class="c14">&quot;\&quot; into Fourier Transform!&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t sample_count = audioFile-&gt;getNumSamplesPerChannel() / audioFile-&gt;getSampleRate();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FILE * fVect;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno_t errVects;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!file_exists(predictOutputFile)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errVects = fopen_s(&amp;fVect, predictOutputFile, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t intro[</span><span class="c7">3</span><span>] = { convert_to_big_endian(</span><span class="c7">2612</span><span>), convert_to_big_endian(sample_count), convert_to_big_endian(</span><span class="c7">4000</span><span class="c1">) };</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite((</span><span class="c5">char</span><span>*)intro, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c7">3</span><span>&nbsp;* </span><span class="c5">sizeof</span><span class="c1">(uint32_t), fVect);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errVects = fopen_s(&amp;fVect, predictOutputFile, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t old_sample_count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fread_s(&amp;old_sample_count, </span><span class="c5">sizeof</span><span>(old_sample_count), </span><span class="c5">sizeof</span><span>(uint32_t), </span><span class="c7">1</span><span class="c1">, fVect);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count = convert_to_little_endian(old_sample_count);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count += sample_count;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count = convert_to_big_endian(old_sample_count);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fVect, </span><span class="c5">sizeof</span><span class="c1">(uint32_t), SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(&amp;old_sample_count, </span><span class="c5">sizeof</span><span>(uint32_t), </span><span class="c7">1</span><span class="c1">, fVect);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fVect, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errVects) { printf(</span><span class="c14">&quot;Could not find nor create prediction file!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// Create an array of the frequencies</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;x = </span><span class="c7">0</span><span class="c1">; x &lt; sample_count; x++) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;Complex&gt; * liveFreq = FT-&gt;FourierTransfer_Part(audioFile-&gt;getSampleRate(), x);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* freqArr = (</span><span class="c5">char</span><span>&nbsp;*)calloc(FT-&gt;MaxFrequency(), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;freqInd = </span><span class="c7">0</span><span class="c1">; freqInd &lt; FT-&gt;MaxFrequency(); freqInd++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freqArr[freqInd] = liveFreq-&gt;at(freqInd).real();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(freqArr, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), FT-&gt;MaxFrequency(), fVect);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(freqArr);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose(fVect);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;FT;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;audioFile;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Created prediction file!!\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;path[</span><span class="c7">2048</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; sprintf_s(path, </span><span class="c5">sizeof</span><span>(path), </span><span class="c14">&quot;ClassifyFrequencyArray.exe \&quot;%s\&quot; \&quot;%s\&quot; \&quot;%s\&quot;&quot;</span><span class="c1">, OutputPath, DataSetLabel, predictOutputFile);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;prediction_output = system(path);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errno_t errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errLabelMap) { printf(</span><span class="c14">&quot;# Could not open label map file!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_pair[MaximumLabelLength + </span><span class="c7">2</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(fread_s(label_pair, (MaximumLabelLength + </span><span class="c7">2</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), MaximumLabelLength + </span><span class="c7">1</span><span class="c1">, fLabelMap)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t label_key = label_pair[</span><span class="c7">0</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(label_key == prediction_output) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;The prediction for this file is: \n\t%d | %s\n&quot;</span><span>, prediction_output, label_pair + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span>&nbsp;(argc == </span><span class="c7">1</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* predictOutputFile;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(GetCommandArg(command, </span><span class="c7">0</span><span>, &amp;predictOutputFile) != </span><span class="c7">0</span><span>) { printf(</span><span class="c14">&quot;# Could not find argument!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;path[</span><span class="c7">2048</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; sprintf_s(path, </span><span class="c5">sizeof</span><span>(path), </span><span class="c14">&quot;ClassifyFrequencyArray.exe \&quot;%s\&quot; \&quot;%s\&quot; \&quot;%s\&quot;&quot;</span><span class="c1">, OutputPath, DataSetLabel, predictOutputFile);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;prediction_output = system(path);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errno_t errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errLabelMap) { printf(</span><span class="c14">&quot;# Could not open label map file!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_pair[MaximumLabelLength + </span><span class="c7">2</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(fread_s(label_pair, (MaximumLabelLength + </span><span class="c7">2</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), MaximumLabelLength + </span><span class="c7">1</span><span class="c1">, fLabelMap)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t label_key = label_pair[</span><span class="c7">0</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(label_key == prediction_output) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;The prediction for this file is: \n\t%d | %s\n&quot;</span><span>, prediction_output, label_pair + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span>&nbsp;(argc == </span><span class="c7">2</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* optionCommand;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(GetCommandArg(command, </span><span class="c7">0</span><span>, &amp;optionCommand) != </span><span class="c7">0</span><span>) { printf(</span><span class="c14">&quot;# Could not find argument!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(strcmp(optionCommand, </span><span class="c14">&quot;-f&quot;</span><span>) == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* predictOutputFile;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(GetCommandArg(command, </span><span class="c7">1</span><span>, &amp;predictOutputFile) != </span><span class="c7">0</span><span>) { printf(</span><span class="c14">&quot;# Could not find argument!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;path[</span><span class="c7">2048</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf_s(path, </span><span class="c5">sizeof</span><span>(path), </span><span class="c14">&quot;ClassifyFrequencyArray.exe \&quot;%s\&quot; \&quot;%s\&quot; \&quot;%s\&quot; \&quot;fast\&quot;&quot;</span><span class="c1">, OutputPath, DataSetLabel, predictOutputFile);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;prediction_output = system(path);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno_t errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errLabelMap) { printf(</span><span class="c14">&quot;# Could not open label map file!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_pair[MaximumLabelLength + </span><span class="c7">2</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(fread_s(label_pair, (MaximumLabelLength + </span><span class="c7">2</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), MaximumLabelLength + </span><span class="c7">1</span><span class="c1">, fLabelMap)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t label_key = label_pair[</span><span class="c7">0</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(label_key == prediction_output) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;The prediction for this file is: \n\t%d | %s\n&quot;</span><span>, prediction_output, label_pair + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# Unrecognized argument count!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ExitProgram() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(fn_data_map);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(fn_label_map);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(fn_labels);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(fn_vectors);</span></p><p class="c0"><span>&nbsp; &nbsp; exit(</span><span class="c7">0</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;Help(</span><span class="c5">bool</span><span class="c1">&nbsp;ext) {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;You can use the following commands:\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; help\t\t\t| To see this menu.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; help extended\t\t| To see a full list of commands.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; init\t\t\t| Initialize dataset files. You must do this first when creating a new dataset!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; change data set name\t| To change the name given to output files.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(ext) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; change dataset name\t| To change the name given to output files.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; change data name\t| To change the name given to output files.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; change output\t\t| To change the output path of created files.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; list classes\t\t| To see which classifications exist in the data set.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(ext) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; list classifications\t| To see which classifications exist in the data set.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; list class\t\t| To see which classifications exist in the data set.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; view classes\t\t| To see which classifications exist in the data set.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; view classifications\t| To see which classifications exist in the data set.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; view class\t\t| To see which classifications exist in the data set.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; list files\t\t| To see a sorted list of the files which have been loaded into the dataset.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(ext) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; list data\t\t| To see a sorted list of the files which have been loaded into the dataset.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; view files\t\t| To see a sorted list of the files which have been loaded into the dataset.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; view data\t\t| To see a sorted list of the files which have been loaded into the dataset.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; add file\t\t| To add another file into the dataset.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(ext) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; add data\t\t| To add another file into the dataset.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; predict\t\t| Predict the genre of a wav file.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; exit\t\t\t| To close the program.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Gets user input and compares it to valid commands</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ProccessCommands() {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;input[</span><span class="c7">1024</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; fgets(input, </span><span class="c5">sizeof</span><span class="c1">(input), stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fix_fgets(input);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;help&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;help extended&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;help ext&quot;</span><span>)) { </span><span class="c5">return</span><span>&nbsp;Help(cmpcommand(input, </span><span class="c14">&quot;help extended&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;help ext&quot;</span><span class="c1">)); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;change output&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;ChangeOutputPath(); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;change data set name&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;change dataset name&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;change data name&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;ChangeOutputPath(); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;list classifications&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;view classifications&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;view class&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;list class&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;view classes&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;list classes&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;ViewClassifications(); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;list files&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;list data&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;view files&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;view data&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;ViewDataFiles(); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;add file&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;add data&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;AddDataToSet(); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;predict&quot;</span><span>)) { </span><span class="c5">return</span><span>&nbsp;Predict(input + strlen(</span><span class="c14">&quot;predict&quot;</span><span>) + </span><span class="c7">1</span><span class="c1">); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;init&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;initialize&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;Initialize(); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;exit&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;close&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;ExitProgram(); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;main()</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;=== === === === ===&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;Started WAV Analyzer&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot; &nbsp;Data Set Editor&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;=== === === === ===&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ChangeOutputPath();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ChangeDataSetName();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(</span><span class="c5">true</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(ProccessCommands() == </span><span class="c7">1</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Command Failed!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h3 class="c39 c47" id="h.luf29o1ssaeg"><span class="c4 c15 c18"></span></h3><h3 class="c39" id="h.rzcffo9mu0lx"><span class="c4 c15 c18">AudioFile.h</span></h3><p class="c17 c46"><span class="c1">Other than CreateDataSet.cpp, and obviously the FFT class we wrote earlier, there is one more file included in CDS. This header file, which is the only part of the project which was not written from scratch. The code loads a Wave (WAV) or Audio Interchange File Format (AIFF) file from the file system and allows us to directly interface with the sample array. This sample array is actually the input for our Fourier Transform, as it literally is samples of the original sound wave.</span></p><p class="c17 c46"><span>The code for this file was generously provided by Adam Stark under the GNU General Public License. Link to original publication: </span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://github.com/adamstark/AudioFile&amp;sa=D&amp;source=editors&amp;ust=1617101997545000&amp;usg=AOvVaw21TTG7U3bte6EsRIOVeC3K">https://github.com/adamstark/AudioFile</a></span></p><p class="c17 c12 c46"><span class="c1"></span></p><a id="t.2fae98fa5eba5b2ed3d22c8291b58b80a59ab9b9"></a><a id="t.37"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0"><span class="c6 c3">//=======================================================================</span></p><p class="c0"><span class="c6 c3">/** @file AudioFile.h</span></p><p class="c0"><span class="c6 c3">&nbsp;* &nbsp;@author Adam Stark</span></p><p class="c0"><span class="c6 c3">&nbsp;* &nbsp;@copyright Copyright (C) 2017 &nbsp;Adam Stark</span></p><p class="c0"><span class="c6 c3">&nbsp;*</span></p><p class="c0"><span class="c6 c3">&nbsp;* This file is part of the &#39;AudioFile&#39; library</span></p><p class="c0"><span class="c6 c3">&nbsp;*</span></p><p class="c0"><span class="c6 c3">&nbsp;* This program is free software: you can redistribute it and/or modify</span></p><p class="c0"><span class="c6 c3">&nbsp;* it under the terms of the GNU General Public License as published by</span></p><p class="c0"><span class="c6 c3">&nbsp;* the Free Software Foundation, either version 3 of the License, or</span></p><p class="c0"><span class="c6 c3">&nbsp;* (at your option) any later version.</span></p><p class="c0"><span class="c6 c3">&nbsp;*</span></p><p class="c0"><span class="c6 c3">&nbsp;* This program is distributed in the hope that it will be useful,</span></p><p class="c0"><span class="c6 c3">&nbsp;* but WITHOUT ANY WARRANTY; without even the implied warranty of</span></p><p class="c0"><span class="c6 c3">&nbsp;* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. &nbsp;See the</span></p><p class="c0"><span class="c6 c3">&nbsp;* GNU General Public License for more details.</span></p><p class="c0"><span class="c6 c3">&nbsp;*</span></p><p class="c0"><span class="c6 c3">&nbsp;* You should have received a copy of the GNU General Public License</span></p><p class="c0"><span class="c6 c3">&nbsp;* along with this program. &nbsp;If not, see &lt;http://www.gnu.org/licenses/&gt;.</span></p><p class="c0"><span class="c6 c3">&nbsp;*/</span></p><p class="c0"><span>&nbsp;</span><span class="c6 c3">//=======================================================================</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp;</span><span class="c6 c3">//=======================================================================</span></p><p class="c0"><span class="c6 c3">/**</span></p><p class="c0"><span class="c6 c3">* &nbsp;This file has been modified by Michael K. Steinberg (2021)</span></p><p class="c0"><span class="c6 c3">*</span></p><p class="c0"><span class="c6 c3">* &nbsp;Many, many thanks to Adam Stark for the original code! :)</span></p><p class="c0"><span class="c6 c3">*/</span></p><p class="c0"><span class="c6 c3">//=======================================================================</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#ifndef</span><span class="c1">&nbsp;_AS_AudioFile_h</span></p><p class="c0"><span class="c5">#define</span><span class="c1">&nbsp;_AS_AudioFile_h</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">iostream</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">assert.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">string</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">fstream</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">unordered_map</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">iterator</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">algorithm</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">cstring</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// disable some warnings on Windows</span></p><p class="c0"><span class="c5">#if</span><span class="c1">&nbsp;defined (_MSC_VER)</span></p><p class="c0"><span class="c5">__pragma</span><span class="c1">(warning(push))</span></p><p class="c0"><span class="c5">__pragma</span><span>(warning(disable : </span><span class="c7">4244</span><span class="c1">))</span></p><p class="c0"><span class="c5">__pragma</span><span>(warning(disable : </span><span class="c7">4457</span><span class="c1">))</span></p><p class="c0"><span class="c5">__pragma</span><span>(warning(disable : </span><span class="c7">4458</span><span class="c1">))</span></p><p class="c0"><span class="c5">__pragma</span><span>(warning(disable : </span><span class="c7">4389</span><span class="c1">))</span></p><p class="c0"><span class="c5">__pragma</span><span>(warning(disable : </span><span class="c7">4996</span><span class="c1">))</span></p><p class="c0"><span class="c5">#elif</span><span class="c1">&nbsp;defined (__GNUC__)</span></p><p class="c0"><span>_Pragma(</span><span class="c14">&quot;GCC diagnostic push&quot;</span><span class="c1">)</span></p><p class="c0"><span>_Pragma(</span><span class="c14">&quot;GCC diagnostic ignored \&quot;-Wconversion\&quot;&quot;</span><span class="c1">)</span></p><p class="c0"><span>_Pragma(</span><span class="c14">&quot;GCC diagnostic ignored \&quot;-Wsign-compare\&quot;&quot;</span><span class="c1">)</span></p><p class="c0"><span>_Pragma(</span><span class="c14">&quot;GCC diagnostic ignored \&quot;-Wshadow\&quot;&quot;</span><span class="c1">)</span></p><p class="c0"><span class="c2">#endif</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c6 c3">/** The different types of audio file, plus some other types to</span></p><p class="c0"><span class="c6 c3">&nbsp;* indicate a failure to load a file, or that one hasn&#39;t been</span></p><p class="c0"><span class="c6 c3">&nbsp;* loaded yet</span></p><p class="c0"><span class="c6 c3">&nbsp;*/</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">enum</span><span>&nbsp;</span><span class="c5">class</span><span class="c1">&nbsp;AudioFileFormat</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Error,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; NotLoaded,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Wave,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Aiff</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">class</span><span class="c1">&nbsp;AudioFile</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c5">public</span><span class="c1">:</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">typedef</span><span class="c1">&nbsp;std::vector&lt;std::vector&lt;T&gt; &gt; AudioBuffer;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Constructor */</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; AudioFile();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Loads an audio file from a given file path.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;* @Returns true if the file was successfully loaded</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;*/</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span class="c1">&nbsp;load(std::string filePath);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Saves an audio file to a given file path.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;* @Returns true if the file was successfully saved</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;*/</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span class="c1">&nbsp;save(std::string filePath, AudioFileFormat format = AudioFileFormat::Wave);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** @Returns the sample rate */</span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t getSampleRate() </span><span class="c5">const</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** @Returns the number of audio channels in the buffer */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;getNumChannels() </span><span class="c5">const</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** @Returns true if the audio file is mono */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span>&nbsp;isMono() </span><span class="c5">const</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** @Returns true if the audio file is stereo */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span>&nbsp;isStereo() </span><span class="c5">const</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** @Returns the bit depth of each sample */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;getBitDepth() </span><span class="c5">const</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** @Returns the number of samples per channel */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;getNumSamplesPerChannel() </span><span class="c5">const</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** @Returns the length in seconds of the audio file based on the number of samples and sample rate */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;getLengthInSeconds() </span><span class="c5">const</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Prints a summary of the audio file to the console */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;printSummary() </span><span class="c5">const</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Set the audio buffer for this AudioFile by copying samples from another buffer.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;* @Returns true if the buffer was copied successfully.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;*/</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span class="c1">&nbsp;setAudioBuffer(AudioBuffer&amp; newBuffer);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Sets the audio buffer to a given number of channels and number of samples per channel. This will try to preserve</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;* the existing audio, adding zeros to any new channels or new samples in a given channel.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;*/</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;setAudioBufferSize(</span><span class="c5">int</span><span>&nbsp;numChannels, </span><span class="c5">int</span><span class="c1">&nbsp;numSamples);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Sets the number of samples per channel in the audio buffer. This will try to preserve</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;* the existing audio, adding zeros to new samples in a given channel if the number of samples is increased.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;*/</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;setNumSamplesPerChannel(</span><span class="c5">int</span><span class="c1">&nbsp;numSamples);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Sets the number of channels. New channels will have the correct number of samples and be initialised to zero */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;setNumChannels(</span><span class="c5">int</span><span class="c1">&nbsp;numChannels);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Sets the bit depth for the audio file. If you use the save() function, this bit depth rate will be used */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;setBitDepth(</span><span class="c5">int</span><span class="c1">&nbsp;numBitsPerSample);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Sets the sample rate for the audio file. If you use the save() function, this sample rate will be used */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;setSampleRate(uint32_t newSampleRate);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Sets whether the library should log error messages to the console. By default this is true */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;shouldLogErrorsToConsole(</span><span class="c5">bool</span><span class="c1">&nbsp;logErrors);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** A vector of vectors holding the audio samples for the AudioFile. You can</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;* access the samples by channel and then by sample index, i.e:</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;*</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;* &nbsp; &nbsp; &nbsp;samples[channel][sampleIndex]</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp;*/</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; AudioBuffer samples;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** An optional iXML chunk that can be added to the AudioFile. */</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::string iXMLChunk;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/** Concact all channels into channel 0 */</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;ConcactChannels();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">private</span><span class="c1">:</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">enum</span><span>&nbsp;</span><span class="c5">class</span><span class="c1">&nbsp;Endianness</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; LittleEndian,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; BigEndian</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; };</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; AudioFileFormat determineAudioFileFormat(std::vector&lt;uint8_t&gt;&amp; fileData);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span class="c1">&nbsp;decodeWaveFile(std::vector&lt;uint8_t&gt;&amp; fileData);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span class="c1">&nbsp;decodeAiffFile(std::vector&lt;uint8_t&gt;&amp; fileData);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;clearAudioBuffer();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; int32_t fourBytesToInt(std::vector&lt;uint8_t&gt;&amp; source, </span><span class="c5">int</span><span class="c1">&nbsp;startIndex, Endianness endianness = Endianness::LittleEndian);</span></p><p class="c0"><span>&nbsp; &nbsp; int16_t twoBytesToInt(std::vector&lt;uint8_t&gt;&amp; source, </span><span class="c5">int</span><span class="c1">&nbsp;startIndex, Endianness endianness = Endianness::LittleEndian);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;getIndexOfString(std::vector&lt;uint8_t&gt;&amp; source, std::string s);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;getIndexOfChunk(std::vector&lt;uint8_t&gt;&amp; source, </span><span class="c5">const</span><span>&nbsp;std::string&amp; chunkHeaderID, </span><span class="c5">int</span><span class="c1">&nbsp;startIndex, Endianness endianness = Endianness::LittleEndian);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; T sixteenBitIntToSample(int16_t sample);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; int16_t sampleToSixteenBitInt(T sample);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint8_t sampleToSingleByte(T sample);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; T singleByteToSample(uint8_t sample);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t getAiffSampleRate(std::vector&lt;uint8_t&gt;&amp; fileData, </span><span class="c5">int</span><span class="c1">&nbsp;sampleRateStartIndex);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span>&nbsp;tenByteMatch(std::vector&lt;uint8_t&gt;&amp; v1, </span><span class="c5">int</span><span>&nbsp;startIndex1, std::vector&lt;uint8_t&gt;&amp; v2, </span><span class="c5">int</span><span class="c1">&nbsp;startIndex2);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;addSampleRateToAiffData(std::vector&lt;uint8_t&gt;&amp; fileData, uint32_t sampleRate);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; T clamp(T v1, T minValue, T maxValue);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;reportError(std::string errorMessage);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; AudioFileFormat audioFileFormat;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint32_t sampleRate;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;bitDepth;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span>&nbsp;logErrorsToConsole{ </span><span class="c5">true</span><span class="c1">&nbsp;};</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c6 c3">// Pre-defined 10-byte representations of common sample rates</span></p><p class="c0"><span class="c5">static</span><span class="c1">&nbsp;std::unordered_map &lt;uint32_t, std::vector&lt;uint8_t&gt;&gt; aiffSampleRateTable = {</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">8000</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">11</span><span>, </span><span class="c7">250</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">11025</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">12</span><span>, </span><span class="c7">172</span><span>, </span><span class="c7">68</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">16000</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">12</span><span>, </span><span class="c7">250</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">22050</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">13</span><span>, </span><span class="c7">172</span><span>, </span><span class="c7">68</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">32000</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">13</span><span>, </span><span class="c7">250</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">37800</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">14</span><span>, </span><span class="c7">147</span><span>, </span><span class="c7">168</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">44056</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">14</span><span>, </span><span class="c7">172</span><span>, </span><span class="c7">24</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">44100</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">14</span><span>, </span><span class="c7">172</span><span>, </span><span class="c7">68</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">47250</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">14</span><span>, </span><span class="c7">184</span><span>, </span><span class="c7">146</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">48000</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">14</span><span>, </span><span class="c7">187</span><span>, </span><span class="c7">128</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">50000</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">14</span><span>, </span><span class="c7">195</span><span>, </span><span class="c7">80</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">50400</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">14</span><span>, </span><span class="c7">196</span><span>, </span><span class="c7">224</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">88200</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">15</span><span>, </span><span class="c7">172</span><span>, </span><span class="c7">68</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">96000</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">15</span><span>, </span><span class="c7">187</span><span>, </span><span class="c7">128</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">176400</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">16</span><span>, </span><span class="c7">172</span><span>, </span><span class="c7">68</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">192000</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">16</span><span>, </span><span class="c7">187</span><span>, </span><span class="c7">128</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">352800</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">17</span><span>, </span><span class="c7">172</span><span>, </span><span class="c7">68</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">2822400</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">20</span><span>, </span><span class="c7">172</span><span>, </span><span class="c7">68</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}},</span></p><p class="c0"><span>&nbsp; &nbsp; {</span><span class="c7">5644800</span><span>, {</span><span class="c7">64</span><span>, </span><span class="c7">21</span><span>, </span><span class="c7">172</span><span>, </span><span class="c7">68</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span>, </span><span class="c7">0</span><span class="c1">}}</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">enum</span><span class="c1">&nbsp;WavAudioFormat</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; PCM = </span><span class="c50">0x0001</span><span class="c1">,</span></p><p class="c0"><span>&nbsp; &nbsp; IEEEFloat = </span><span class="c50">0x0003</span><span class="c1">,</span></p><p class="c0"><span>&nbsp; &nbsp; ALaw = </span><span class="c50">0x0006</span><span class="c1">,</span></p><p class="c0"><span>&nbsp; &nbsp; MULaw = </span><span class="c50">0x0007</span><span class="c1">,</span></p><p class="c0"><span>&nbsp; &nbsp; Extensible = </span><span class="c3 c15 c50">0xFFFE</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">enum</span><span class="c1">&nbsp;AIFFAudioFormat</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Uncompressed,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Compressed,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Error</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c6 c3">/* IMPLEMENTATION */</span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c1">AudioFile&lt;T&gt;::AudioFile()</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">static_assert</span><span>(std::is_floating_point&lt;T&gt;::value, </span><span class="c14">&quot;Error: This version of AudioFile only supports floating point sample formats.&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; bitDepth = </span><span class="c7">16</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; sampleRate = </span><span class="c7">44100</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; samples.resize(</span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; samples[</span><span class="c7">0</span><span>].resize(</span><span class="c7">0</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; audioFileFormat = AudioFileFormat::NotLoaded;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span>uint32_t AudioFile&lt;T&gt;::getSampleRate() </span><span class="c2">const</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;sampleRate;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;AudioFile&lt;T&gt;::getNumChannels() </span><span class="c2">const</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(</span><span class="c5">int</span><span class="c1">)samples.size();</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">bool</span><span>&nbsp;AudioFile&lt;T&gt;::isMono() </span><span class="c2">const</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;getNumChannels() == </span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">bool</span><span>&nbsp;AudioFile&lt;T&gt;::isStereo() </span><span class="c2">const</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;getNumChannels() == </span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;AudioFile&lt;T&gt;::getBitDepth() </span><span class="c2">const</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;bitDepth;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;AudioFile&lt;T&gt;::getNumSamplesPerChannel() </span><span class="c2">const</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(samples.size() &gt; </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(</span><span class="c5">int</span><span>)samples[</span><span class="c7">0</span><span class="c1">].size();</span></p><p class="c0"><span>&nbsp; &nbsp; } </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">double</span><span>&nbsp;AudioFile&lt;T&gt;::getLengthInSeconds() </span><span class="c2">const</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(</span><span class="c5">double</span><span>)getNumSamplesPerChannel() / (</span><span class="c5">double</span><span class="c1">)sampleRate;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;AudioFile&lt;T&gt;::printSummary() </span><span class="c2">const</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;|======================================|&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;Number of Channels: &quot;</span><span class="c1">&nbsp;&lt;&lt; getNumChannels() &lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;Number of Samples per Channel: &quot;</span><span class="c1">&nbsp;&lt;&lt; getNumSamplesPerChannel() &lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;Sample Rate: &quot;</span><span class="c1">&nbsp;&lt;&lt; sampleRate &lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;Bit Depth: &quot;</span><span class="c1">&nbsp;&lt;&lt; bitDepth &lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;Length in Seconds: &quot;</span><span class="c1">&nbsp;&lt;&lt; getLengthInSeconds() &lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;|======================================|&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">bool</span><span class="c1">&nbsp;AudioFile&lt;T&gt;::setAudioBuffer(AudioBuffer&amp; newBuffer)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;numChannels = (</span><span class="c5">int</span><span class="c1">)newBuffer.size();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(numChannels &lt;= </span><span class="c7">0</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; assert(</span><span class="c5">false</span><span>&nbsp;&amp;&amp; </span><span class="c14">&quot;The buffer your are trying to use has no channels.&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; size_t numSamples = newBuffer[</span><span class="c7">0</span><span class="c1">].size();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// set the number of channels</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; samples.resize(newBuffer.size());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;k = </span><span class="c7">0</span><span class="c1">; k &lt; getNumChannels(); k++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; assert(newBuffer[k].size() == numSamples);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; samples[k].resize(numSamples);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(size_t i = </span><span class="c7">0</span><span class="c1">; i &lt; numSamples; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples[k][i] = newBuffer[k][i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">true</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;AudioFile&lt;T&gt;::setAudioBufferSize(</span><span class="c5">int</span><span>&nbsp;numChannels, </span><span class="c5">int</span><span class="c1">&nbsp;numSamples)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; samples.resize(numChannels);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; setNumSamplesPerChannel(numSamples);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;AudioFile&lt;T&gt;::setNumSamplesPerChannel(</span><span class="c5">int</span><span class="c1">&nbsp;numSamples)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;originalSize = getNumSamplesPerChannel();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; getNumChannels(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; samples[i].resize(numSamples);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// set any new samples to zero</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(numSamples &gt; originalSize)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::fill(samples[i].begin() + originalSize, samples[i].end(), (T)</span><span class="c7">0</span><span class="c1">.);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;AudioFile&lt;T&gt;::setNumChannels(</span><span class="c5">int</span><span class="c1">&nbsp;numChannels)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;originalNumChannels = getNumChannels();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;originalNumSamplesPerChannel = getNumSamplesPerChannel();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; samples.resize(numChannels);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// make sure any new channels are set to the right size</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// and filled with zeros</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(numChannels &gt; originalNumChannels)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span class="c1">&nbsp;i = originalNumChannels; i &lt; numChannels; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples[i].resize(originalNumSamplesPerChannel);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::fill(samples[i].begin(), samples[i].end(), (T)</span><span class="c7">0</span><span class="c1">.);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;AudioFile&lt;T&gt;::setBitDepth(</span><span class="c5">int</span><span class="c1">&nbsp;numBitsPerSample)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; bitDepth = numBitsPerSample;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;AudioFile&lt;T&gt;::setSampleRate(uint32_t newSampleRate)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; sampleRate = newSampleRate;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;AudioFile&lt;T&gt;::shouldLogErrorsToConsole(</span><span class="c5">bool</span><span class="c1">&nbsp;logErrors)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; logErrorsToConsole = logErrors;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">bool</span><span class="c1">&nbsp;AudioFile&lt;T&gt;::load(std::string filePath)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::ifstream file(filePath, std::ios::binary);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// check the file exists</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!file.good())</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: This file doesn&#39;t exist or otherwise can&#39;t be loaded.\n&quot;</span><span class="c1">&nbsp;+ filePath);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; file.unsetf(std::ios::skipws);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::istream_iterator&lt;uint8_t&gt; begin(file), end;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;uint8_t&gt; fileData(begin, end);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// get audio file format</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; audioFileFormat = determineAudioFileFormat(fileData);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(audioFileFormat == AudioFileFormat::Wave)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;decodeWaveFile(fileData);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span class="c1">&nbsp;(audioFileFormat == AudioFileFormat::Aiff)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;decodeAiffFile(fileData);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Audio File Type: Error&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">bool</span><span class="c1">&nbsp;AudioFile&lt;T&gt;::decodeWaveFile(std::vector&lt;uint8_t&gt;&amp; fileData)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// -----------------------------------------------------------</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// HEADER CHUNK</span></p><p class="c0"><span>&nbsp; &nbsp; std::string headerChunkID(fileData.begin(), fileData.begin() + </span><span class="c7">4</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//int32_t fileSizeInBytes = fourBytesToInt (fileData, 4) + 8;</span></p><p class="c0"><span>&nbsp; &nbsp; std::string format(fileData.begin() + </span><span class="c7">8</span><span>, fileData.begin() + </span><span class="c7">12</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// -----------------------------------------------------------</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// try and find the start points of key chunks</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;indexOfDataChunk = getIndexOfChunk(fileData, </span><span class="c14">&quot;data&quot;</span><span>, </span><span class="c7">12</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;indexOfFormatChunk = getIndexOfChunk(fileData, </span><span class="c14">&quot;fmt &quot;</span><span>, </span><span class="c7">12</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;indexOfXMLChunk = getIndexOfChunk(fileData, </span><span class="c14">&quot;iXML&quot;</span><span>, </span><span class="c7">12</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// if we can&#39;t find the data or format chunks, or the IDs/formats don&#39;t seem to be as expected</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// then it is unlikely we&#39;ll able to read this file, so abort</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(indexOfDataChunk == -</span><span class="c7">1</span><span>&nbsp;|| indexOfFormatChunk == -</span><span class="c7">1</span><span>&nbsp;|| headerChunkID != </span><span class="c14">&quot;RIFF&quot;</span><span>&nbsp;|| format != </span><span class="c14">&quot;WAVE&quot;</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: This doesn&#39;t seem to be a valid .WAV file!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// -----------------------------------------------------------</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// FORMAT CHUNK</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;f = indexOfFormatChunk;</span></p><p class="c0"><span>&nbsp; &nbsp; std::string formatChunkID(fileData.begin() + f, fileData.begin() + f + </span><span class="c7">4</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//int32_t formatChunkSize = fourBytesToInt (fileData, f + 4);</span></p><p class="c0"><span>&nbsp; &nbsp; int16_t audioFormat = twoBytesToInt(fileData, f + </span><span class="c7">8</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; int16_t numChannels = twoBytesToInt(fileData, f + </span><span class="c7">10</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; sampleRate = (uint32_t)fourBytesToInt(fileData, f + </span><span class="c7">12</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; int32_t numBytesPerSecond = fourBytesToInt(fileData, f + </span><span class="c7">16</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; int16_t numBytesPerBlock = twoBytesToInt(fileData, f + </span><span class="c7">20</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; bitDepth = (</span><span class="c5">int</span><span>)twoBytesToInt(fileData, f + </span><span class="c7">22</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;numBytesPerSample = bitDepth / </span><span class="c7">8</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// check that the audio format is PCM or Float</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(audioFormat != WavAudioFormat::PCM &amp;&amp; audioFormat != WavAudioFormat::IEEEFloat)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: This .WAV file is encoded in a format that this library does not support!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// check the number of channels is mono or stereo</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(numChannels &lt; </span><span class="c7">1</span><span>&nbsp;|| numChannels &gt; </span><span class="c7">128</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: This WAV file seems to be an invalid number of channels (or corrupted?).\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// check header data is consistent</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;((numBytesPerSecond != (numChannels * sampleRate * bitDepth) / </span><span class="c7">8</span><span class="c1">) || (numBytesPerBlock != (numChannels * numBytesPerSample)))</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: The header data in this WAV file seems to be inconsistent!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// check bit depth is either 8, 16, 24 or 32 bit</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(bitDepth != </span><span class="c7">8</span><span>&nbsp;&amp;&amp; bitDepth != </span><span class="c7">16</span><span>&nbsp;&amp;&amp; bitDepth != </span><span class="c7">24</span><span>&nbsp;&amp;&amp; bitDepth != </span><span class="c7">32</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: This file has a bit depth that is not 8, 16, 24 or 32 bits!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// -----------------------------------------------------------</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// DATA CHUNK</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;d = indexOfDataChunk;</span></p><p class="c0"><span>&nbsp; &nbsp; std::string dataChunkID(fileData.begin() + d, fileData.begin() + d + </span><span class="c7">4</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; int32_t dataChunkSize = fourBytesToInt(fileData, d + </span><span class="c7">4</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;numSamples = dataChunkSize / (numChannels * bitDepth / </span><span class="c7">8</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;samplesStartIndex = indexOfDataChunk + </span><span class="c7">8</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; clearAudioBuffer();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; samples.resize(numChannels);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; numSamples; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;channel = </span><span class="c7">0</span><span class="c1">; channel &lt; numChannels; channel++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;sampleIndex = samplesStartIndex + (numBytesPerBlock * i) + channel * numBytesPerSample;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(bitDepth == </span><span class="c7">8</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T sample = singleByteToSample(fileData[sampleIndex]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples[channel].push_back(sample);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span>&nbsp;(bitDepth == </span><span class="c7">16</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16_t sampleAsInt = twoBytesToInt(fileData, sampleIndex);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T sample = sixteenBitIntToSample(sampleAsInt);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples[channel].push_back(sample);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span>&nbsp;(bitDepth == </span><span class="c7">24</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32_t sampleAsInt = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sampleAsInt = (fileData[sampleIndex + </span><span class="c7">2</span><span>] &lt;&lt; </span><span class="c7">16</span><span>) | (fileData[sampleIndex + </span><span class="c7">1</span><span>] &lt;&lt; </span><span class="c7">8</span><span class="c1">) | fileData[sampleIndex];</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(sampleAsInt &amp; </span><span class="c50">0x800000</span><span>) </span><span class="c6 c3">// &nbsp;if the 24th bit is set, this is a negative number in 24-bit world</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sampleAsInt = sampleAsInt | ~</span><span class="c50">0xFFFFFF</span><span>; </span><span class="c6 c3">// so make sure sign is extended to the 32 bit float</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T sample = (T)sampleAsInt / (T)</span><span class="c7">8388608</span><span class="c1">.;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples[channel].push_back(sample);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span>&nbsp;(bitDepth == </span><span class="c7">32</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32_t sampleAsInt = fourBytesToInt(fileData, sampleIndex);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T sample;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(audioFormat == WavAudioFormat::IEEEFloat)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sample = (T)</span><span class="c5">reinterpret_cast</span><span>&lt;</span><span class="c5">float</span><span class="c1">&amp;&gt; (sampleAsInt);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c6 c3">// assume PCM</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sample = (T)sampleAsInt / </span><span class="c5">static_cast</span><span>&lt;</span><span class="c5">float</span><span class="c1">&gt; (std::numeric_limits&lt;std::int32_t&gt;::max());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples[channel].push_back(sample);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(</span><span class="c5">false</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// -----------------------------------------------------------</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// iXML CHUNK</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(indexOfXMLChunk != -</span><span class="c7">1</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; int32_t chunkSize = fourBytesToInt(fileData, indexOfXMLChunk + </span><span class="c7">4</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; iXMLChunk = std::string((</span><span class="c5">const</span><span>&nbsp;</span><span class="c5">char</span><span>*)&amp;fileData[indexOfXMLChunk + </span><span class="c7">8</span><span class="c1">], chunkSize);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">true</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">bool</span><span class="c1">&nbsp;AudioFile&lt;T&gt;::decodeAiffFile(std::vector&lt;uint8_t&gt;&amp; fileData)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// -----------------------------------------------------------</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// HEADER CHUNK</span></p><p class="c0"><span>&nbsp; &nbsp; std::string headerChunkID(fileData.begin(), fileData.begin() + </span><span class="c7">4</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//int32_t fileSizeInBytes = fourBytesToInt (fileData, 4, Endianness::BigEndian) + 8;</span></p><p class="c0"><span>&nbsp; &nbsp; std::string format(fileData.begin() + </span><span class="c7">8</span><span>, fileData.begin() + </span><span class="c7">12</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;audioFormat = format == </span><span class="c14">&quot;AIFF&quot;</span><span>&nbsp;? AIFFAudioFormat::Uncompressed : format == </span><span class="c14">&quot;AIFC&quot;</span><span class="c1">&nbsp;? AIFFAudioFormat::Compressed : AIFFAudioFormat::Error;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// -----------------------------------------------------------</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// try and find the start points of key chunks</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;indexOfCommChunk = getIndexOfChunk(fileData, </span><span class="c14">&quot;COMM&quot;</span><span>, </span><span class="c7">12</span><span class="c1">, Endianness::BigEndian);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;indexOfSoundDataChunk = getIndexOfChunk(fileData, </span><span class="c14">&quot;SSND&quot;</span><span>, </span><span class="c7">12</span><span class="c1">, Endianness::BigEndian);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;indexOfXMLChunk = getIndexOfChunk(fileData, </span><span class="c14">&quot;iXML&quot;</span><span>, </span><span class="c7">12</span><span class="c1">, Endianness::BigEndian);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// if we can&#39;t find the data or format chunks, or the IDs/formats don&#39;t seem to be as expected</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// then it is unlikely we&#39;ll able to read this file, so abort</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(indexOfSoundDataChunk == -</span><span class="c7">1</span><span>&nbsp;|| indexOfCommChunk == -</span><span class="c7">1</span><span>&nbsp;|| headerChunkID != </span><span class="c14">&quot;FORM&quot;</span><span class="c1">&nbsp;|| audioFormat == AIFFAudioFormat::Error)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: this doesn&#39;t seem to be a valid AIFF file&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// -----------------------------------------------------------</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// COMM CHUNK</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;p = indexOfCommChunk;</span></p><p class="c0"><span>&nbsp; &nbsp; std::string commChunkID(fileData.begin() + p, fileData.begin() + p + </span><span class="c7">4</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//int32_t commChunkSize = fourBytesToInt (fileData, p + 4, Endianness::BigEndian);</span></p><p class="c0"><span>&nbsp; &nbsp; int16_t numChannels = twoBytesToInt(fileData, p + </span><span class="c7">8</span><span class="c1">, Endianness::BigEndian);</span></p><p class="c0"><span>&nbsp; &nbsp; int32_t numSamplesPerChannel = fourBytesToInt(fileData, p + </span><span class="c7">10</span><span class="c1">, Endianness::BigEndian);</span></p><p class="c0"><span>&nbsp; &nbsp; bitDepth = (</span><span class="c5">int</span><span>)twoBytesToInt(fileData, p + </span><span class="c7">14</span><span class="c1">, Endianness::BigEndian);</span></p><p class="c0"><span>&nbsp; &nbsp; sampleRate = getAiffSampleRate(fileData, p + </span><span class="c7">16</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// check the sample rate was properly decoded</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(sampleRate == </span><span class="c7">0</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: This AIFF file has an unsupported sample rate!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// check the number of channels is mono or stereo</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(numChannels &lt; </span><span class="c7">1</span><span>&nbsp;|| numChannels &gt; </span><span class="c7">2</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: This AIFF file seems to be neither mono nor stereo (perhaps multi-track, or corrupted?)!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// check bit depth is either 8, 16, 24 or 32-bit</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(bitDepth != </span><span class="c7">8</span><span>&nbsp;&amp;&amp; bitDepth != </span><span class="c7">16</span><span>&nbsp;&amp;&amp; bitDepth != </span><span class="c7">24</span><span>&nbsp;&amp;&amp; bitDepth != </span><span class="c7">32</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: This file has a bit depth that is not 8, 16, 24 or 32 bits!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// -----------------------------------------------------------</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// SSND CHUNK</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;s = indexOfSoundDataChunk;</span></p><p class="c0"><span>&nbsp; &nbsp; std::string soundDataChunkID(fileData.begin() + s, fileData.begin() + s + </span><span class="c7">4</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; int32_t soundDataChunkSize = fourBytesToInt(fileData, s + </span><span class="c7">4</span><span class="c1">, Endianness::BigEndian);</span></p><p class="c0"><span>&nbsp; &nbsp; int32_t offset = fourBytesToInt(fileData, s + </span><span class="c7">8</span><span class="c1">, Endianness::BigEndian);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//int32_t blockSize = fourBytesToInt (fileData, s + 12, Endianness::BigEndian);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;numBytesPerSample = bitDepth / </span><span class="c7">8</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;numBytesPerFrame = numBytesPerSample * numChannels;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;totalNumAudioSampleBytes = numSamplesPerChannel * numBytesPerFrame;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;samplesStartIndex = s + </span><span class="c7">16</span><span>&nbsp;+ (</span><span class="c5">int</span><span class="c1">)offset;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// sanity check the data</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;((soundDataChunkSize - </span><span class="c7">8</span><span>) != totalNumAudioSampleBytes || totalNumAudioSampleBytes &gt; </span><span class="c5">static_cast</span><span>&lt;</span><span class="c5">long</span><span class="c1">&gt;(fileData.size() - samplesStartIndex))</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: The meta-data for this file doesn&#39;t seem right!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; clearAudioBuffer();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; samples.resize(numChannels);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; numSamplesPerChannel; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;channel = </span><span class="c7">0</span><span class="c1">; channel &lt; numChannels; channel++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;sampleIndex = samplesStartIndex + (numBytesPerFrame * i) + channel * numBytesPerSample;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(bitDepth == </span><span class="c7">8</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int8_t sampleAsSigned8Bit = (int8_t)fileData[sampleIndex];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T sample = (T)sampleAsSigned8Bit / (T)</span><span class="c7">128</span><span class="c1">.;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples[channel].push_back(sample);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span>&nbsp;(bitDepth == </span><span class="c7">16</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16_t sampleAsInt = twoBytesToInt(fileData, sampleIndex, Endianness::BigEndian);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T sample = sixteenBitIntToSample(sampleAsInt);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples[channel].push_back(sample);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span>&nbsp;(bitDepth == </span><span class="c7">24</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32_t sampleAsInt = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sampleAsInt = (fileData[sampleIndex] &lt;&lt; </span><span class="c7">16</span><span>) | (fileData[sampleIndex + </span><span class="c7">1</span><span>] &lt;&lt; </span><span class="c7">8</span><span>) | fileData[sampleIndex + </span><span class="c7">2</span><span class="c1">];</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(sampleAsInt &amp; </span><span class="c50">0x800000</span><span>) </span><span class="c6 c3">// &nbsp;if the 24th bit is set, this is a negative number in 24-bit world</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sampleAsInt = sampleAsInt | ~</span><span class="c50">0xFFFFFF</span><span>; </span><span class="c6 c3">// so make sure sign is extended to the 32 bit float</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T sample = (T)sampleAsInt / (T)</span><span class="c7">8388608</span><span class="c1">.;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples[channel].push_back(sample);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span>&nbsp;(bitDepth == </span><span class="c7">32</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32_t sampleAsInt = fourBytesToInt(fileData, sampleIndex, Endianness::BigEndian);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T sample;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(audioFormat == AIFFAudioFormat::Compressed)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sample = (T)</span><span class="c5">reinterpret_cast</span><span>&lt;</span><span class="c5">float</span><span class="c1">&amp;&gt; (sampleAsInt);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c6 c3">// assume uncompressed</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sample = (T)sampleAsInt / </span><span class="c5">static_cast</span><span>&lt;</span><span class="c5">float</span><span class="c1">&gt; (std::numeric_limits&lt;std::int32_t&gt;::max());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples[channel].push_back(sample);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(</span><span class="c5">false</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// -----------------------------------------------------------</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// iXML CHUNK</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(indexOfXMLChunk != -</span><span class="c7">1</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; int32_t chunkSize = fourBytesToInt(fileData, indexOfXMLChunk + </span><span class="c7">4</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; iXMLChunk = std::string((</span><span class="c5">const</span><span>&nbsp;</span><span class="c5">char</span><span>*)&amp;fileData[indexOfXMLChunk + </span><span class="c7">8</span><span class="c1">], chunkSize);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">true</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span>uint32_t AudioFile&lt;T&gt;::getAiffSampleRate(std::vector&lt;uint8_t&gt;&amp; fileData, </span><span class="c5">int</span><span class="c1">&nbsp;sampleRateStartIndex)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">auto</span><span class="c1">&nbsp;it : aiffSampleRateTable)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(tenByteMatch(fileData, sampleRateStartIndex, it.second, </span><span class="c7">0</span><span class="c1">))</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;it.first;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">bool</span><span>&nbsp;AudioFile&lt;T&gt;::tenByteMatch(std::vector&lt;uint8_t&gt;&amp; v1, </span><span class="c5">int</span><span>&nbsp;startIndex1, std::vector&lt;uint8_t&gt;&amp; v2, </span><span class="c5">int</span><span class="c1">&nbsp;startIndex2)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; </span><span class="c7">10</span><span class="c1">; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(v1[startIndex1 + i] != v2[startIndex2 + i])</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">true</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;AudioFile&lt;T&gt;::clearAudioBuffer()</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(size_t i = </span><span class="c7">0</span><span class="c1">; i &lt; samples.size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; samples[i].clear();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; samples.clear();</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c1">AudioFileFormat AudioFile&lt;T&gt;::determineAudioFileFormat(std::vector&lt;uint8_t&gt;&amp; fileData)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; std::string header(fileData.begin(), fileData.begin() + </span><span class="c7">4</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(header == </span><span class="c14">&quot;RIFF&quot;</span><span class="c1">)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;AudioFileFormat::Wave;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span>&nbsp;(header == </span><span class="c14">&quot;FORM&quot;</span><span class="c1">)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;AudioFileFormat::Aiff;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;AudioFileFormat::Error;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span>int32_t AudioFile&lt;T&gt;::fourBytesToInt(std::vector&lt;uint8_t&gt;&amp; source, </span><span class="c5">int</span><span class="c1">&nbsp;startIndex, Endianness endianness)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; int32_t result;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(endianness == Endianness::LittleEndian)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; result = (source[startIndex + </span><span class="c7">3</span><span>] &lt;&lt; </span><span class="c7">24</span><span>) | (source[startIndex + </span><span class="c7">2</span><span>] &lt;&lt; </span><span class="c7">16</span><span>) | (source[startIndex + </span><span class="c7">1</span><span>] &lt;&lt; </span><span class="c7">8</span><span class="c1">) | source[startIndex];</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; result = (source[startIndex] &lt;&lt; </span><span class="c7">24</span><span>) | (source[startIndex + </span><span class="c7">1</span><span>] &lt;&lt; </span><span class="c7">16</span><span>) | (source[startIndex + </span><span class="c7">2</span><span>] &lt;&lt; </span><span class="c7">8</span><span>) | source[startIndex + </span><span class="c7">3</span><span class="c1">];</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;result;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span>int16_t AudioFile&lt;T&gt;::twoBytesToInt(std::vector&lt;uint8_t&gt;&amp; source, </span><span class="c5">int</span><span class="c1">&nbsp;startIndex, Endianness endianness)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; int16_t result;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(endianness == Endianness::LittleEndian)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; result = (source[startIndex + </span><span class="c7">1</span><span>] &lt;&lt; </span><span class="c7">8</span><span class="c1">) | source[startIndex];</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; result = (source[startIndex] &lt;&lt; </span><span class="c7">8</span><span>) | source[startIndex + </span><span class="c7">1</span><span class="c1">];</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;result;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;AudioFile&lt;T&gt;::getIndexOfString(std::vector&lt;uint8_t&gt;&amp; source, std::string stringToSearchFor)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;index = -</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;stringLength = (</span><span class="c5">int</span><span class="c1">)stringToSearchFor.length();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(size_t i = </span><span class="c7">0</span><span class="c1">; i &lt; source.size() - stringLength; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; std::string section(source.begin() + i, source.begin() + i + stringLength);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(section == stringToSearchFor)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = </span><span class="c5">static_cast</span><span>&lt;</span><span class="c5">int</span><span class="c1">&gt; (i);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;index;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;AudioFile&lt;T&gt;::getIndexOfChunk(std::vector&lt;uint8_t&gt;&amp; source, </span><span class="c5">const</span><span>&nbsp;std::string&amp; chunkHeaderID, </span><span class="c5">int</span><span class="c1">&nbsp;startIndex, Endianness endianness)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">constexpr</span><span>&nbsp;</span><span class="c5">int</span><span>&nbsp;dataLen = </span><span class="c7">4</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(chunkHeaderID.size() != dataLen)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; assert(</span><span class="c5">false</span><span>&nbsp;&amp;&amp; </span><span class="c14">&quot;Invalid chunk header ID string&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;i = startIndex;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(i &lt; source.size() - dataLen)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(memcmp(&amp;source[i], chunkHeaderID.data(), dataLen) == </span><span class="c7">0</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;i;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; i += dataLen;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">auto</span><span class="c1">&nbsp;chunkSize = fourBytesToInt(source, i, endianness);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; i += (dataLen + chunkSize);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c1">T AudioFile&lt;T&gt;::sixteenBitIntToSample(int16_t sample)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">static_cast</span><span>&lt;T&gt; (sample) / </span><span class="c5">static_cast</span><span>&lt;T&gt; (</span><span class="c7">32768</span><span class="c1">.);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c1">int16_t AudioFile&lt;T&gt;::sampleToSixteenBitInt(T sample)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; sample = clamp(sample, -</span><span class="c7">1</span><span>., </span><span class="c7">1</span><span class="c1">.);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">static_cast</span><span>&lt;int16_t&gt; (sample * </span><span class="c7">32767</span><span class="c1">.);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c1">uint8_t AudioFile&lt;T&gt;::sampleToSingleByte(T sample)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; sample = clamp(sample, -</span><span class="c7">1</span><span>., </span><span class="c7">1</span><span class="c1">.);</span></p><p class="c0"><span>&nbsp; &nbsp; sample = (sample + </span><span class="c7">1</span><span>.) / </span><span class="c7">2</span><span class="c1">.;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">static_cast</span><span>&lt;uint8_t&gt; (sample * </span><span class="c7">255</span><span class="c1">.);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c1">T AudioFile&lt;T&gt;::singleByteToSample(uint8_t sample)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">static_cast</span><span>&lt;T&gt; (sample - </span><span class="c7">128</span><span>) / </span><span class="c5">static_cast</span><span>&lt;T&gt; (</span><span class="c7">128</span><span class="c1">.);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c1">T AudioFile&lt;T&gt;::clamp(T value, T minValue, T maxValue)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; value = std::min(value, maxValue);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; value = std::max(value, minValue);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;value;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//=============================================================</span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;AudioFile&lt;T&gt;::reportError(std::string errorMessage)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(logErrorsToConsole) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; errorMessage &lt;&lt; std::endl;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">template</span><span>&nbsp;&lt;</span><span class="c5">class</span><span class="c1">&nbsp;T&gt;</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;AudioFile&lt;T&gt;::ConcactChannels() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(AudioFile&lt;T&gt;::isStereo()) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;sample_index = </span><span class="c7">0</span><span>; sample_index &lt; samples[</span><span class="c7">1</span><span class="c1">].size(); sample_index++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples[</span><span class="c7">0</span><span>].push_back(samples[</span><span class="c7">1</span><span class="c1">][sample_index]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(samples[</span><span class="c7">0</span><span>].size() != samples[</span><span class="c7">1</span><span>].size() * </span><span class="c7">2</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reportError(</span><span class="c14">&quot;Error: Concacting channels failed!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samples.erase(samples.begin() + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#if</span><span class="c1">&nbsp;defined (_MSC_VER)</span></p><p class="c0"><span class="c5">__pragma</span><span class="c1">(warning(pop))</span></p><p class="c0"><span class="c5">#elif</span><span class="c1">&nbsp;defined (__GNUC__)</span></p><p class="c0"><span>_Pragma(</span><span class="c14">&quot;GCC diagnostic pop&quot;</span><span class="c1">)</span></p><p class="c0"><span class="c2">#endif</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#endif</span><span>&nbsp;</span><span class="c30">/* AudioFile_h */</span></p></td></tr></tbody></table><hr style="page-break-before:always;display:none;"><p class="c17 c12 c46"><span class="c1"></span></p><h1 class="c36" id="h.xkjtgfmwbqe"><span class="c4 c15 c56">Multifunction Audio Classifier</span></h1><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;After some tinkering with the Music Genre Classifier, I realized there was more potential than I had anticipated; the exact same code and structure could be used to classify any type of sound! The entire project was written to be as generic and modular as possible, and therefore was easily adaptable to a few more problems.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><h3 class="c39" id="h.7sqzyolimvv2"><span class="c4 c15 c18">Network Output Files - .net</span></h3><p class="c17 c46"><span class="c1">The only real difference between the various solutions to the problems is the resulting network file (.net file, explained below), which is produced uniquely for each problem and its dataset. This network file actually turned out to be invaluable as during testing, some versions of the network required multiple days of training. Unfortunately, the power lines in Tel Aviv are extremely volatile during winter (around when I began training the networks), and the power would shut off every few hours. This meant I would lose hours of work each time the computer crashed. To overcome this, the network export files were designed. Network export files contain all the information needed to recreate a &ldquo;carbon&rdquo; copy of a trained network.</span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Network Output file contains the weights and biases of each and every neuron, and information needed to redesign the structure (layer layout) of the network. Additionally, to improve the ability to sort between network output files, before each export the network tests itself and appends its best score into the output file.</span></p><h2 class="c54" id="h.nm3bulueensr"><span class="c4 c15 c32">Final Result:</span></h2><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 325.33px;"><img alt="" src="images/image28.png" style="width: 601.70px; height: 325.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 325.33px;"><img alt="" src="images/image12.png" style="width: 601.70px; height: 325.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using this Audio Classifier, we are able to classify:</span></p><ul class="c24 lst-kix_b91ee1teiew4-0 start"><li class="c54 c73 li-bullet-0"><h2 id="h.qvvedneg9cjy" style="display:inline"><span class="c4 c15 c32">Different genres of music:</span></h2></li></ul><ul class="c24 lst-kix_b91ee1teiew4-1 start"><li class="c17 c40 li-bullet-0"><span class="c1">The first test was to see if we can differentiate between genres of music. The result was that we can classify with a little over 78% accuracy &lsquo;Classical Music&rsquo;, &lsquo;Electronic Dance Music&rsquo;, &lsquo;Jazz&rsquo;, and &lsquo;Rock&rsquo;. This test was done with a network of 4000 -&gt; 420 -&gt; 32 -&gt; 4, and took around 11 training iterations on a dataset of 23,707 feature vectors.</span></li></ul><ul class="c24 lst-kix_b91ee1teiew4-2 start"><li class="c17 c33 li-bullet-0"><span>Network File: </span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://github.com/Michael-K-Stein/Sound-Classifier/blob/master/Neural%2520Networks/MNIST_fast/MNIST_fast/MNIST_Network_Output3.net&amp;sa=D&amp;source=editors&amp;ust=1617101997696000&amp;usg=AOvVaw0QAQyiYL_j5UQ4xxT00LWD">MNIST_Network_Output3.net</a></span></li></ul><ul class="c24 lst-kix_b91ee1teiew4-0"><li class="c54 c73 li-bullet-0"><h2 id="h.muph8g8rz4k7" style="display:inline"><span class="c4 c15 c32">Different people speaking:</span></h2></li></ul><ul class="c24 lst-kix_b91ee1teiew4-1 start"><li class="c17 c40 li-bullet-0"><span>The next test was to differentiate between people&rsquo;s voices. As explained in the </span><span class="c20"><a class="c8" href="#h.hds9hl5hocod">Theoretical Background</a></span><span>, this is almost identical to our previous problem. Hence, we used the exact same program, with the exact same network configuration to give us an accuracy of over 96% when differentiating between &lsquo;</span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3DKvBsusuBA0o&amp;sa=D&amp;source=editors&amp;ust=1617101997696000&amp;usg=AOvVaw2v6HASXAMKbwmhOfN4e9aU">Angela Merkel</a></span><span>&rsquo;, &lsquo;</span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://www.npr.org/transcripts/122701268&amp;sa=D&amp;source=editors&amp;ust=1617101997696000&amp;usg=AOvVaw3BXCw3AMf7X0aqoHklYlnm">Martin Luther King Jr</a></span><span>&rsquo;, &lsquo;</span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3DhJNM0C-7lPk%26t&amp;sa=D&amp;source=editors&amp;ust=1617101997697000&amp;usg=AOvVaw2LvWgn0UBzmSy6UdaYqHnU">John F Kennedy</a></span><span>&rsquo;, and &lsquo;</span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3D2NWeucMKrLI%26t&amp;sa=D&amp;source=editors&amp;ust=1617101997697000&amp;usg=AOvVaw3Xx4HWHjVOOJXRpyiUbqJ2">Bucky Roberts</a></span><span class="c1">&rsquo;, after around 30 training cycles of 2,838 data samples.</span></li></ul><ul class="c24 lst-kix_b91ee1teiew4-2 start"><li class="c17 c33 li-bullet-0"><span>Network File: </span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://github.com/Michael-K-Stein/Sound-Classifier/blob/master/SpeachRecognition/FourV_96.net&amp;sa=D&amp;source=editors&amp;ust=1617101997697000&amp;usg=AOvVaw0_rAzqXJ-twG6iBUPSJ-rH">FourV_96.net</a></span></li></ul><ul class="c24 lst-kix_b91ee1teiew4-0"><li class="c54 c73 li-bullet-0"><h2 id="h.qdq2jc6pmsv" style="display:inline"><span class="c4 c15 c32">Different instruments:</span></h2></li></ul><ul class="c24 lst-kix_b91ee1teiew4-1 start"><li class="c17 c40 li-bullet-0"><span>Now let&rsquo;s try instruments! Testing with these following classifications and files </span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3DBJp_16j8s-A&amp;sa=D&amp;source=editors&amp;ust=1617101997698000&amp;usg=AOvVaw0afyjXCPxAZQYcdxAwC-ch">Piano</a></span><span>, </span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3Dnbr4lu4KI1k&amp;sa=D&amp;source=editors&amp;ust=1617101997698000&amp;usg=AOvVaw05FiSxNdPP9Yi1paoRSfVQ">Guitar</a></span><span>, </span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3DnaR_laSbUVQ&amp;sa=D&amp;source=editors&amp;ust=1617101997698000&amp;usg=AOvVaw1rJYU0pZrPRTPS68bfYeST">Violin</a></span><span class="c1">, returned a test accuracy of ~98% on a very simple network of 4000 -&gt; 30 -&gt; 3 with 7547 feature vectors.</span></li></ul><ul class="c24 lst-kix_b91ee1teiew4-2 start"><li class="c17 c33 li-bullet-0"><span>Network file: </span><span class="c20"><a class="c8" href="https://www.google.com/url?q=https://github.com/Michael-K-Stein/Sound-Classifier/blob/master/Demo%2520AudioClassifier/Instr98.net&amp;sa=D&amp;source=editors&amp;ust=1617101997699000&amp;usg=AOvVaw1UIWOwcyXH29n38dkJbm8M">Instr98.net</a></span></li></ul><hr style="page-break-before:always;display:none;"><h2 class="c38" id="h.8rw2v052ny8c"><span class="c4 c15 c32"></span></h2><h2 class="c54" id="h.5mmr5ropg797"><span class="c4 c15 c32">Code:</span></h2><h3 class="c39" id="h.s9f76537z0mu"><span class="c4 c15 c18">neuron.h + neuron.cpp</span></h3><p class="c17 c12"><span class="c1"></span></p><a id="t.ccfc103e2026ed524e0d602461df35950b1ec54d"></a><a id="t.38"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">stdio.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">cmath</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">random</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">time.h</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">static</span><span>&nbsp;</span><span class="c5">int</span><span>&nbsp;import_c_only = </span><span class="c7">1</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">class</span><span class="c1">&nbsp;Neuron</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c5">public</span><span class="c1">:</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;output;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;delta;</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; weights;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* weights_array;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint32_t weights_array_size;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; Neuron(</span><span class="c5">int</span><span>, </span><span class="c5">int</span><span>); </span><span class="c6 c3">// ctor</span></p><p class="c0"><span>&nbsp; &nbsp; Neuron(); </span><span class="c6 c3">// ctor for import</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;initialize_weights(</span><span class="c5">int</span><span>); </span><span class="c6 c3">// randomize weight values</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;activate(std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; inputs);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;activate(</span><span class="c5">int</span><span>&nbsp;inputs_size, </span><span class="c5">double</span><span>&nbsp;* inputs); </span><span class="c6 c3">// c</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;c_only();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t export_neuron(</span><span class="c5">char</span><span class="c1">&nbsp;* buffer);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;import_neuron(uint32_t prev_layer_size, uint32_t layer_size, </span><span class="c5">char</span><span class="c1">&nbsp;* buffer);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t raw_size();</span></p><p class="c0"><span class="c1">};</span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">neuron.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span>&nbsp;generateRandomNumber(</span><span class="c5">double</span><span>&nbsp;min, </span><span class="c5">double</span><span class="c1">&nbsp;max)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;random = (</span><span class="c5">double</span><span class="c1">)rand() / RAND_MAX;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;min + random * (max - min);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">Neuron::Neuron() {}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>Neuron::Neuron(</span><span class="c5">int</span><span>&nbsp;prev_layer_size, </span><span class="c5">int</span><span class="c1">&nbsp;curr_layer_size)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; initialize_weights(prev_layer_size);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;Neuron::initialize_weights(</span><span class="c5">int</span><span class="c1">&nbsp;prev_layer_size)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; prev_layer_size + </span><span class="c7">1</span><span class="c1">; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; weights.push_back(generateRandomNumber(-</span><span class="c7">1.0</span><span>, </span><span class="c7">1.0</span><span class="c1">));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span>&nbsp;Neuron::activate(std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; inputs) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;activation = weights.back(); </span><span class="c6 c3">// bias</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; weights.size() - </span><span class="c7">1</span><span class="c1">; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; activation += weights[i] * inputs[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;activation;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">double</span><span>&nbsp;Neuron::activate(</span><span class="c5">int</span><span>&nbsp;input_size, </span><span class="c5">double</span><span class="c1">&nbsp;* inputs) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;activation = weights_array[input_size]; </span><span class="c6 c3">// bias</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; input_size; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; activation += weights_array[i] * inputs[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;activation;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;Neuron::c_only() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(weights.size() &gt; </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; weights_array = (</span><span class="c5">double</span><span>*)malloc(weights.size() * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; weights_array_size = weights.size();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; weights.size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weights_array[i] = weights.at(i);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; weights.clear();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">uint64_t Neuron::raw_size() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(weights_array_size * </span><span class="c5">sizeof</span><span>(weights_array[</span><span class="c7">0</span><span class="c1">]));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>uint32_t Neuron::export_neuron(</span><span class="c5">char</span><span class="c1">&nbsp;* buffer) {</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(buffer, weights_array, (weights_array_size * </span><span class="c5">sizeof</span><span>(weights_array[</span><span class="c7">0</span><span class="c1">])));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(weights_array_size * </span><span class="c5">sizeof</span><span>(weights_array[</span><span class="c7">0</span><span class="c1">]));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span>&nbsp;Neuron::import_neuron(uint32_t prev_layer_size, uint32_t layer_size, </span><span class="c5">char</span><span class="c1">&nbsp;* buffer) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(weights_array != NULL) { free(weights_array); }</span></p><p class="c0"><span>&nbsp; &nbsp; weights_array_size = prev_layer_size + </span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; weights_array = (</span><span class="c5">double</span><span>*)malloc(weights_array_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; weights_array_size; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;val = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;val, buffer + (i * </span><span class="c5">sizeof</span><span>(val)), </span><span class="c5">sizeof</span><span class="c1">(val));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(import_c_only) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; weights_array[i] = val;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; } </span><span class="c5">else</span><span class="c1">&nbsp;{ weights.push_back(val); }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h3 class="c39" id="h.uji3vcytg5hd"><span class="c4 c15 c18">layer.h + layer.cpp</span></h3><p class="c17 c12"><span class="c1"></span></p><a id="t.e5b97c4a50b20d947e80a99e613726d76ecb8e39"></a><a id="t.39"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">neuron.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">stdint.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">static</span><span>&nbsp;</span><span class="c5">int</span><span>&nbsp;layerId = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">class</span><span class="c1">&nbsp;Layer</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c5">public</span><span class="c1">:</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;id;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;current_layer_size;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;Neuron *&gt; neurons;</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; layer_outputs;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Neuron ** neurons_array;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;neurons_size;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* layer_outputs_array;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; Layer(</span><span class="c5">int</span><span>&nbsp;prev_layer_size, </span><span class="c5">int</span><span>&nbsp;curr_layer_size); </span><span class="c6 c3">// ctor</span></p><p class="c0"><span>&nbsp; &nbsp; Layer(</span><span class="c5">int</span><span>, </span><span class="c5">int</span><span>, </span><span class="c5">bool</span><span>); </span><span class="c6 c3">// ctor for import</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;c_only();</span></p><p class="c0"><span class="c1">};</span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">layer.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>Layer::Layer(</span><span class="c5">int</span><span>&nbsp;prev_layer_size, </span><span class="c5">int</span><span class="c1">&nbsp;curr_layer_size)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; curr_layer_size; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; neurons.push_back(</span><span class="c5">new</span><span class="c1">&nbsp;Neuron(prev_layer_size, curr_layer_size));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;current_layer_size = curr_layer_size;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>Layer::Layer(</span><span class="c5">int</span><span>&nbsp;prev_layer_size, </span><span class="c5">int</span><span>&nbsp;curr_layer_size, </span><span class="c5">bool</span><span class="c1">&nbsp;importing)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(importing) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(import_c_only) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(neurons_array != NULL) { free(neurons_array); }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neurons_size = curr_layer_size;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neurons_array = (Neuron**)malloc(neurons_size *</span><span class="c5">sizeof</span><span class="c1">(Neuron*));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; curr_layer_size; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(import_c_only) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neurons_array[i] = </span><span class="c5">new</span><span class="c1">&nbsp;Neuron();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neurons.push_back(</span><span class="c5">new</span><span class="c1">&nbsp;Neuron());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; curr_layer_size; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neurons.push_back(</span><span class="c5">new</span><span class="c1">&nbsp;Neuron(prev_layer_size, curr_layer_size));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;current_layer_size = curr_layer_size;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;id = ++layerId;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;Layer::c_only() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; neurons_size = neurons.size();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; neurons_array = (Neuron**)malloc(neurons_size * </span><span class="c5">sizeof</span><span class="c1">(Neuron*));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; neurons_size; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; neurons_array[i] = neurons.at(i);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; neurons_array[i]-&gt;c_only();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; layer_outputs_array = (</span><span class="c5">double</span><span>&nbsp;*)malloc(neurons_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; neurons.clear();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; layer_outputs.clear();</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h3 class="c39" id="h.49b631p4s7ab"><span class="c4 c15 c18">network.h + network.cpp</span></h3><p class="c17 c12"><span class="c1"></span></p><a id="t.0e2f5c26e78c201378a506b6f5eabe59b5278396"></a><a id="t.40"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">Data/data.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">Data/data_handler.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">Data/common_data.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">neuron.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">layer.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">numeric</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">algorithm</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">thread</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">class</span><span>&nbsp;Network : </span><span class="c5">public</span><span class="c1">&nbsp;Common_data</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span class="c5">public</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;Layer *&gt; layers;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Layer ** layers_array;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;layers_size;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;learning_rate;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;test_performance;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; Network(</span><span class="c5">double</span><span>); </span><span class="c6 c3">// ctor for import</span></p><p class="c0"><span>&nbsp; &nbsp; Network(std::vector&lt;</span><span class="c5">int</span><span>&gt; hidden_layers_specification, </span><span class="c5">int</span><span>, </span><span class="c5">int</span><span>, </span><span class="c5">double</span><span>); </span><span class="c6 c3">// ctor</span></p><p class="c0"><span>&nbsp; &nbsp; ~Network(); </span><span class="c6 c3">// dtor</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span class="c1">&nbsp;c_only();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span>&gt; fprop(Data * d); </span><span class="c6 c3">// forward propagation</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;bprop(std::vector&lt;</span><span class="c5">double</span><span>&gt; deriv_errors); </span><span class="c6 c3">// back propagation</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;update_weights(Data * data); </span><span class="c6 c3">// update weights after bprop</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;fprop_c(Data * d, </span><span class="c5">double</span><span>&nbsp;** output); </span><span class="c6 c3">// forward propagation - c | returns class count</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;bprop_c(</span><span class="c5">double</span><span>&nbsp;* deriv_errors); </span><span class="c6 c3">// back propagation - c</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;update_weights_c(Data * data); </span><span class="c6 c3">// update weights after bprop - c</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;train(); </span><span class="c6 c3">// returns error</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;validate(); </span><span class="c6 c3">// return percentage correct</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;test(); </span><span class="c6 c3">// return percentage correct</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;train_c(); </span><span class="c6 c3">// returns error - c</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;train_c(</span><span class="c5">int</span><span>&nbsp;target); </span><span class="c6 c3">// Train only datasamples with this label | returns error - c</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;validate_c(); </span><span class="c6 c3">// return percentage correct - c</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;test_c(); </span><span class="c6 c3">// return percentage correct - c</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;transfer_activation(</span><span class="c5">double</span><span class="c1">&nbsp;activat);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;predict(Data * data);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;predict_c(Data * data);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;real_predict();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;export_network(</span><span class="c5">char</span><span>&nbsp;** buffer); </span><span class="c6 c3">// returns the size of buffer</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">void</span><span>&nbsp;import_network(</span><span class="c5">char</span><span class="c1">&nbsp;* buffer);</span></p><p class="c0"><span class="c1">};</span></p><p class="c11 c12"><span class="c1"></span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">network.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">Network::~Network() {}</span></p><p class="c0"><span>Network::Network(std::vector&lt;</span><span class="c5">int</span><span>&gt; hidden_layers_specification, </span><span class="c5">int</span><span>&nbsp;input_size, </span><span class="c5">int</span><span>&nbsp;number_of_classes, </span><span class="c5">double</span><span class="c1">&nbsp;learning_rate) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; hidden_layers_specification.size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i == </span><span class="c7">0</span><span class="c1">)</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; layers.push_back(</span><span class="c5">new</span><span class="c1">&nbsp;Layer(input_size, hidden_layers_specification.at(i)));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">else</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; layers.push_back(</span><span class="c5">new</span><span>&nbsp;Layer(layers.at(i - </span><span class="c7">1</span><span class="c1">)-&gt;neurons.size(), hidden_layers_specification.at(i)));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; layers.push_back(</span><span class="c5">new</span><span>&nbsp;Layer(layers.at(layers.size() - </span><span class="c7">1</span><span class="c1">)-&gt;neurons.size(), number_of_classes));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;learning_rate = learning_rate;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span>Network::Network(</span><span class="c5">double</span><span class="c1">&nbsp;learning_rate) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">this</span><span class="c1">-&gt;learning_rate = learning_rate;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span>std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; Network::fprop(Data * d) {</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; inputs = *d-&gt;get_normalized_feature_vector();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers.size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Layer * l = layers.at(i);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; new_inputs;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;neuron_index = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(Neuron * n : l-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;activation = n-&gt;activate(inputs);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;output = </span><span class="c5">this</span><span class="c1">-&gt;transfer_activation(activation);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_inputs.push_back(n-&gt;output);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">//l-&gt;layer_outputs = new_inputs;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; inputs = new_inputs;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;inputs; </span><span class="c6 c3">// output layer outputs</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;Network::fprop_c(Data * d, </span><span class="c5">double</span><span>&nbsp;** output) { </span><span class="c6 c3">// fprop with only c</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;inputs_size = d-&gt;get_feature_array_size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;* inputs = (</span><span class="c5">double</span><span>*)malloc(inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(inputs, d-&gt;get_normalized_feature_array(), inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;layer_index = </span><span class="c7">0</span><span class="c1">; layer_index &lt; layers_size; layer_index++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Layer * l = (layers_array[layer_index]);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;* new_inputs = (</span><span class="c5">double</span><span>&nbsp;*)malloc(l-&gt;neurons_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;neuron_index = </span><span class="c7">0</span><span class="c1">; neuron_index &lt; l-&gt;neurons_size; neuron_index++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Neuron * n = (l-&gt;neurons_array[neuron_index]);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;activation = n-&gt;activate(inputs_size, inputs);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;output = </span><span class="c5">this</span><span class="c1">-&gt;transfer_activation(activation);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_inputs[neuron_index] = n-&gt;output;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; inputs_size = l-&gt;neurons_size;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">//memcpy(l-&gt;layer_outputs_array, new_inputs, inputs_size * sizeof(double));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; inputs = (</span><span class="c5">double</span><span>&nbsp;*)realloc(inputs, inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(inputs, new_inputs, inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; free(new_inputs);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; *output = (</span><span class="c5">double</span><span>&nbsp;*)malloc(inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(*output, inputs, inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(inputs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;inputs_size;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span>&nbsp;Network::bprop(std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; deriv_errors) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = layers.size() - </span><span class="c7">1</span><span>; i &gt;= </span><span class="c7">0</span><span class="c1">; i--)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Layer * l = layers.at(i);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; errors;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i != layers.size() - </span><span class="c7">1</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; l-&gt;neurons.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Neuron *n : layers.at(i + </span><span class="c7">1</span><span class="c1">)-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error += (n-&gt;weights.at(j) * n-&gt;delta);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors.push_back(error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// If is last layer (i == layers.size()-1)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors = deriv_errors;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; l-&gt;neurons.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Neuron * n = l-&gt;neurons.at(j);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;delta = errors[j];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;Network::bprop_c(</span><span class="c5">double</span><span class="c1">&nbsp;* deriv_errors) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* errors;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = layers_size - </span><span class="c7">1</span><span>; i &gt;= </span><span class="c7">0</span><span class="c1">; i--)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Layer * l = (layers_array[i]);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i != layers_size - </span><span class="c7">1</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors = (</span><span class="c5">double</span><span>&nbsp;*)malloc(l-&gt;neurons_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; l-&gt;neurons_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// for each neuron in current layer.</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;k = </span><span class="c7">0</span><span>; k &lt; layers_array[i + </span><span class="c7">1</span><span class="c1">]-&gt;neurons_size; k++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// for each neuron in next layer</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Neuron * n = (layers_array[i + </span><span class="c7">1</span><span class="c1">]-&gt;neurons_array[k]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error += (n-&gt;weights_array[j] * n-&gt;delta);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors[j] = error;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// If is last layer (i == layers.size()-1)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errors = deriv_errors;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; l-&gt;neurons_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Neuron * n = (l-&gt;neurons_array[j]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;delta = errors[j];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(deriv_errors != errors) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(errors);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;Network::update_weights(Data * d) {</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; inputs = *d-&gt;get_normalized_feature_vector();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers.size(); i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i != </span><span class="c7">0</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Neuron *n : layers.at(i - </span><span class="c7">1</span><span class="c1">)-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputs.push_back(n-&gt;output);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span class="c1">&nbsp;(Neuron *n : layers.at(i)-&gt;neurons)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; inputs.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;weights.at(j) += </span><span class="c5">this</span><span class="c1">-&gt;learning_rate * n-&gt;delta * inputs.at(j);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;weights.back() += </span><span class="c5">this</span><span class="c1">-&gt;learning_rate * n-&gt;delta;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; inputs.clear();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;Network::update_weights_c(Data * d) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;inputs_size = d-&gt;get_feature_array_size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;* inputs = (</span><span class="c5">double</span><span>&nbsp;*)malloc(inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(inputs, d-&gt;get_normalized_feature_array(), inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers_size; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(i != </span><span class="c7">0</span><span class="c1">)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputs_size = layers_array[i - </span><span class="c7">1</span><span class="c1">]-&gt;neurons_size;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputs = (</span><span class="c5">double</span><span>&nbsp;*)realloc(inputs, inputs_size * </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span>; j &lt; layers_array[i - </span><span class="c7">1</span><span class="c1">]-&gt;neurons_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Neuron * n = (layers_array[i - </span><span class="c7">1</span><span class="c1">]-&gt;neurons_array[j]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputs[i] = n-&gt;output;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; layers_array[i]-&gt;neurons_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Neuron * n = (layers_array[i]-&gt;neurons_array[j]);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;k = </span><span class="c7">0</span><span class="c1">; k &lt; inputs_size; k++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;weights_array[k] += </span><span class="c5">this</span><span class="c1">-&gt;learning_rate * n-&gt;delta * inputs[k];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;weights_array[inputs_size] += </span><span class="c5">this</span><span class="c1">-&gt;learning_rate * n-&gt;delta;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(inputs);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;Network::train() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;sum_error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; deriv_error;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;output_vector_size = </span><span class="c5">this</span><span>-&gt;training_data-&gt;at(</span><span class="c7">0</span><span class="c1">)-&gt;get_class_vector()-&gt;size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; output_vector_size; i++) { deriv_error.push_back(</span><span class="c7">0.0</span><span class="c1">); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Data * d : *</span><span class="c5">this</span><span class="c1">-&gt;training_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; outputs = fprop(d);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;</span><span class="c5">int</span><span class="c1">&gt; expected = *(d-&gt;get_class_vector());</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;tmp_sum_error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; outputs.size(); j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_sum_error += pow((</span><span class="c5">double</span><span>)expected.at(j) - outputs.at(j), </span><span class="c7">2</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] += (</span><span class="c5">double</span><span class="c1">)expected.at(j) - outputs.at(j);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; sum_error += tmp_sum_error;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error.at(j) /= </span><span class="c5">this</span><span class="c1">-&gt;training_data-&gt;size();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error.at(j) *= </span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; bprop(deriv_error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; update_weights(d);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error.at(j) = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;sum_error;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;Network::validate() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;num_correct = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;count = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Data * d : *</span><span class="c5">this</span><span class="c1">-&gt;validation_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = predict(d);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(d-&gt;get_class_vector()-&gt;at(index) == </span><span class="c7">1</span><span class="c1">) { num_correct++; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;num_correct / count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;Network::test() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;num_correct = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;count = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Data * d : *</span><span class="c5">this</span><span class="c1">-&gt;test_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = predict(d);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(d-&gt;get_class_vector()-&gt;at(index) == </span><span class="c7">1</span><span class="c1">) { num_correct++; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;num_correct / count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;Network::train_c() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;sum_error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;output_vector_size = </span><span class="c5">this</span><span>-&gt;training_data-&gt;at(</span><span class="c7">0</span><span class="c1">)-&gt;get_class_array_size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;* deriv_error = (</span><span class="c5">double</span><span>&nbsp;*)calloc(output_vector_size, </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Data * d : *</span><span class="c5">this</span><span class="c1">-&gt;training_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* outputs;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fprop_c(d, &amp;outputs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;* expected = d-&gt;get_class_array();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;tmp_sum_error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;exp = (</span><span class="c5">double</span><span class="c1">)expected[j];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;out = outputs[j];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_sum_error += pow(exp - out, </span><span class="c7">2</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] += exp - out;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; sum_error += tmp_sum_error;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] /= </span><span class="c5">this</span><span class="c1">-&gt;training_data-&gt;size();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] *= </span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; bprop_c(deriv_error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; update_weights_c(d);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; free(outputs);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(deriv_error);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;sum_error;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span>&nbsp;Network::train_c(</span><span class="c5">int</span><span class="c1">&nbsp;target) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;sum_error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;output_vector_size = </span><span class="c5">this</span><span>-&gt;training_data-&gt;at(</span><span class="c7">0</span><span class="c1">)-&gt;get_class_array_size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;* deriv_error = (</span><span class="c5">double</span><span>&nbsp;*)calloc(output_vector_size, </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Data * d : *</span><span class="c5">this</span><span class="c1">-&gt;training_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(d-&gt;get_label() != target) { </span><span class="c5">continue</span><span>; } </span><span class="c6 c3">// Skip anything which does not match the target label</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* outputs;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fprop_c(d, &amp;outputs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;* expected = d-&gt;get_class_array();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;tmp_sum_error = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;exp = (</span><span class="c5">double</span><span class="c1">)expected[j];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;out = outputs[j];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_sum_error += pow(exp - out, </span><span class="c7">2</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] += exp - out;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; sum_error += tmp_sum_error;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] /= </span><span class="c5">this</span><span class="c1">-&gt;training_data-&gt;size();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] *= </span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; bprop_c(deriv_error);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; update_weights_c(d);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; output_vector_size; j++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deriv_error[j] = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; free(outputs);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(deriv_error);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;sum_error;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;Network::validate_c() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;num_correct = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;count = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Data * d : *</span><span class="c5">this</span><span class="c1">-&gt;validation_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = predict_c(d);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(d-&gt;get_class_array()[index] == </span><span class="c7">1</span><span class="c1">) { num_correct++; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;num_correct / count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">double</span><span class="c1">&nbsp;Network::test_c() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;num_correct = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;count = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Data * d : *</span><span class="c5">this</span><span class="c1">-&gt;test_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;index = predict_c(d);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(d-&gt;get_class_array()[index] == </span><span class="c7">1</span><span class="c1">) { num_correct++; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; test_performance = (num_correct / count);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;num_correct / count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">double</span><span>&nbsp;Network::transfer_activation(</span><span class="c5">double</span><span class="c1">&nbsp;activat) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">1.0</span><span>&nbsp;/ (</span><span class="c7">1.0</span><span class="c1">&nbsp;+ exp(-activat));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;Network::predict(Data * data) {</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">double</span><span class="c1">&gt; outputs = fprop(data);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;std::distance(outputs.begin(), std::max_element(outputs.begin(), outputs.end()));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;Network::predict_c(Data * data) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* outputs;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;class_count = fprop_c(data, &amp;outputs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;max_ind = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;max = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = class_count - </span><span class="c7">1</span><span>; i &gt;= </span><span class="c7">0</span><span class="c1">; i--) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(outputs[i] &gt; max) { max_ind = i; max = outputs[i]; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(outputs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;max_ind;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;Network::real_predict()</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// A map to predictions and the amout of times they were made</span></p><p class="c0"><span>&nbsp; &nbsp; std::map&lt;</span><span class="c5">int</span><span>, </span><span class="c5">double</span><span class="c1">&gt; predictions;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;numCorrect = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;count = </span><span class="c7">0.0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;size = prediction_data-&gt;size();</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(Data *data : *</span><span class="c5">this</span><span class="c1">-&gt;prediction_data)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; Data_Handler::print_loading(</span><span class="c5">false</span><span class="c1">, count, size);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;* outputs;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;outputs_size = fprop_c(data, &amp;outputs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; outputs_size; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(count == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predictions[i] = outputs[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predictions[i] += outputs[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\r &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\r&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;total = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">auto</span><span class="c1">&nbsp;tpl : predictions) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; total += tpl.second;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;top_guessed = predictions.begin()-&gt;first;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;top_guessed_count = predictions.begin()-&gt;second;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Prediction table: \n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">auto</span><span class="c1">&nbsp;tpl : predictions) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t%u) %.2f%%\n&quot;</span><span>, tpl.first, (</span><span class="c5">float</span><span>)(tpl.second * </span><span class="c7">100.0</span><span class="c1">&nbsp;/ total));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(tpl.second &gt; top_guessed_count) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_guessed = tpl.first;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_guessed_count = tpl.second;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;top_guessed;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span class="c1">&nbsp;Network::c_only() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; layers_size = layers.size();</span></p><p class="c0"><span>&nbsp; &nbsp; layers_array = (Layer **)malloc(layers_size * </span><span class="c5">sizeof</span><span class="c1">(Layer *));</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers_size; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; layers_array[i] = (layers.at(i));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; layers.clear();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers_size; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Layer * l = layers_array[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; l-&gt;c_only();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Network is now C only!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;Network::export_network(</span><span class="c5">char</span><span class="c1">&nbsp;** buffer) {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Now exporting...\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">unsigned</span><span>&nbsp;</span><span class="c5">long</span><span>&nbsp;</span><span class="c5">long</span><span>&nbsp;</span><span class="c5">int</span><span>&nbsp;total_size = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; total_size += </span><span class="c5">sizeof</span><span class="c1">(total_size);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; total_size += </span><span class="c5">sizeof</span><span>(</span><span class="c5">double</span><span>); </span><span class="c6 c3">// network_accuracy</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t layer_size = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t prev_layer_size = layers_array[</span><span class="c7">0</span><span>]-&gt;neurons_array[</span><span class="c7">0</span><span>]-&gt;weights_array_size-</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; total_size += </span><span class="c5">sizeof</span><span class="c1">(layers_size);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; total_size += </span><span class="c5">sizeof</span><span class="c1">(prev_layer_size);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers_size; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; layer_size = layers_array[i]-&gt;current_layer_size;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; total_size += </span><span class="c7">1</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(layer_size); </span><span class="c6 c3">// layer_size</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; layers_array[i]-&gt;neurons_size; j++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Neuron * n = layers_array[i]-&gt;neurons_array[j];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_size += n-&gt;raw_size();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; prev_layer_size = layer_size;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; total_size += </span><span class="c7">1</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(prev_layer_size); </span><span class="c6 c3">// prev_layer_size</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Export size: %llu\n&quot;</span><span class="c1">, total_size);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; *buffer = (</span><span class="c5">char</span><span>&nbsp;*)calloc(total_size, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t current_size_index = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(*buffer, &amp;total_size, </span><span class="c5">sizeof</span><span class="c1">(total_size));</span></p><p class="c0"><span>&nbsp; &nbsp; current_size_index += </span><span class="c5">sizeof</span><span class="c1">(total_size);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;network_accuracy = </span><span class="c5">this</span><span class="c1">-&gt;test_performance;</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(*buffer + current_size_index, &amp;network_accuracy, </span><span class="c5">sizeof</span><span class="c1">(network_accuracy));</span></p><p class="c0"><span>&nbsp; &nbsp; current_size_index += </span><span class="c5">sizeof</span><span class="c1">(network_accuracy);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; layer_size = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; prev_layer_size = layers_array[</span><span class="c7">0</span><span>]-&gt;neurons_array[</span><span class="c7">0</span><span>]-&gt;weights_array_size - </span><span class="c7">1</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint32_t layer_sizes = layers_size;</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(*buffer + current_size_index, &amp;layer_sizes, </span><span class="c5">sizeof</span><span class="c1">(layer_sizes));</span></p><p class="c0"><span>&nbsp; &nbsp; current_size_index += </span><span class="c7">1</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(layer_sizes); </span><span class="c6 c3">// layer_sizes</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(*buffer + current_size_index, &amp;prev_layer_size, </span><span class="c5">sizeof</span><span class="c1">(prev_layer_size));</span></p><p class="c0"><span>&nbsp; &nbsp; current_size_index += </span><span class="c7">1</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(uint32_t); </span><span class="c6 c3">// prevlayerSize</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layers_size; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; layer_size = layers_array[i]-&gt;current_layer_size;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(*buffer + current_size_index, &amp;layer_size, </span><span class="c5">sizeof</span><span class="c1">(layer_size));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; current_size_index += </span><span class="c7">1</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(uint32_t); </span><span class="c6 c3">// layerSize</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; layers_array[i]-&gt;neurons_size; j++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Neuron * n = layers_array[i]-&gt;neurons_array[j];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_size_index += n-&gt;export_neuron((*buffer) + current_size_index);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; prev_layer_size = layer_size;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(*buffer + current_size_index, &amp;prev_layer_size, </span><span class="c5">sizeof</span><span class="c1">(prev_layer_size));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; current_size_index += </span><span class="c7">1</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(uint32_t); </span><span class="c6 c3">// prevlayerSize</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(current_size_index != total_size) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Total size does not match!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/*FILE * f;</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; errno_t err = fopen_s(&amp;f, &quot;Network_Output.net&quot;, &quot;wb&quot;);</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; fwrite(*buffer, sizeof(char), total_size, f);</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; fclose(f);*/</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Successfully exported network to buffer!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;total_size;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">void</span><span>&nbsp;Network::import_network(</span><span class="c5">char</span><span class="c1">&nbsp;* buffer) {</span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t current_size_index = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">unsigned</span><span>&nbsp;</span><span class="c5">long</span><span>&nbsp;</span><span class="c5">long</span><span>&nbsp;total_size = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(&amp;total_size, buffer, </span><span class="c5">sizeof</span><span class="c1">(total_size));</span></p><p class="c0"><span>&nbsp; &nbsp; current_size_index += </span><span class="c5">sizeof</span><span class="c1">(total_size);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;network_accuracy = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(&amp;network_accuracy, buffer + current_size_index, </span><span class="c5">sizeof</span><span class="c1">(network_accuracy));</span></p><p class="c0"><span>&nbsp; &nbsp; current_size_index += </span><span class="c5">sizeof</span><span class="c1">(network_accuracy);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t layer_sizes = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(&amp;layer_sizes, buffer + current_size_index, </span><span class="c5">sizeof</span><span class="c1">(layer_sizes));</span></p><p class="c0"><span>&nbsp; &nbsp; current_size_index += </span><span class="c5">sizeof</span><span class="c1">(layer_sizes);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t layer_size = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; uint32_t prev_layer_size = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(&amp;prev_layer_size, buffer + current_size_index, </span><span class="c5">sizeof</span><span class="c1">(prev_layer_size));</span></p><p class="c0"><span>&nbsp; &nbsp; current_size_index += </span><span class="c7">1</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(uint32_t); </span><span class="c6 c3">// prev_layer_size</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">//inputLayer = new InputLayer(0, prev_layer_size, true);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(layers_array != NULL) { free(layers_array); }</span></p><p class="c0"><span>&nbsp; &nbsp; layers_size = layer_sizes; </span><span class="c6 c3">// netw-&gt;layers_size := layer_size</span></p><p class="c0"><span>&nbsp; &nbsp; layers_array = (Layer**)malloc(layers_size * </span><span class="c5">sizeof</span><span class="c1">(Layer*));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; layer_sizes; i++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;layer_size, buffer + current_size_index, </span><span class="c5">sizeof</span><span class="c1">(layer_size));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; current_size_index += </span><span class="c7">1</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(uint32_t); </span><span class="c6 c3">// layerSize</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; Layer * layer = </span><span class="c5">new</span><span>&nbsp;Layer(prev_layer_size, layer_size, </span><span class="c5">true</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;j = </span><span class="c7">0</span><span class="c1">; j &lt; layer-&gt;neurons_size; j++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Neuron * n = layer-&gt;neurons_array[j];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;import_neuron(prev_layer_size, layer_size, buffer + current_size_index);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_size_index += n-&gt;raw_size();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; layers_array[i] = layer;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;prev_layer_size, buffer + current_size_index, </span><span class="c5">sizeof</span><span class="c1">(prev_layer_size));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; current_size_index += </span><span class="c7">1</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(uint32_t); </span><span class="c6 c3">// prev_layer_size</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(current_size_index != total_size) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Import sizes do not match!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Successfully imported network with accuracy: %.4f!\n&quot;</span><span class="c1">, network_accuracy);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h3 class="c39" id="h.xbjj3bx4h2xd"><span class="c4 c15 c18">CommandLineFunctions.h + CommandLineFunctions.cpp</span></h3><p class="c17 c12"><span class="c1"></span></p><a id="t.ac7b0de75caadeb7c3cbb854a2e7af4d5832857c"></a><a id="t.41"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#pragma</span><span class="c1">&nbsp;once</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">//#ifndef __CommandLineFunctions</span></p><p class="c0"><span class="c6 c3">//#define __CommandLineFunctions</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">iostream</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">sys/stat.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">time.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">vector</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">map</span><span class="c2">&gt;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">AudioFile.h</span><span class="c2">&quot;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">FFT.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">Neural_Network/network.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">/// Globals</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Reference to global neural network</span></p><p class="c0"><span class="c5">static</span><span class="c1">&nbsp;Network * network;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Reference to global dataset</span></p><p class="c0"><span class="c5">static</span><span class="c1">&nbsp;Data_Handler * data_handler;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Global strings (character arrays)</span></p><p class="c0"><span class="c5">static</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;DataSetLabel[</span><span class="c7">128</span><span>] = { </span><span class="c7">0</span><span class="c1">&nbsp;};</span></p><p class="c0"><span class="c5">static</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;OutputPath[</span><span class="c7">128</span><span>] = { </span><span class="c7">0</span><span class="c1">&nbsp;};</span></p><p class="c0"><span class="c5">static</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;fn_label_map[</span><span class="c7">128</span><span class="c1">];</span></p><p class="c0"><span class="c5">static</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;fn_data_map[</span><span class="c7">128</span><span class="c1">];</span></p><p class="c0"><span class="c5">static</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;fn_vectors[</span><span class="c7">128</span><span class="c1">];</span></p><p class="c0"><span class="c5">static</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;fn_labels[</span><span class="c7">128</span><span class="c1">];</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">/// Helping_Funcs</span></p><p class="c0"><span class="c1">std::string get_current_dir();</span></p><p class="c0"><span class="c5">inline</span><span>&nbsp;</span><span class="c5">bool</span><span>&nbsp;file_exists(</span><span class="c5">const</span><span class="c1">&nbsp;std::string&amp; name);</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;getFileSize(FILE * f); </span><span class="c6 c3">// This will move the file pointer to SEEK_SET + 0</span></p><p class="c0"><span class="c1">uint32_t convert_to_big_endian(uint32_t b);</span></p><p class="c0"><span class="c1">uint32_t convert_to_little_endian(uint32_t b);</span></p><p class="c0"><span class="c6 c3">// Change the last character of a string into a null byte (if it&#39;s a newline).</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;fix_fgets(</span><span class="c5">char</span><span class="c1">&nbsp;* inp);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Check if an input matches a command</span></p><p class="c0"><span class="c5">bool</span><span>&nbsp;cmpcommand(</span><span class="c5">char</span><span>&nbsp;* inp, </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">char</span><span class="c1">&nbsp;* command);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Count the amount of arguments given in an input command (as &#39; &#39; delimiter)</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;CountCommandArgs(</span><span class="c5">char</span><span class="c1">&nbsp;* command);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Get command input argument at index as place it into output (also allocate memory for output)</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;GetCommandArg(</span><span class="c5">char</span><span>&nbsp;* command, </span><span class="c5">int</span><span>&nbsp;index, </span><span class="c5">char</span><span class="c1">&nbsp;** output);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">/// Command_Line_Commands</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Update file paths using the user specified outputpath and the dataset global name</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;UpdateFilePaths();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Change the path of the output directory</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ChangeOutputPath();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Change the dataset&#39;s name</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ChangeDataSetName();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Count how many labels exist in the label map file.</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;getExistingLabelsCount(uint8_t * existing_labels, FILE * fLabelMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Proccess &#39;list&#39; commands</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;ListView(</span><span class="c5">char</span><span class="c1">&nbsp;* command);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Prints the classes and their labels, which are stored in the label map file.</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ViewClassifications();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Prints the file paths of each file in the dataset sorted by their labels.</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ViewDataFiles();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Add an item to a dataset</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;AddDataToSet();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Initialize a new dataset</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;Initialize();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// predict the label of a file using the Classifier</span></p><p class="c0"><span class="c6 c3">/*</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; The predict function can take arguments such as:</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; 1) a file path.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; The first input can be the relative path to a vectors file which you want to use instead of processing a wav file into a vectors file.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; 2) the &#39;-f&#39; argument.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; This is passed into the classifier as &#39;fast&#39; which tells the program to only check some of the data points (arbitrarily) and not all of them.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; This obviously results in faster execution time (10x faster - since we take only a tenth of the vectors), but there is a penalty to the accuracy of the results. Though the final prediction is still usually correct.</span></p><p class="c0"><span class="c6 c3">*/</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;Predict(</span><span class="c5">char</span><span class="c1">&nbsp;* command);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c3 c6">// Initialize Network of size / model</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;InitNetwork(</span><span class="c5">char</span><span class="c1">&nbsp;* command);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Load an existing network</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;LoadNetwork(</span><span class="c5">char</span><span class="c1">&nbsp;* command);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Export the loaded network</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;ExportNetwork(</span><span class="c5">char</span><span class="c1">&nbsp;* command);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Train the loaded network</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;TrainNetwork(</span><span class="c5">char</span><span class="c1">&nbsp;* command);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Validate the loaded network</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ValidateNetwork();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Train and Export the network</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;AFKTrain();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Load dataset into data_handler</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;LoadDataHandler();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Load predict file</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;LoadPredictFile(</span><span class="c5">char</span><span class="c1">&nbsp;* command);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Exit</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ExitProgram();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">enum</span><span class="c1">&nbsp;HelpMenus {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; NoHelpMenu,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; GeneralHelpMenu,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; DataSetHelpMenu,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; PreidctionHelpMenu,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; NetworkHelpMenu,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; AllHelpMenu</span></p><p class="c0"><span class="c1">};</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Show help menu</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;Help(HelpMenus helpMenu);</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;Help(</span><span class="c5">char</span><span class="c1">&nbsp;* command);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Gets user input and compares it to valid commands</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ProccessCommands();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c30">//#endif // !__CommandLineFunctions</span></p></td></tr><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">CommandLineFunctions.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">direct.h</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#define</span><span class="c1">&nbsp;GetCurrentDir _getcwd</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#define</span><span>&nbsp;MaximumLabelLength </span><span class="c3 c15 c7">255</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">std::string get_current_dir() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;buff[FILENAME_MAX];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; GetCurrentDir(buff, FILENAME_MAX);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::string current_working_dir(buff);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;current_working_dir;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">inline</span><span>&nbsp;</span><span class="c5">bool</span><span>&nbsp;file_exists(</span><span class="c5">const</span><span class="c1">&nbsp;std::string&amp; name) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">struct</span><span class="c1">&nbsp;stat buffer;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(stat(name.c_str(), &amp;buffer) == </span><span class="c7">0</span><span class="c1">);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;getFileSize(FILE * f) { </span><span class="c6 c3">// This will move the file pointer to SEEK_SET + 0</span></p><p class="c0"><span>&nbsp; &nbsp; fseek(f, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;size = ftell(f);</span></p><p class="c0"><span>&nbsp; &nbsp; fseek(f, </span><span class="c7">0</span><span class="c1">, SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;size;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">uint32_t convert_to_big_endian(uint32_t b) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">unsigned</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;bytes[</span><span class="c7">4</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(bytes, &amp;b, </span><span class="c5">sizeof</span><span class="c1">(b));</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(uint32_t)((bytes[</span><span class="c7">0</span><span>] &lt;&lt; </span><span class="c7">24</span><span>) | (bytes[</span><span class="c7">1</span><span>] &lt;&lt; </span><span class="c7">16</span><span>) | (bytes[</span><span class="c7">2</span><span>] &lt;&lt; </span><span class="c7">8</span><span>) | (bytes[</span><span class="c7">3</span><span class="c1">]));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">uint32_t convert_to_little_endian(uint32_t b) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">unsigned</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;bytes[</span><span class="c7">4</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(bytes, &amp;b, </span><span class="c5">sizeof</span><span class="c1">(b));</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;(uint32_t)((bytes[</span><span class="c7">0</span><span>] &lt;&lt; </span><span class="c7">24</span><span>) | (bytes[</span><span class="c7">1</span><span>] &lt;&lt; </span><span class="c7">16</span><span>) | (bytes[</span><span class="c7">2</span><span>] &lt;&lt; </span><span class="c7">8</span><span>) | (bytes[</span><span class="c7">3</span><span class="c1">]));</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Change the last character of a string into a null byte (if it&#39;s a newline).</span></p><p class="c0"><span class="c5">void</span><span>&nbsp;fix_fgets(</span><span class="c5">char</span><span class="c1">&nbsp;* inp) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(inp[strlen(inp) - </span><span class="c7">1</span><span>] == </span><span class="c14">&#39;\n&#39;</span><span>) { inp[strlen(inp) - </span><span class="c7">1</span><span>] = </span><span class="c50">0x0</span><span class="c1">; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Check if an input matches a command</span></p><p class="c0"><span class="c5">bool</span><span>&nbsp;cmpcommand(</span><span class="c5">char</span><span>&nbsp;* inp, </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(memcmp(inp, command, strlen(command)) == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;fin_char = inp[strlen(command)];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// the format specified is that a command ends with one of the following four characters.</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(fin_char == </span><span class="c14">&#39; &#39;</span><span>&nbsp;|| fin_char == </span><span class="c14">&#39;\t&#39;</span><span>&nbsp;|| fin_char == </span><span class="c14">&#39;\n&#39;</span><span>&nbsp;|| fin_char == </span><span class="c14">&#39;</span><span>\</span><span class="c7">0</span><span class="c14">&#39;</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">true</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Count the amount of arguments given in an input command (as &#39; &#39; delimiter)</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;CountCommandArgs(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* tmpCommand = (</span><span class="c5">char</span><span>&nbsp;*)malloc((strlen(command) + </span><span class="c7">1</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(tmpCommand, command, strlen(command) + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;delim[</span><span class="c7">2</span><span>] = </span><span class="c14">&quot; &quot;</span><span>; </span><span class="c6 c3">// delimiter</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* next_tok;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* tok = strtok_s(tmpCommand, delim, &amp;next_tok);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(tok != NULL) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">//printf(&quot;Arg #%d: &#39;%s&#39;\n&quot;, count, tok);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; tok = strtok_s(NULL, delim, &amp;next_tok);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(tmpCommand);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Get command input argument at index as place it into output (also allocate memory for output)</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;GetCommandArg(</span><span class="c5">char</span><span>&nbsp;* command, </span><span class="c5">int</span><span>&nbsp;index, </span><span class="c5">char</span><span class="c1">&nbsp;** output) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* tmpCommand = (</span><span class="c5">char</span><span>&nbsp;*)malloc((strlen(command) + </span><span class="c7">1</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(tmpCommand, command, strlen(command) + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;delim[</span><span class="c7">2</span><span>] = </span><span class="c14">&quot; &quot;</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* next_tok;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* tok = strtok_s(tmpCommand, delim, &amp;next_tok);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(tok != NULL &amp;&amp; count &lt; index) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">//printf(&quot;Arg #%d: &#39;%s&#39;\n&quot;, count, tok);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; tok = strtok_s(NULL, delim, &amp;next_tok);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(index &gt; count) { free(tmpCommand); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; *output = (</span><span class="c5">char</span><span>*)malloc((strlen(tok) + </span><span class="c7">1</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; memcpy(*output, tok, strlen(tok) + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(tmpCommand);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Update file paths using the user specified outputpath and the dataset global name</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;UpdateFilePaths() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">/*fn_label_map = (char*)calloc(128, sizeof(char));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; fn_data_map = (char*)calloc(128, sizeof(char));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; fn_vectors = (char*)calloc(128, sizeof(char));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; fn_labels = (char*)calloc(128, sizeof(char));*/</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; sprintf_s(fn_label_map, </span><span class="c7">128</span><span>, </span><span class="c14">&quot;%s/%s.label_map&quot;</span><span class="c1">, OutputPath, DataSetLabel);</span></p><p class="c0"><span>&nbsp; &nbsp; sprintf_s(fn_data_map, </span><span class="c7">128</span><span>, </span><span class="c14">&quot;%s/%s.data_map&quot;</span><span class="c1">, OutputPath, DataSetLabel);</span></p><p class="c0"><span>&nbsp; &nbsp; sprintf_s(fn_vectors, </span><span class="c7">128</span><span>, </span><span class="c14">&quot;%s/%s.vectors&quot;</span><span class="c1">, OutputPath, DataSetLabel);</span></p><p class="c0"><span>&nbsp; &nbsp; sprintf_s(fn_labels, </span><span class="c7">128</span><span>, </span><span class="c14">&quot;%s/%s.labels&quot;</span><span class="c1">, OutputPath, DataSetLabel);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ChangeOutputPath() {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# Please choose an output path for generated files.\n&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; memset(OutputPath, </span><span class="c50">0x0</span><span>, </span><span class="c7">128</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; fgets(OutputPath, </span><span class="c7">127</span><span class="c1">, stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fix_fgets(OutputPath);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; UpdateFilePaths();</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# The data set will output to (vectors file example): &#39;%s&#39;\n&quot;</span><span class="c1">, fn_vectors);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ChangeDataSetName() {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# Please choose a name for this data set.\n&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; memset(DataSetLabel, </span><span class="c50">0x0</span><span>, </span><span class="c7">128</span><span>&nbsp;* </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; fgets(DataSetLabel, </span><span class="c7">127</span><span class="c1">, stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fix_fgets(DataSetLabel);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; UpdateFilePaths();</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# The data set will output to (vectors file example): &#39;%s&#39;\n&quot;</span><span class="c1">, fn_vectors);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Count how many labels exist in the label map file.</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;getExistingLabelsCount(uint8_t * existing_labels, FILE * fLabelMap) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;existing_labels_count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_pair[MaximumLabelLength + </span><span class="c7">2</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(fread_s(label_pair, (MaximumLabelLength + </span><span class="c7">2</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), MaximumLabelLength + </span><span class="c7">1</span><span class="c1">, fLabelMap)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint8_t label_key = label_pair[</span><span class="c7">0</span><span class="c1">];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; existing_labels[existing_labels_count] = label_key;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; existing_labels_count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;existing_labels_count;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Prints the classes and their labels, which are stored in the label map file.</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ViewClassifications() {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# The following classifications exist in the data set: \n\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint8_t existing_labels[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; uint8_t existing_labels_count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// A file with a map (dictionary) of the label numbers (0-255) and their corresponding &quot;human&quot; definition.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errLabelMap;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// A file with a map of the actual wav files which are in the vectors file.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fDataMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errDataMap;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!file_exists(fn_label_map)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# As you can clearly see, there are none.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errDataMap || errLabelMap) { printf(</span><span class="c14">&quot;# Could not open data or label map files!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errDataMap || errLabelMap) { printf(</span><span class="c14">&quot;# Could not open data or label map files!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fseek(fDataMap, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// Every 256bytes are one pair in the dictionary. Starting at byte 0.</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_pair[MaximumLabelLength + </span><span class="c7">2</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(fread_s(label_pair, (MaximumLabelLength + </span><span class="c7">2</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), MaximumLabelLength + </span><span class="c7">1</span><span class="c1">, fLabelMap)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t label_key = label_pair[</span><span class="c7">0</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; %d | %s\n&quot;</span><span>, label_key, label_pair + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_labels[existing_labels_count] = label_key;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_labels_count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(existing_labels_count == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# As you can clearly see, there are none.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fDataMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Prints the file paths of each file in the dataset sorted by their labels.</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ViewDataFiles() {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;# The following files are in the data set: \n\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; uint8_t existing_labels[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; uint8_t existing_labels_count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// A file with a map (dictionary) of the label numbers (0-255) and their corresponding &quot;human&quot; definition.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errLabelMap;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c6 c3">// A file with a map of the actual wav files which are in the vectors file.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fDataMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errDataMap;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!file_exists(fn_data_map)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# As you can clearly see, there are none.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errDataMap || errLabelMap) { printf(</span><span class="c14">&quot;# Could not open data or label map files!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errDataMap || errLabelMap) { printf(</span><span class="c14">&quot;# Could not open data or label map files!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;size = getFileSize(fDataMap); fseek(fDataMap, </span><span class="c7">0</span><span class="c1">, SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* file_data = (</span><span class="c5">char</span><span>*)malloc(size + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;read_count = fread_s(file_data, size, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), size, fDataMap);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(read_count == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Error reading file.\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::map&lt;uint8_t, </span><span class="c5">char</span><span class="c1">*&gt; label_data_map;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// Every 256bytes are one pair in the dictionary. Starting at byte 0.</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_pair[MaximumLabelLength + </span><span class="c7">2</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(fread_s(label_pair, (MaximumLabelLength + </span><span class="c7">2</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), MaximumLabelLength + </span><span class="c7">1</span><span class="c1">, fLabelMap)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t label_key = label_pair[</span><span class="c7">0</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">//existing_labels[existing_labels_count] = label_key;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">//label_data_map.insert(std::pair&lt;uint8_t,char*&gt;(label_key, label_pair + 1));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&gt; %u | %s\n&quot;</span><span>, label_key, label_pair + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* live_data = file_data;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;pos = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span class="c1">&nbsp;(pos &lt; size) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t data_key = live_data[pos];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(data_key == label_key) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t|--&gt; %s\n&quot;</span><span>, live_data + pos + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos += </span><span class="c7">2</span><span>&nbsp;+ strlen(live_data + pos + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_labels_count++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(existing_labels_count == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# As you can clearly see, there are none.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; free(file_data);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fDataMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;ListView(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(CountCommandArgs(command) &gt; </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* arg; GetCommandArg(command, </span><span class="c7">0</span><span class="c1">, &amp;arg);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(arg, </span><span class="c14">&quot;-f&quot;</span><span class="c1">)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ViewDataFiles();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span>&nbsp;(cmpcommand(arg, </span><span class="c14">&quot;-c&quot;</span><span class="c1">)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ViewClassifications();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Unknown argument!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; free(arg);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Unknown argument!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;AddDataToSet() {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::string WAV_File_Path;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# Path for WAV file: &quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; std::cout &lt;&lt; get_current_dir() &lt;&lt; </span><span class="c14">&quot;\\&quot;</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; WAV_File_Path = get_current_dir() + </span><span class="c14">&quot;\\&quot;</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;WAV_File_Path_buffer[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; fgets(WAV_File_Path_buffer, </span><span class="c5">sizeof</span><span class="c1">(WAV_File_Path_buffer), stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fix_fgets(WAV_File_Path_buffer);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; strlen(WAV_File_Path_buffer); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; WAV_File_Path += WAV_File_Path_buffer[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; AudioFile&lt;</span><span class="c5">double</span><span>&gt; * audioFile = </span><span class="c5">new</span><span>&nbsp;AudioFile&lt;</span><span class="c5">double</span><span class="c1">&gt;();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(audioFile-&gt;load(WAV_File_Path)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# Loaded File!&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; audioFile-&gt;printSummary();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# CH: &quot;</span><span>&nbsp;&lt;&lt; audioFile-&gt;getNumChannels() &lt;&lt; </span><span class="c14">&quot; | &quot;</span><span>&nbsp;&lt;&lt; </span><span class="c14">&quot;SAMP: &quot;</span><span class="c1">&nbsp;&lt;&lt; audioFile-&gt;getNumSamplesPerChannel() * audioFile-&gt;getNumChannels() &lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; audioFile-&gt;ConcactChannels();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; FFT * FT = </span><span class="c5">new</span><span class="c1">&nbsp;FFT();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint8_t channelInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;sampInd = </span><span class="c7">0</span><span class="c1">; sampInd &lt; audioFile-&gt;getNumSamplesPerChannel(); sampInd++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FT-&gt;AppendToWave(audioFile-&gt;samples[channelInd][sampInd]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;actInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;\t&quot;</span><span>&nbsp;&lt;&lt; ++actInd &lt;&lt; </span><span class="c14">&quot;) &quot;</span><span>&nbsp;&lt;&lt; </span><span class="c14">&quot;Loaded \&quot;&quot;</span><span>&nbsp;&lt;&lt; WAV_File_Path &lt;&lt; </span><span class="c14">&quot;\&quot; into Fourier Transform!&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint32_t sample_count = audioFile-&gt;getNumSamplesPerChannel() / audioFile-&gt;getSampleRate();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// A file with a map (dictionary) of the label numbers (0-255) and their corresponding &quot;human&quot; definition.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// A file with a map of the actual wav files which are in the vectors file.</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FILE * fDataMap;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errno_t errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; errno_t errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errDataMap || errLabelMap) { printf(</span><span class="c14">&quot;# Could not open Data or Label map files!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// Create new vector and label files, or use existing ones and change the sample count</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FILE * fVect;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; FILE * fLabel;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!file_exists(fn_vectors)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno_t errVects = fopen_s(&amp;fVect, fn_vectors, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno_t errLabels = fopen_s(&amp;fLabel, fn_labels, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t intro[</span><span class="c7">3</span><span>] = { convert_to_big_endian(</span><span class="c7">2612</span><span>), convert_to_big_endian(sample_count), convert_to_big_endian(</span><span class="c7">4000</span><span class="c1">) };</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t introLabels[</span><span class="c7">2</span><span>] = { convert_to_big_endian(</span><span class="c7">2211</span><span class="c1">), convert_to_big_endian(sample_count) };</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite((</span><span class="c5">char</span><span>*)intro, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c7">4</span><span>&nbsp;* </span><span class="c5">sizeof</span><span class="c1">(uint32_t), fVect);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite((</span><span class="c5">char</span><span>*)introLabels, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c7">2</span><span>&nbsp;* </span><span class="c5">sizeof</span><span class="c1">(uint32_t), fLabel);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno_t errVects = fopen_s(&amp;fVect, fn_vectors, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno_t errLabels = fopen_s(&amp;fLabel, fn_labels, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t old_sample_count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fLabel, </span><span class="c5">sizeof</span><span class="c1">(uint32_t), SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fread_s(&amp;old_sample_count, </span><span class="c5">sizeof</span><span>(old_sample_count), </span><span class="c5">sizeof</span><span>(uint32_t), </span><span class="c7">1</span><span class="c1">, fLabel);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count = convert_to_little_endian(old_sample_count);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count += sample_count;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count = convert_to_big_endian(old_sample_count);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fLabel, </span><span class="c5">sizeof</span><span class="c1">(uint32_t), SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fVect, </span><span class="c5">sizeof</span><span class="c1">(uint32_t), SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(&amp;old_sample_count, </span><span class="c5">sizeof</span><span>(uint32_t), </span><span class="c7">1</span><span class="c1">, fLabel);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(&amp;old_sample_count, </span><span class="c5">sizeof</span><span>(uint32_t), </span><span class="c7">1</span><span class="c1">, fVect);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fLabel, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fVect, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Please enter the label (as uint8) for this sound.\n&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_buffer[</span><span class="c7">16</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fgets(label_buffer, </span><span class="c5">sizeof</span><span class="c1">(label_buffer), stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fix_fgets(label_buffer);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">long</span><span>&nbsp;lab_long = strtol(label_buffer, NULL, </span><span class="c7">10</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint8_t lab = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;lab, &amp;lab_long, </span><span class="c5">sizeof</span><span class="c1">(uint8_t));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label[</span><span class="c7">1</span><span class="c1">] = { lab };</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/*char * label_buffer_temp = (char*)malloc(strlen(label_buffer));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; memcpy(label_buffer_temp, label_buffer, strlen(label_buffer));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\n\nGot label! %u\n\n&quot;, label_buffer_temp[0]);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; sprintf_s(label, sizeof(label), &quot;%u&quot;, label_buffer_temp[0]);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; free(label_buffer_temp);*/</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint8_t existing_labels[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;existing_labels_count = getExistingLabelsCount(existing_labels, fLabelMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fseek(fDataMap, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fseek(fLabelMap, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fwrite(label, </span><span class="c5">sizeof</span><span>(uint8_t), </span><span class="c7">1</span><span class="c1">, fDataMap);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/*char * WAV_File_Path_c_str = (char*)calloc(WAV_File_Path.length(), sizeof(char));</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; strncpy_s(WAV_File_Path_c_str, WAV_File_Path.length(), WAV_File_Path.c_str(), WAV_File_Path.length());</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; fwrite(WAV_File_Path_c_str, sizeof(char), WAV_File_Path.length(), fDataMap);*/</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fwrite(WAV_File_Path.c_str(), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), WAV_File_Path.length(), fDataMap);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fwrite(OutputPath + </span><span class="c7">127</span><span>, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c7">1</span><span class="c1">, fDataMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">bool</span><span>&nbsp;exists = </span><span class="c5">false</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(existing_labels_count &gt; </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(i &lt; </span><span class="c7">256</span><span class="c1">&nbsp;&amp;&amp; !exists) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exists = exists || existing_labels[i] == lab;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!exists) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# This is a new label, please describe it. (in 255 or less characters)\n&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_description_buffer[MaximumLabelLength + </span><span class="c7">1</span><span class="c1">];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fgets(label_description_buffer, MaximumLabelLength, stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fix_fgets(label_description_buffer);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(label, </span><span class="c7">1</span><span>, </span><span class="c7">1</span><span class="c1">, fLabelMap);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(label_description_buffer, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), MaximumLabelLength, fLabelMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Added the pair: {%u, %s} to the label_map.\n&quot;</span><span class="c1">, lab, label_description_buffer);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Now loading the file with the label %d.\n&quot;</span><span class="c1">, lab);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// Create an array of the frequencies</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;x = </span><span class="c7">0</span><span class="c1">; x &lt; sample_count; x++) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;Complex&gt; * liveFreq = FT-&gt;FourierTransfer_Part(audioFile-&gt;getSampleRate(), x);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* freqArr = (</span><span class="c5">char</span><span>&nbsp;*)calloc(FT-&gt;MaxFrequency(), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;freqInd = </span><span class="c7">0</span><span class="c1">; freqInd &lt; FT-&gt;MaxFrequency(); freqInd++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freqArr[freqInd] = liveFreq-&gt;at(freqInd).real();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(freqArr, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), FT-&gt;MaxFrequency(), fVect);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(label, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c7">1</span><span class="c1">, fLabel);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(freqArr);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fclose(fVect);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fclose(fLabel);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fclose(fDataMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;FT;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Appended sound!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;audioFile;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Initialize a new dataset</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;Initialize() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errLabelMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fDataMap;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; errno_t errDataMap;</span></p><p class="c0"><span>&nbsp; &nbsp; errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; errDataMap = fopen_s(&amp;fDataMap, fn_data_map, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fDataMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// predict the label of a file using the Classifier</span></p><p class="c0"><span class="c6 c3">/*</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; The predict function can take arguments such as:</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; 1) a file path.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; The first input can be the relative path to a vectors file which you want to use instead of processing a wav file into a vectors file.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; 2) the &#39;-f&#39; argument.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; This is passed into the classifier as &#39;fast&#39; which tells the program to only check some of the data points (arbitrarily) and not all of them.</span></p><p class="c0"><span class="c6 c3">&nbsp; &nbsp; &nbsp; &nbsp; This obviously results in faster execution time (10x faster - since we take only a tenth of the vectors), but there is a penalty to the accuracy of the results. Though the final prediction is still usually correct.</span></p><p class="c0"><span class="c6 c3">*/</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;Predict(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;argc = CountCommandArgs(command);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Arg count: %d\n&quot;</span><span class="c1">, argc);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(argc == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;predictOutputFile[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;predictOutputFile_tmp[</span><span class="c7">128</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Name your prediction file: \n&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fgets(predictOutputFile_tmp, </span><span class="c5">sizeof</span><span class="c1">(predictOutputFile_tmp), stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fix_fgets(predictOutputFile_tmp);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; sprintf_s(predictOutputFile, </span><span class="c5">sizeof</span><span>(predictOutputFile), </span><span class="c14">&quot;%s/%s.vectors&quot;</span><span class="c1">, OutputPath, predictOutputFile_tmp);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; std::string WAV_File_Path;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# Path for WAV file: &quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; get_current_dir() &lt;&lt; </span><span class="c14">&quot;\\&quot;</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; WAV_File_Path = get_current_dir() + </span><span class="c14">&quot;\\&quot;</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;WAV_File_Path_buffer[</span><span class="c7">256</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fgets(WAV_File_Path_buffer, </span><span class="c5">sizeof</span><span class="c1">(WAV_File_Path_buffer), stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fix_fgets(WAV_File_Path_buffer);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; strlen(WAV_File_Path_buffer); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAV_File_Path += WAV_File_Path_buffer[i];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; AudioFile&lt;</span><span class="c5">double</span><span>&gt; * audioFile = </span><span class="c5">new</span><span>&nbsp;AudioFile&lt;</span><span class="c5">double</span><span class="c1">&gt;();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// Parse audio file into FFT and export it as vectors into a vectors file</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(audioFile-&gt;load(WAV_File_Path)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# Loaded File!&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; audioFile-&gt;printSummary();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;# CH: &quot;</span><span>&nbsp;&lt;&lt; audioFile-&gt;getNumChannels() &lt;&lt; </span><span class="c14">&quot; | &quot;</span><span>&nbsp;&lt;&lt; </span><span class="c14">&quot;SAMP: &quot;</span><span class="c1">&nbsp;&lt;&lt; audioFile-&gt;getNumSamplesPerChannel() * audioFile-&gt;getNumChannels() &lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FFT * FT = </span><span class="c5">new</span><span class="c1">&nbsp;FFT();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8_t channelInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;sampInd = </span><span class="c7">0</span><span class="c1">; sampInd &lt; audioFile-&gt;getNumSamplesPerChannel(); sampInd++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FT-&gt;AppendToWave(audioFile-&gt;samples[channelInd][sampInd]);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;actInd = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; </span><span class="c14">&quot;\t&quot;</span><span>&nbsp;&lt;&lt; ++actInd &lt;&lt; </span><span class="c14">&quot;) &quot;</span><span>&nbsp;&lt;&lt; </span><span class="c14">&quot;Loaded \&quot;&quot;</span><span>&nbsp;&lt;&lt; WAV_File_Path &lt;&lt; </span><span class="c14">&quot;\&quot; into Fourier Transform!&quot;</span><span class="c1">&nbsp;&lt;&lt; std::endl;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t sample_count = audioFile-&gt;getNumSamplesPerChannel() / audioFile-&gt;getSampleRate();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FILE * fVect;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno_t errVects;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(!file_exists(predictOutputFile)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errVects = fopen_s(&amp;fVect, predictOutputFile, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t intro[</span><span class="c7">3</span><span>] = { convert_to_big_endian(</span><span class="c7">2612</span><span>), convert_to_big_endian(sample_count), convert_to_big_endian(</span><span class="c7">4000</span><span class="c1">) };</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite((</span><span class="c5">char</span><span>*)intro, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c7">3</span><span>&nbsp;* </span><span class="c5">sizeof</span><span class="c1">(uint32_t), fVect);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errVects = fopen_s(&amp;fVect, predictOutputFile, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32_t old_sample_count = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fread_s(&amp;old_sample_count, </span><span class="c5">sizeof</span><span>(old_sample_count), </span><span class="c5">sizeof</span><span>(uint32_t), </span><span class="c7">1</span><span class="c1">, fVect);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count = convert_to_little_endian(old_sample_count);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count += sample_count;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_sample_count = convert_to_big_endian(old_sample_count);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fVect, </span><span class="c5">sizeof</span><span class="c1">(uint32_t), SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(&amp;old_sample_count, </span><span class="c5">sizeof</span><span>(uint32_t), </span><span class="c7">1</span><span class="c1">, fVect);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fseek(fVect, </span><span class="c7">0</span><span class="c1">, SEEK_END);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errVects) { printf(</span><span class="c14">&quot;Could not find nor create prediction file!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// Create an array of the frequencies</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;x = </span><span class="c7">0</span><span class="c1">; x &lt; sample_count; x++) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::vector&lt;Complex&gt; * liveFreq = FT-&gt;FourierTransfer_Part(audioFile-&gt;getSampleRate(), x);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* freqArr = (</span><span class="c5">char</span><span>&nbsp;*)calloc(FT-&gt;MaxFrequency(), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;freqInd = </span><span class="c7">0</span><span class="c1">; freqInd &lt; FT-&gt;MaxFrequency(); freqInd++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freqArr[freqInd] = liveFreq-&gt;at(freqInd).real();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fwrite(freqArr, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), FT-&gt;MaxFrequency(), fVect);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free(freqArr);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose(fVect);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;FT;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">delete</span><span class="c1">&nbsp;audioFile;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Created prediction file!!\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; data_handler-&gt;read_predict_feature_vector(predictOutputFile);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span>&nbsp;</span><span class="c5">if</span><span>&nbsp;(argc == </span><span class="c7">1</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* predictOutputFile;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(GetCommandArg(command, </span><span class="c7">0</span><span>, &amp;predictOutputFile) != </span><span class="c7">0</span><span>) { printf(</span><span class="c14">&quot;# Could not find argument!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; data_handler-&gt;read_predict_feature_vector(predictOutputFile);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Unrecognized argument count!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; data_handler-&gt;normalize_prediction_data();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; data_handler-&gt;get_prediction_data_size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; data_handler-&gt;get_prediction_data()-&gt;at(i)-&gt;c_only();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_prediction_data(data_handler-&gt;get_prediction_data());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;prediction_output = network-&gt;real_predict();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * fLabelMap;</span></p><p class="c0"><span>&nbsp; &nbsp; errno_t errLabelMap = fopen_s(&amp;fLabelMap, fn_label_map, </span><span class="c14">&quot;r+b&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(errLabelMap) { printf(</span><span class="c14">&quot;# Could not open label map file!\n&quot;</span><span>); </span><span class="c5">return</span><span>&nbsp;-</span><span class="c7">1</span><span class="c1">; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;label_pair[MaximumLabelLength + </span><span class="c7">2</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(fread_s(label_pair, (MaximumLabelLength + </span><span class="c7">2</span><span>) * </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span>), MaximumLabelLength + </span><span class="c7">1</span><span class="c1">, fLabelMap)) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint8_t label_key = label_pair[</span><span class="c7">0</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(label_key == prediction_output) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;The prediction for this file is: \n\t%d | %s\n&quot;</span><span>, prediction_output, label_pair + </span><span class="c7">1</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(fLabelMap);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_training_data(data_handler-&gt;get_training_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_validation_data(data_handler-&gt;get_validation_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_test_data(data_handler-&gt;get_test_data());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;InitNetwork(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(data_handler == NULL) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;You must have a data_handler before initializing a network!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Now initializing network of model: &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;%d -&gt; &quot;</span><span>, data_handler-&gt;get_training_data()-&gt;at(</span><span class="c7">0</span><span class="c1">)-&gt;get_feature_array_size());</span></p><p class="c0"><span>&nbsp; &nbsp; std::vector&lt;</span><span class="c5">int</span><span class="c1">&gt; hidden_layers;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; CountCommandArgs(command); i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* arg;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; GetCommandArg(command, i, &amp;arg);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; hidden_layers.push_back(strtol(arg, NULL, </span><span class="c7">10</span><span class="c1">));</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;%d -&gt; &quot;</span><span class="c1">, hidden_layers.at(i));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;%d\n&quot;</span><span class="c1">, data_handler-&gt;get_class_count());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; network = </span><span class="c5">new</span><span class="c1">&nbsp;Network(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; hidden_layers,</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; data_handler-&gt;get_training_data()-&gt;at(</span><span class="c7">0</span><span class="c1">)-&gt;get_feature_array_size(),</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; data_handler-&gt;get_class_count(),</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">0.25</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_training_data(data_handler-&gt;get_training_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_validation_data(data_handler-&gt;get_validation_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_test_data(data_handler-&gt;get_test_data());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;c_only();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;LoadNetwork(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(network != NULL) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;You currently have a network with an accuracy of %.4f%% loaded. Please dereference it before proceeding!\n&quot;</span><span>, network-&gt;test_performance * </span><span class="c7">100.0</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * f;</span></p><p class="c0"><span>&nbsp; &nbsp; errno_t err = fopen_s(&amp;f, command, </span><span class="c14">&quot;rb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(err == </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">// Successfully opened file for reading</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c3">/// IMPORT</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">unsigned</span><span>&nbsp;</span><span class="c5">long</span><span>&nbsp;</span><span class="c5">long</span><span>&nbsp;file_size = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fread(&amp;file_size, </span><span class="c5">sizeof</span><span>(file_size), </span><span class="c7">1</span><span class="c1">, f);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; fseek(f, </span><span class="c7">0</span><span class="c1">, SEEK_SET);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;* buffer_read = (</span><span class="c5">char</span><span>*)calloc(file_size, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">));</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; uint32_t read = fread(buffer_read, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), file_size, f);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fclose(f);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; network = </span><span class="c5">new</span><span>&nbsp;Network(</span><span class="c7">0.25</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; network-&gt;import_network(buffer_read);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; free(buffer_read);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; network-&gt;set_training_data(data_handler-&gt;get_training_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; network-&gt;set_validation_data(data_handler-&gt;get_validation_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; network-&gt;set_test_data(data_handler-&gt;get_test_data());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Failed to open or read file &#39;%s&#39; which was requested as a network import file!&quot;</span><span class="c1">, command);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;ExportNetwork(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Network test performance: %.4f%%\n&quot;</span><span>, </span><span class="c7">100.0</span><span class="c1">*network-&gt;test_c());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span class="c1">&nbsp;* buffer;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span class="c1">&nbsp;total_size = network-&gt;export_network(&amp;buffer);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; FILE * f;</span></p><p class="c0"><span>&nbsp; &nbsp; errno_t err = fopen_s(&amp;f, command, </span><span class="c14">&quot;wb&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; fwrite(buffer, </span><span class="c5">sizeof</span><span>(</span><span class="c5">char</span><span class="c1">), total_size, f);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fclose(f);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;TrainNetwork(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(network == NULL) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;You must first load or initialize a network before training it!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">long</span><span>&nbsp;epochs = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; epochs = strtol(command, NULL, </span><span class="c7">10</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Now training %d times...\n&quot;</span><span class="c1">, epochs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; epochs; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Training error @ iteration %d: %.4f\n&quot;</span><span class="c1">, i, network-&gt;train_c());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;ThreadTrainNetwork(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(network == NULL) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;You must first load or initialize a network before training it!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">long</span><span>&nbsp;epochs = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; epochs = strtol(command, NULL, </span><span class="c7">10</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Now training %d times...\n&quot;</span><span class="c1">, epochs);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">auto</span><span>&nbsp;lamba = [&amp;](</span><span class="c5">int</span><span class="c1">&nbsp;target) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; epochs; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Thread #%d =&gt; Training error @ iteration %d: %.4f\n&quot;</span><span class="c1">, target, i, network-&gt;train_c(target));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; };</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;std::thread&gt; threads;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;target = </span><span class="c7">0</span><span class="c1">; target &lt; data_handler-&gt;get_class_count(); target++)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; threads.emplace_back(std::thread(lamba, target));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">auto</span><span class="c1">&nbsp;&amp;th : threads)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; th.join();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;AFKTrain() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::vector&lt;std::thread&gt; threads;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">auto</span><span class="c1">&nbsp;lambdaTrain = [&amp;]() {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span>&nbsp;last_validation_performance = </span><span class="c7">0</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Started training thread!\nType: &#39;stop&#39; to exit!\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(</span><span class="c7">1</span><span class="c1">) {</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;epoch = </span><span class="c7">0</span><span>; epoch &lt; </span><span class="c7">5</span><span class="c1">; epoch++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; network-&gt;train_c();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">double</span><span class="c1">&nbsp;validation_performance = network-&gt;validate_c();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;Validation performance: %.4f%%\n&quot;</span><span>, </span><span class="c7">100.0</span><span class="c1">&nbsp;* validation_performance);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(validation_performance &gt; last_validation_performance) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;export_network_file_name[</span><span class="c7">64</span><span>] = { </span><span class="c7">0</span><span class="c1">&nbsp;};</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf_s(export_network_file_name, </span><span class="c7">64</span><span>, </span><span class="c14">&quot;NetworkOutput_%.2f.net&quot;</span><span>, </span><span class="c7">100.0</span><span class="c1">&nbsp;* validation_performance);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExportNetwork(export_network_file_name);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; };</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">auto</span><span class="c1">&nbsp;lambdaAwaitExit = [&amp;](std::thread * training_thread) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(</span><span class="c7">1</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;buffer[</span><span class="c7">64</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fgets(buffer, </span><span class="c7">64</span><span class="c1">, stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fix_fgets(buffer);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(buffer, </span><span class="c14">&quot;stop&quot;</span><span class="c1">)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*training_thread).join();</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; };</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::thread training_thread = std::thread(lambdaTrain);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::thread exit_thread = std::thread(lambdaAwaitExit, &amp;training_thread);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; exit_thread.join();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ValidateNetwork() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(network == NULL) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;You must first load or initialize a network before validating it!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_training_data(data_handler-&gt;get_training_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_validation_data(data_handler-&gt;get_validation_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_test_data(data_handler-&gt;get_test_data());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Validation performance: %.4f%%\n&quot;</span><span>, </span><span class="c7">100.0</span><span class="c1">&nbsp;* network-&gt;validate_c());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;TestNetwork() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(network == NULL) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;You must first load or initialize a network before validating it!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_training_data(data_handler-&gt;get_training_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_validation_data(data_handler-&gt;get_validation_data());</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; network-&gt;set_test_data(data_handler-&gt;get_test_data());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Test performance: %.4f%%\n&quot;</span><span>, </span><span class="c7">100.0</span><span class="c1">&nbsp;* network-&gt;test_c());</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;LoadDataHandler() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(data_handler != NULL) { </span><span class="c5">delete</span><span class="c1">&nbsp;data_handler; }</span></p><p class="c0"><span>&nbsp; &nbsp; data_handler = </span><span class="c5">new</span><span class="c1">&nbsp;Data_Handler();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; data_handler-&gt;read_feature_vector(fn_vectors);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; data_handler-&gt;read_feature_labels(fn_labels);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; data_handler-&gt;count_classes();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; data_handler-&gt;normalize_data();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; data_handler-&gt;split_data();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; data_handler-&gt;c_only();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ResetDataHandler() {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(data_handler != NULL) { </span><span class="c5">delete</span><span class="c1">&nbsp;data_handler; }</span></p><p class="c0"><span>&nbsp; &nbsp; data_handler = </span><span class="c5">new</span><span class="c1">&nbsp;Data_Handler();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;LoadPredictFile(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span class="c1">&nbsp;(data_handler == NULL) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;There is no data_handler, please initialize one before loading a predict file!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">2</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; data_handler-&gt;read_predict_feature_vector(command);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; data_handler-&gt;normalize_prediction_data();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span class="c1">; i &lt; data_handler-&gt;get_prediction_data_size(); i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; data_handler-&gt;get_prediction_data()-&gt;at(i)-&gt;c_only();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ExitProgram() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(fn_data_map);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(fn_label_map);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(fn_labels);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; free(fn_vectors);</span></p><p class="c0"><span>&nbsp; &nbsp; exit(</span><span class="c7">0</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;ShowNoHelpMenu(</span><span class="c5">bool</span><span class="c1">&nbsp;ext) {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Please select a help menu: \n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">const</span><span>&nbsp;</span><span class="c5">char</span><span>&nbsp;* menus[</span><span class="c7">6</span><span>] = { </span><span class="c14">&quot;This menu&quot;</span><span>, </span><span class="c14">&quot;General&quot;</span><span>, </span><span class="c14">&quot;Data Set&quot;</span><span>, </span><span class="c14">&quot;Predictions&quot;</span><span>, </span><span class="c14">&quot;Neural Network&quot;</span><span>, </span><span class="c14">&quot;All&quot;</span><span class="c1">&nbsp;};</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">for</span><span>&nbsp;(</span><span class="c5">int</span><span>&nbsp;i = </span><span class="c7">0</span><span>; i &lt; </span><span class="c7">6</span><span class="c1">; i++) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;\t%d) for %s help type &#39;%d&#39;\n&quot;</span><span class="c1">, i, menus[i], i);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\tTo exit type &#39;-1&#39;\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">int</span><span>&nbsp;helpMenuToShow = -</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;inp[</span><span class="c7">16</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; fgets(inp, </span><span class="c7">16</span><span class="c1">, stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fix_fgets(inp);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; helpMenuToShow = strtol(inp, NULL, </span><span class="c7">10</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(helpMenuToShow == -</span><span class="c7">1</span><span>) { </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">; }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">else</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Help((HelpMenus)helpMenuToShow);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;ShowGeneralHelpMenu(</span><span class="c5">bool</span><span class="c1">&nbsp;ext) {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;&gt; General Help Menu\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ help {0} | To see help menu.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t {0} =&gt; The help menu to show as an integer (type &#39;help 0&#39; for more...).\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ exit | Exits the program.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ dsinit | DataSet Initialize. Initializes a new dataset. You must do this when starting a new dataset!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ cds | Change to a different dataset in the same directory.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ cdir | Change output directory.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;ShowDataSetHelpMenu(</span><span class="c5">bool</span><span class="c1">&nbsp;ext) {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;&gt; DataSet Help Menu\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ list {0} | List: \n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t -c | Classification - classes. Show a list of the classes which are labeled in the dataset.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t -f | Files. Show a list of the files which are in the dataset.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ add | Add a file to the dataset\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ dhload | Data Handler Load. Loads the dataset into the live data handler (HDD =&gt; RAM). Do this before training or testing (or validating) a network.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ dhreset | Unloades a loaded dataset from the data handler, or creates a blank data handler.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;ShowPredictionHelpMenu(</span><span class="c5">bool</span><span class="c1">&nbsp;ext) {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;&gt; Prediction Help Menu\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ pred {0} | Predict.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t{0} =&gt; Prediction file path | If a prediction file (A vectors file) already exists, you may use this to instead of creating a new prediction file.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;ShowNetworkHelpMenu(</span><span class="c5">bool</span><span class="c1">&nbsp;ext) {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;&gt; Neural Network Help Menu\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ ninit {...} | Initialize a new neural network.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\tEach argument should be the size of a hidden layer for the new neural network.&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\t&#39;ninit 120 120 32&#39; will create a neural network with 5 layers: an input layer (automatically created acording to the datahandler), 3 hidden layers of size: 120, 120, 32, and an output layer (also automatic).\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ ntrain {0} | Train a network a certain amount of times. Default = 1\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ nthtrain {0} | Network threaded train. Train a network on multiple threads a certain amount of epochs. Warning: Multithread training may harm the network, use only with an untrained network.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ nafktrain | Train a network and export it until stopped.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ nvalid | Validate the network.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ ntest | Test the network.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ nexport {0} | Export the network. {0} =&gt; File path and name.\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;$ nimport {0} | Import a network. {0} =&gt; File path and name.\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;Help(HelpMenus helpMenu) {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">bool</span><span>&nbsp;ext = </span><span class="c5">false</span><span class="c1">;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">switch</span><span class="c1">&nbsp;(helpMenu)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">case</span><span class="c1">&nbsp;NoHelpMenu:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ShowNoHelpMenu(ext);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">case</span><span class="c1">&nbsp;GeneralHelpMenu:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ShowGeneralHelpMenu(ext);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">case</span><span class="c1">&nbsp;DataSetHelpMenu:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ShowDataSetHelpMenu(ext);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">case</span><span class="c1">&nbsp;PreidctionHelpMenu:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ShowPredictionHelpMenu(ext);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">case</span><span class="c1">&nbsp;NetworkHelpMenu:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ShowNetworkHelpMenu(ext);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">case</span><span class="c1">&nbsp;AllHelpMenu:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ShowGeneralHelpMenu(ext);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ShowDataSetHelpMenu(ext);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ShowPredictionHelpMenu(ext);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ShowNetworkHelpMenu(ext);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">default</span><span class="c1">:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ShowNoHelpMenu(ext);</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">break</span><span class="c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c5">int</span><span>&nbsp;Help(</span><span class="c5">char</span><span class="c1">&nbsp;* command) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; HelpMenus helpMenu = NoHelpMenu;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(CountCommandArgs(command) &gt; </span><span class="c7">0</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; helpMenu = (HelpMenus)strtol(command, NULL, </span><span class="c7">10</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;Help(helpMenu);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c6 c3">// Gets user input and compares it to valid commands</span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;ProccessCommands() {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;&gt; &quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">char</span><span>&nbsp;input[</span><span class="c7">1024</span><span class="c1">];</span></p><p class="c0"><span>&nbsp; &nbsp; fgets(input, </span><span class="c5">sizeof</span><span class="c1">(input), stdin);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; fix_fgets(input);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;help&quot;</span><span>)) { </span><span class="c5">return</span><span>&nbsp;Help(input + strlen(</span><span class="c14">&quot;help&quot;</span><span>) + </span><span class="c7">1</span><span class="c1">); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;exit&quot;</span><span>) || cmpcommand(input, </span><span class="c14">&quot;close&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;ExitProgram(); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;dsinit&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;Initialize(); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;cds&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;ChangeDataSetName(); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;cdir&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;ChangeOutputPath(); }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;list&quot;</span><span>)) { </span><span class="c5">return</span><span>&nbsp;ListView(input + strlen(</span><span class="c14">&quot;list&quot;</span><span>) + </span><span class="c7">1</span><span class="c1">); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;add&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;AddDataToSet(); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;dhload&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;LoadDataHandler(); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;dhreset&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;ResetDataHandler(); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;pred&quot;</span><span>)) { </span><span class="c5">return</span><span>&nbsp;Predict(input + strlen(</span><span class="c14">&quot;pred&quot;</span><span>) + </span><span class="c7">1</span><span class="c1">); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;ninit&quot;</span><span>)) { </span><span class="c5">return</span><span>&nbsp;InitNetwork(input + strlen(</span><span class="c14">&quot;ninit&quot;</span><span>) + </span><span class="c7">1</span><span class="c1">); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;ntrain&quot;</span><span>)) { </span><span class="c5">return</span><span>&nbsp;TrainNetwork(input + strlen(</span><span class="c14">&quot;ntrain&quot;</span><span>) + </span><span class="c7">1</span><span class="c1">); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;nafktrain&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;AFKTrain(); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;nthtrain&quot;</span><span>)) { </span><span class="c5">return</span><span>&nbsp;ThreadTrainNetwork(input + strlen(</span><span class="c14">&quot;nthtrain&quot;</span><span>) + </span><span class="c7">1</span><span class="c1">); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;nvalid&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;ValidateNetwork(); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;ntest&quot;</span><span>)) { </span><span class="c5">return</span><span class="c1">&nbsp;TestNetwork(); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;nimport&quot;</span><span>)) { </span><span class="c5">return</span><span>&nbsp;LoadNetwork(input + strlen(</span><span class="c14">&quot;nimport&quot;</span><span>) + </span><span class="c7">1</span><span class="c1">); }</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(cmpcommand(input, </span><span class="c14">&quot;nexport&quot;</span><span>)) { </span><span class="c5">return</span><span>&nbsp;ExportNetwork(input + strlen(</span><span class="c14">&quot;nexport&quot;</span><span>) + </span><span class="c7">1</span><span class="c1">); }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">1</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><p class="c17 c12"><span class="c1"></span></p><h3 class="c39" id="h.7o2p75syjsm5"><span class="c4 c15 c18">AudioClassifier.cpp (main)</span></h3><p class="c17 c12"><span class="c1"></span></p><a id="t.9ee485839ddb93ae9ace3f4d3cb3f358ce97cb4e"></a><a id="t.42"></a><table class="c51"><tbody><tr class="c34"><td class="c37" colspan="1" rowspan="1"><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&quot;</span><span class="c14">CommandLineFunctions.h</span><span class="c2">&quot;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">chrono</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">#include</span><span>&nbsp;</span><span class="c5">&lt;</span><span class="c14">utility</span><span class="c2">&gt;</span></p><p class="c0"><span class="c5">typedef</span><span class="c1">&nbsp;std::chrono::high_resolution_clock::time_point TimeVar;</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">#define</span><span class="c1">&nbsp;duration(a) std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(a).count()</span></p><p class="c0"><span class="c5">#define</span><span class="c1">&nbsp;timeNow() std::chrono::high_resolution_clock::now()</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span class="c1">&nbsp;StartUp() {</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot; &nbsp; _____ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ &nbsp; &nbsp;_____ _ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ &nbsp;__ _ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot; &nbsp;/ ____| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | | &nbsp;/ ____| | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (_)/ _(_) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot; | (___ &nbsp; ___ &nbsp;_ &nbsp; _ _ __ &nbsp; __| | | | &nbsp; &nbsp;| | __ _ ___ ___ _| |_ _ &nbsp;___ _ __ \n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot; &nbsp;\\___ \\ / _ \\| | | | &#39;_ \\ / _` | | | &nbsp; &nbsp;| |/ _` / __/ __| | &nbsp;_| |/ _ \\ &#39;__|\n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot; &nbsp;____) | (_) | |_| | | | | (_| | | |____| | (_| \\__ \\__ \\ | | | | &nbsp;__/ | &nbsp; \n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot; |_____/ \\___/ \\__,_|_| |_|\\__,_| &nbsp;\\_____|_|\\__,_|___/___/_|_| |_|\\___|_| &nbsp; \n&quot;</span><span class="c1">);</span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; printf(</span><span class="c14">&quot;Copyright &copy; 2021 Michael Kuperfish Steinberg\n\n\n&quot;</span><span class="c1">);</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ChangeOutputPath();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ChangeDataSetName();</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">while</span><span>&nbsp;(</span><span class="c5">true</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c5">if</span><span>&nbsp;(ProccessCommands() == </span><span class="c7">1</span><span class="c1">) {</span></p><p class="c0"><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(</span><span class="c14">&quot;# Command Failed!\n&quot;</span><span class="c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span>&nbsp;</span><span class="c7">0</span><span class="c1">;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c12"><span class="c1"></span></p><p class="c0"><span class="c5">int</span><span>&nbsp;main(</span><span class="c5">int</span><span>&nbsp;argc, </span><span class="c5">char</span><span class="c1">&nbsp;** argv)</span></p><p class="c0"><span class="c1">{</span></p><p class="c0"><span>&nbsp; &nbsp; </span><span class="c5">return</span><span class="c1">&nbsp;StartUp();</span></p><p class="c0"><span class="c1">}</span></p></td></tr></tbody></table><hr style="page-break-before:always;display:none;"><h1 class="c55" id="h.ckynjrizps73"><span class="c4 c15 c56"></span></h1><h1 class="c80 c86" id="h.njg5yv5rlqry"><span class="c4 c15 c56">Works Cited</span></h1><p class="c11 c12 c80"><span class="c3 c15 c49"></span></p><p class="c35"><span>&ldquo;10.&rdquo; </span><span class="c29">Shutterstock</span><span>, ak6.picdn.net/shutterstock/videos/1027713866/thumb/10.jpg. </span></p><p class="c35"><span>&ldquo;17.7 - Calling Inherited Functions and Overriding Behavior.&rdquo; </span><span class="c29">Learn C++</span><span>, www.learncpp.com/cpp-tutorial/calling-inherited-functions-and-overriding-behavior/. </span></p><p class="c35"><span>&ldquo;17.8 - Hiding Inherited Functionality.&rdquo; </span><span class="c29">Learn C++</span><span>, www.learncpp.com/cpp-tutorial/hiding-inherited-functionality/. </span></p><p class="c35"><span>About Thorben JanssenThorben is an independent trainer and author of the Amazon bestselling book Hibernate Tips - More than 70 solutions to common Hibernate problems.He writes about Java EE related topics on his blog Thoughts on Java. &ldquo;OOP Concept for Beginners: What Is Inheritance?&rdquo; </span><span class="c29">Stackify</span><span>, 2 June 2020, stackify.com/oop-concept-inheritance/. </span></p><p class="c35"><span>Adamstark. &ldquo;Adamstark/AudioFile.&rdquo; </span><span class="c29">GitHub</span><span>, github.com/adamstark/AudioFile. </span></p><p class="c35"><span>Aquarius_GirlAquarius_Girl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;18.1k5656 gold badges186186 silver badges346346 bronze badges, et al. &ldquo;How to Print a Char Array in C through Printf?&rdquo; </span><span class="c29">Stack Overflow</span><span>, 1 Mar. 1967, stackoverflow.com/questions/50312194/how-to-print-a-char-array-in-c-through-printf. </span></p><p class="c35"><span>&ldquo;Artificial Neural Network.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 22 Mar. 2021, en.wikipedia.org/wiki/Artificial_neural_network. </span></p><p class="c35"><span>Atul, Kang &amp;, et al. &ldquo;Snake Game with Deep Learning.&rdquo; </span><span class="c29">TheAILearner</span><span>, 12 Dec. 2018, theailearner.com/2018/04/19/snake-game-with-deep-learning/. </span></p><p class="c35"><span>&ldquo;Audio File Format Specifications.&rdquo; </span><span class="c29">Wave File Specifications</span><span>, www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html. </span></p><p class="c35"><span>Bettilyon, Tyler Elliot. &ldquo;How to Classify MNIST Digits with Different Neural Network Architectures.&rdquo; </span><span class="c29">Medium</span><span>, Teb&#39;s Lab, 9 May 2019, medium.com/tebs-lab/how-to-classify-mnist-digits-with-different-neural-network-architectures-39c75a0f03e3. </span></p><p class="c35"><span>Braunschweig, Dave. &ldquo;Encapsulation.&rdquo; </span><span class="c29">Programming Fundamentals</span><span>, 15 Dec. 2018, press.rebus.community/programmingfundamentals/chapter/encapsulation/#:~:text=Encapsulation%20is%20one%20of%20the,parties&#39;%20direct%20access%20to%20them. </span></p><p class="c35"><span>&ldquo;Breakout (Video Game).&rdquo; </span><span class="c29">Infogalactic</span><span>, 1 Apr. 1976, infogalactic.com/info/Breakout_(video_game). </span></p><p class="c35"><span>&ldquo;Bytes to Integer - C++ Forum.&rdquo; </span><span class="c29">Cplusplus.com</span><span>, www.cplusplus.com/forum/beginner/3076/. </span></p><p class="c35"><span>The C++ Resources Network. &ldquo;Data Structures.&rdquo; </span><span class="c29">Cplusplus.com</span><span>, www.cplusplus.com/doc/tutorial/structures/. </span></p><p class="c35"><span>&ldquo;C++.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 21 Mar. 2021, en.wikipedia.org/wiki/C%2B%2B. </span></p><p class="c35"><span>Cerna, Michael, and Audrey F. Hervey. &ldquo;The Fundamentals of FFT-Based Signal Analysis and Measurement.&rdquo; National Instruments, July 2000. </span></p><p class="c35"><span>&ldquo;Common Misconceptions about Birds - Arctic and Antarctic Birds.&rdquo; </span><span class="c29">Beyond Penguins and Polar Bears</span><span>, beyondpenguins.ehe.osu.edu/issue/arctic-and-anarctic-birds/common-misconceptions-about-birds. </span></p><p class="c35"><span>Corob-Msft. &ldquo;x64 Calling Convention.&rdquo; </span><span class="c29">Microsoft Docs</span><span>, docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160. </span></p><p class="c35"><span>Darkshots6692. &ldquo;The Ultimate Eminem Piano Medley.&rdquo; </span><span class="c29">YouTube</span><span>, YouTube, 8 Sept. 2015, www.youtube.com/watch?v=BJp_16j8s-A. </span></p><p class="c35"><span>DiCola, Tony. &ldquo;FFT: Fun with Fourier Transforms.&rdquo; </span><span class="c29">Adafruit Learning System</span><span>, learn.adafruit.com/fft-fun-with-fourier-transforms/background. </span></p><p class="c35"><span>&ldquo;Discrete Fourier Transform.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 17 Mar. 2021, en.wikipedia.org/wiki/Discrete_Fourier_transform. </span></p><p class="c35"><span>&ldquo;Fast Fourier Transform.&rdquo; </span><span class="c29">Fast Fourier Transform - Rosetta Code</span><span>, rosettacode.org/wiki/Fast_Fourier_transform. </span></p><p class="c35"><span>&ldquo;Fast Fourier Transform.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 8 Mar. 2021, en.wikipedia.org/wiki/Fast_Fourier_transform. </span></p><p class="c35"><span class="c29">Fourier Analysis and Synthesis</span><span>, hyperphysics.phy-astr.gsu.edu/hbase/Audio/fourier.html. </span></p><p class="c35"><span>&ldquo;Frequency Ranges of Musical Instruments: Musical Instruments, Musicals, Music Theory.&rdquo; </span><span class="c29">Pinterest</span><span>, www.pinterest.com/pin/469641067374231384/. </span></p><p class="c35"><span>&ldquo;Function - Dictionary Definition.&rdquo; </span><span class="c29">Vocabulary.com</span><span>, www.vocabulary.com/dictionary/function. </span></p><p class="c35"><span>gerardonfiya. &ldquo;C++ Machine Learning Tutorial Part 3: K-Means Clustering Unsupervised Learning.&rdquo; </span><span class="c29">YouTube</span><span>, YouTube, 6 Feb. 2019, www.youtube.com/watch?v=knXGdIUExBY. </span></p><p class="c35"><span>Godbolt, Matt. </span><span class="c29">Compiler Explorer</span><span>, godbolt.org/. </span></p><p class="c35"><span>&ldquo;Gradient Descent Derivation.&rdquo; </span><span class="c29">Gradient Descent Derivation &middot; Chris McCormick</span><span>, 4 Mar. 2014, mccormickml.com/2014/03/04/gradient-descent-derivation/. </span></p><p class="c35"><span>Henrik Hillestad L&oslash;voldHenrik Hillestad L&oslash;vold &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1, et al. &ldquo;Reading File as Hex in C++.&rdquo; </span><span class="c29">Stack Overflow</span><span>, 1 Oct. 1962, stackoverflow.com/questions/20336810/reading-file-as-hex-in-c. </span></p><p class="c35"><span>&ldquo;Hidden Markov Model.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 24 Mar. 2021, en.wikipedia.org/wiki/Hidden_Markov_model. </span></p><p class="c35"><span>&ldquo;How Many Dog Breeds Are There?: Hill&#39;s Pet.&rdquo; </span><span class="c29">Hill&#39;s Pet Nutrition</span><span>, www.hillspet.com/dog-care/behavior-appearance/how-many-dog-breeds-are-there. </span></p><p class="c35"><span>&ldquo;Information Hiding.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 28 Mar. 2021, en.wikipedia.org/wiki/Information_hiding. </span></p><p class="c35"><span>&ldquo;Inheritance (Object-Oriented Programming).&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 11 Feb. 2021, en.wikipedia.org/wiki/Inheritance_(object-oriented_programming). </span></p><p class="c35"><span>&ldquo;Inheritance, Polymorphism and the Object Memory Model.&rdquo; Cs.bgu.ac.il, 2010. </span></p><p class="c35"><span>Karthikeyan, Vijayanarasimhan. &ldquo;How Can We Differentiate between People&#39;s Voices? Why Are People&#39;s Voices Different?&rdquo; </span><span class="c29">Quora</span><span>, 9 Nov. 2015, www.quora.com/How-can-we-differentiate-between-peoples-voices-Why-are-peoples-voices-different. </span></p><p class="c35"><span>Katharina von Kriegstein, Anne-Lise Giraud. &ldquo;Implicit Multisensory Associations Influence Voice Recognition.&rdquo; </span><span class="c29">PLOS Biology</span><span>, Public Library of Science, journals.plos.org/plosbiology/article?id=10.1371%2Fjournal.pbio.0040326. </span></p><p class="c35"><span>L, Noah. &ldquo;Sharing Objects Between Threads in C++, the Safe and Easy Way.&rdquo; </span><span class="c29">CodeProject</span><span>, CodeProject, 14 June 2016, www.codeproject.com/Articles/1106491/Sharing-Objects-Between-Threads-in-Cplusplus-the-S. </span></p><p class="c35"><span>Liashchynskyi, Petro. &ldquo;Creating of Neural Network Using JavaScript in 7&nbsp;Minutes!&rdquo; </span><span class="c29">DEV Community</span><span>, DEV Community, 12 Jan. 2019, dev.to/liashchynskyi/creating-of-neural-network-using-javascript-in-7minutes-o21. </span></p><p class="c35"><span>&ldquo;Marin Mersenne.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 18 Mar. 2021, en.wikipedia.org/wiki/Marin_Mersenne. </span></p><p class="c35"><span>&ldquo;MNIST Database.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 10 Mar. 2021, en.wikipedia.org/wiki/MNIST_database. </span></p><p class="c35"><span>Monson, Brian B., et al. &ldquo;The Perceptual Significance of High-Frequency Energy in the Human Voice.&rdquo; </span><span class="c29">Frontiers</span><span>, Frontiers, 26 May 2014, www.frontiersin.org/articles/10.3389/fpsyg.2014.00587/full. </span></p><p class="c35"><span>&ldquo;My Shazam Adventure.&rdquo; </span><span class="c29">luungoc2005</span><span>, 16 Jan. 2017, luungoc2005.github.io/posts/tutorials/dotnet/naudio/my-shazam-adventure/. </span></p><p class="c35"><span>&ldquo;Neural Circuit.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 8 Mar. 2021, en.wikipedia.org/wiki/Neural_circuit. </span></p><p class="c35"><span>&ldquo;Object-Oriented Programming.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 22 Mar. 2021, en.wikipedia.org/wiki/Object-oriented_programming. </span></p><p class="c35"><span>officialtiesto. &ldquo;Ti&euml;sto &amp; Sevenn - BOOM (Official Video).&rdquo; </span><span class="c29">YouTube</span><span>, YouTube, 26 Apr. 2017, www.youtube.com/watch?v=tSJSVmfaMCs. </span></p><p class="c35"><span>&ldquo;Online x86 / x64 Assembler and Disassembler.&rdquo; </span><span class="c29">&#9660;</span><span>, defuse.ca/online-x86-assembler.htm. </span></p><p class="c35"><span>oscaralsing. &ldquo;What Is The Difference Between KNN and K-Means?&rdquo; </span><span class="c29">YouTube</span><span>, YouTube, 25 Jan. 2018, www.youtube.com/watch?v=OClrEI_5Ri4. </span></p><p class="c35"><span class="c29">Packt Subscription</span><span>, subscription.packtpub.com/book/game_development/9781849699099/1/ch01lvl1sec09/analog-and-digital-audio. </span></p><p class="c35"><span>&ldquo;Procedural Programming.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 15 Feb. 2021, en.wikipedia.org/wiki/Procedural_programming. </span></p><p class="c35"><span>Puzzle Magazine. &ldquo;Minesweeper Puzzle Magazine.&rdquo; </span><span class="c29">Puzzle Magazines</span><span>, www.puzzle-magazine.com/minesweeper-magazine.php. </span></p><p class="c35"><span>Reed, Smith Alexander. &ldquo;THE MUSICAL SEMIOTICS OF TIMBRE IN THE HUMAN VOICE and STATIC TAKES LOVE&rsquo;S BODY .&rdquo; </span><span class="c29">University of Pittsburgh </span><span>, 2005. </span></p><p class="c35"><span>&ldquo;Research Guides: MLA Style: In-Text Citations.&rdquo; </span><span class="c29">In-Text Citations - MLA Style - Research Guides at Towson University</span><span>, towson.libguides.com/mlastyle/in-text. </span></p><p class="c35"><span>Roberts, Bucky, director. </span><span class="c29">C++ Programming Tutorials</span><span>. </span><span class="c29">YouTube</span><span>, TheNewBoston, 11 Apr. 2011, www.youtube.com/playlist?list=PLAE85DE8440AA6B83. </span></p><p class="c35"><span>Shalev-Shwartz, Shai, and Shai Ben-David. </span><span class="c29">Understanding Machine Learning: From Theory to Algorithms</span><span>. Cambridge University Press, 2017. </span></p><p class="c35"><span>Smith, Keith. &ldquo;Blockade [Model 807-0001].&rdquo; </span><span class="c29">Return to the Mainpage</span><span>, Gaming-History (Arcade-History), 2011, www.arcade-history.com/?n=blockade&amp;page=detail&amp;id=287. </span></p><p class="c35"><span>&ldquo;Spectrum Analyzer.&rdquo; </span><span class="c29">Spectrum Analyzer | Academo.org - Free, Interactive, Education.</span><span>, academo.org/demos/spectrum-analyzer/. </span></p><p class="c35"><span>&ldquo;Std::Cout, Std::Wcout.&rdquo; </span><span class="c29">Cppreference.com</span><span>, en.cppreference.com/w/cpp/io/cout. </span></p><p class="c35"><span>&ldquo;Std::Vector::Size.&rdquo; </span><span class="c29">Cplusplus.com</span><span>, www.cplusplus.com/reference/vector/vector/size/. </span></p><p class="c35"><span>Umamaheswaran, Venkatesh. &ldquo;Comprehending K-Means and KNN Algorithms.&rdquo; </span><span class="c29">Medium</span><span>, Becoming Human: Artificial Intelligence Magazine, 14 Nov. 2018, becominghuman.ai/comprehending-k-means-and-knn-algorithms-c791be90883d. </span></p><p class="c35"><span>Wang, Avery Li-Chun. &ldquo;An Industrial-Strength Audio Search Algorithm .&rdquo; Shazam Entertainment, Ltd. . </span></p><p class="c35"><span>Wang, Avery Li-Chun. &ldquo;An Industrial-Strength Audio Search Algorithm.&rdquo; Shazam Entertainment, Ltd., 2003. </span></p><p class="c35"><span class="c29">What Is a Static Polymorphism in C#?</span><span>, www.tutorialspoint.com/What-is-a-static-polymorphism-in-Chash. </span></p><p class="c35"><span>&ldquo;What Is Backpropagation Really Doing? | Deep Learning, Chapter 3.&rdquo; </span><span class="c29">YouTube</span><span>, YouTube, 3 Nov. 2017, www.youtube.com/watch?v=Ilg3gGewQ5U. </span></p><p class="c35"><span>&ldquo;What Is the Toupper() Function in C?&rdquo; </span><span class="c29">Educative</span><span>, www.educative.io/edpresso/what-is-the-toupper-function-in-c. </span></p><p class="c35"><span>&ldquo;X86 Calling Conventions.&rdquo; </span><span class="c29">Wikipedia</span><span>, Wikimedia Foundation, 24 Mar. 2021, en.wikipedia.org/wiki/X86_calling_conventions. </span></p><p class="c35 c12"><span class="c1"></span></p><p class="c35 c12"><span class="c1"></span></p></body></html>